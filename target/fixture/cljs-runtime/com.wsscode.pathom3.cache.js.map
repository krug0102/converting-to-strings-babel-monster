{"version":3,"sources":["com/wsscode/pathom3/cache.cljc"],"mappings":";AASA,AAAA;AAAA;;;uCAAA,vCAAaS;;AAAb,IAAAT,wEAAA,WAC0BU,MAAKC,UAAUC;AADzC,AAAA,IAAAX,kBAAA,EAAA,UAAA,OAAA,hBAC0BS,qBAAAA;IAD1BR,kBAAA,CAAAC,gDAAA,AAAAC,YAAAH;AAAA,AAAA,GAAA,GAAA,CAAAC,mBAAA;AAAA,QAAAA,gDAAAA,mEAAAA,rBAC0BQ,+CAAAA,zCAAKC,+CAAAA,rCAAUC,+CAAAA;;AADzC,IAAAP,kBAAA,CAAAF,gDAAA;AAAA,AAAA,GAAA,GAAA,CAAAE,mBAAA;AAAA,QAAAA,gDAAAA,mEAAAA,rBAC0BK,+CAAAA,zCAAKC,+CAAAA,rCAAUC,+CAAAA;;AADzC,MAAA,AAAAN,2BAAA,mCAC0BI;;;;AAD1B,AAAA,kDAAA,lDACGP,4GAAuBO,MAAKC,UAAUC;AADzC,AAAA,GAAA,EAAA,GAAA,UAAA,aAAA,GAAA,CAAA,4EAAA,tGAC0BF,0BAAAA;AAD1B,OAC0BA,yEAAAA,MAAKC,UAAUC;;AADzC,OAAAZ,sEAC0BU,MAAKC,UAAUC;;;;AADzC,IAAAL,8DAAA,WAEgBG,MAAKC;AAFrB,AAAA,IAAAV,kBAAA,EAAA,UAAA,OAAA,hBAEgBS,qBAAAA;IAFhBR,kBAAA,CAAAM,sCAAA,AAAAJ,YAAAH;AAAA,AAAA,GAAA,GAAA,CAAAC,mBAAA;AAAA,QAAAA,gDAAAA,iEAAAA,nBAEgBQ,6CAAAA,vCAAKC,6CAAAA;;AAFrB,IAAAN,kBAAA,CAAAG,sCAAA;AAAA,AAAA,GAAA,GAAA,CAAAH,mBAAA;AAAA,QAAAA,gDAAAA,iEAAAA,nBAEgBK,6CAAAA,vCAAKC,6CAAAA;;AAFrB,MAAA,AAAAL,2BAAA,yBAEgBI;;;;AAFhB,AAAA;;;;;;wCAAA,xCAEGF,wFAAaE,MAAKC;AAFrB,AAAA,GAAA,EAAA,GAAA,UAAA,aAAA,GAAA,CAAA,kEAAA,5FAEgBD,0BAAAA;AAFhB,OAEgBA,+DAAAA,MAAKC;;AAFrB,OAAAJ,4DAEgBG,MAAKC;;;;AAFrB,AAQA,AAAA,AAAA,CAAA,AAAA,iEAAAE,jEACEC;;AADF,CAAA,AAAA,AACEA,8FACA,WAAwBJ,MAAKC,UAAUC;AAAvC,AAAA,gBAAA,ZAAwBF;AAAxB,AACE,YAAA,AAAAK,RAAMC,wBAAON;AAAb,AACE,IAAAO,qBAAe,AAACE,eAAKH,MAAML;AAA3B,AAAA,oBAAAM;AAAA,YAAAA,RAASC;AAAT,AACE,OAACE,cAAIF;;AACL,IAAMG,MAAI,CAACT,kCAAAA,oCAAAA;AAAX,AACE,AAACU,mDAAMZ,UAAKa,gBAAMZ,UAAUU;;AAC5BA;;;;AARV,CAAA,AAAA,AACEP,oFASA,WAAcJ,MAAKC;AAAnB,AAAA,gBAAA,ZAAcD;AAAd,AACE,sBAAA,AAAAK,fAACI,+BAAMT,WAAKC;;;AAXhB,AAAA,CAAA,AAAA,qEAAAE,rEAaEW;;AAbF,CAAA,AAAA,AAaEA,kGACA,WAAwBd,MAAKC,UAAUC;AAAvC,AAAA,gBAAA,ZAAwBF;AAAxB,AACE,YAAA,AAAAK,RAAMC,wBAAON;AAAb,AACE,IAAAO,qBAAe,AAACE,eAAKH,MAAML;AAA3B,AAAA,oBAAAM;AAAA,YAAAA,RAASC;AAAT,AACE,OAACE,cAAIF;;AACL,IAAMG,MAAI,CAACT,kCAAAA,oCAAAA;AAAX,AACE,yDAAA,8CAAA,vGAAQF,uGAAAA,9CAAKe,8FAAMd,UAAUU;;AAC7BA;;;;AApBV,CAAA,AAAA,AAaEG,wFASA,WAAcd,MAAKC;AAAnB,AAAA,gBAAA,ZAAcD;AAAd,AACE,sBAAA,AAAAK,fAACI,+BAAMT,WAAKC;;AAEhB,+CAAA,/CAAMe,sGAAcC;AAApB,AAAuB,GAAA,GAAA,MAAA,LAAuBA;AAAvB,GAAA,EAAA,WAAA,CAAAd,gCAAA,AAAuBc;AAAvB;;AAAA,GAAA,EAAA,AAAuBA;AAAvB,OAAAC,kCAAYnB,qCAAWkB;;AAAvB;;;;AAAA,OAAAC,kCAAYnB,qCAAWkB;;;AAE9C;;;;;;;;;;;;;;;;;mCAAA,nCAAOE,8EAgBJC,gBAAgBC,IAAIpB,UAAUC;AAhBjC,AAkBE,IAAAK,qBAAgB,AAACgB,4CAAIF,IAAID;AAAzB,AAAA,oBAAAb;AAAA,kBAAAA,dAASe;AAAT,AACE,OAAC7B,gDAAsB6B,YAAOrB,UAAUC;;AACxC,QAACA,kCAAAA,oCAAAA;;;AAEL;;;uCAAA,vCAAOsB,sFAEJlB,MAAML;AAFT,AAIE,OAACH,sCAAYQ,MAAML","names":["com$wsscode$pathom3$cache$CacheStore$_cache_lookup_or_miss$dyn","x__4521__auto__","m__4522__auto__","com.wsscode.pathom3.cache/-cache-lookup-or-miss","goog/typeOf","m__4519__auto__","cljs.core/missing-protocol","com$wsscode$pathom3$cache$CacheStore$_cache_find$dyn","com.wsscode.pathom3.cache/-cache-find","com.wsscode.pathom3.cache/CacheStore","this","cache-key","f","cljs.core/PROTOCOL_SENTINEL","cljs.core/Atom","cljs.core/deref","cache","temp__5751__auto__","entry","cljs.core/find","cljs.core/val","res","cljs.core.swap_BANG_","cljs.core/assoc","cljs.core/Volatile","cljs.core.assoc","com.wsscode.pathom3.cache/cache-store?","x","cljs.core/native-satisfies?","com.wsscode.pathom3.cache/cached","cache-container","env","cache*","cljs.core.get","com.wsscode.pathom3.cache/cache-find"],"sourcesContent":["(ns com.wsscode.pathom3.cache\n  (:require\n    [com.fulcrologic.guardrails.core :refer [<- => >def >defn >fdef ? |]])\n  #?(:clj\n     (:import\n       (clojure.lang\n         Atom\n         Volatile))))\n\n(defprotocol CacheStore\n  (-cache-lookup-or-miss [this cache-key f])\n  (-cache-find [this cache-key]\n    \"Implement a way to read a cache key from the cache. If there is a hit, you must\n    return a map entry for the result, otherwise return nil. The map-entry can make\n    the distinction between a miss (nil return) vs a value with a miss (a map-entry with\n    a value of nil)\"))\n\n(extend-protocol CacheStore\n  Atom\n  (-cache-lookup-or-miss [this cache-key f]\n    (let [cache @this]\n      (if-let [entry (find cache cache-key)]\n        (val entry)\n        (let [res (f)]\n          (swap! this assoc cache-key res)\n          res))))\n\n  (-cache-find [this cache-key]\n    (find @this cache-key))\n\n  Volatile\n  (-cache-lookup-or-miss [this cache-key f]\n    (let [cache @this]\n      (if-let [entry (find cache cache-key)]\n        (val entry)\n        (let [res (f)]\n          (vswap! this assoc cache-key res)\n          res))))\n\n  (-cache-find [this cache-key]\n    (find @this cache-key)))\n\n(defn cache-store? [x] (satisfies? CacheStore x))\n\n(>defn cached\n  \"Try to read some value from a cache, otherwise run and cache it.\n\n  cache-container is a keyword for the cache container name, consider that the environment\n  has multiple cache atoms. If the cache-container key is not present in the env, the\n  cache will be ignored and will always run f.\n\n  cache-key is how you decide, in that cache container, what key should be used for\n  this cache try.\n\n  f needs to a function of zero arguments.\n\n  Example:\n\n      (cached ::my-cache {::my-cache (atom {})} [3 :foo]\n        (fn [] (run-expensive-operation)))\"\n  [cache-container env cache-key f]\n  [keyword? map? any? fn? => any?]\n  (if-let [cache* (get env cache-container)]\n    (-cache-lookup-or-miss cache* cache-key f)\n    (f)))\n\n(>defn cache-find\n  \"Read from cache, without trying to set.\"\n  [cache cache-key]\n  [cache-store? any? => (? map-entry?)]\n  (-cache-find cache cache-key))\n"]}