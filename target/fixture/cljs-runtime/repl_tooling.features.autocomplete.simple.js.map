{"version":3,"sources":["repl_tooling/features/autocomplete/simple.cljs"],"mappings":";AAMA,AAAKA,0DACH,2DAAA,AAAA,3DAACC,6CAAKC;AAIR,yDAAA,zDAAeC;AAEf,8DAAA,9DAAOC,oIAAmBC;AAA1B,AACE,OAACC,cAAI,iBAAAC,YAASF;IAATE,gBAAA,EAAA,CAAAA,aAAA,OAAA,KAAA,yCAAAA,zCACSC;IADTD,gBAAA,EAAA,CAAAA,iBAAA,OAAA,KAAA,AAAA,uFAAAA;AAAA,AAAA,GAAA,CAAAA,iBAAA;AAAA;;AAGS,OAACE,4CAAI,WAAKC;AAAL,AAAA,kDAAA,qDAAA,8DAAA,+DAAoCA;GAAzCH;;;;AAEhB,AAAeI,4IAGR,AAACF,4CAAI,gEAAA,WAAAI,3EAACC,6CAAKC,zKACX,6CAAA,7CAACC;AADI,AAAgB,QAAA,iDAAAH;IADrBD,AACA,cAAA;AAGP,sDAAA,tDAAOK,oHAAWC;AAAlB,AACE,OAACC,sBAAW,4CAAKD,QAAQP;;AAE3B,oDAAA,pDAAMS,gHAASC,KAAKC,QAAQC;AAA5B,AACE,IAAML,SAAO,eAAA,uFAAKK,xEAAW,AAACC,iBAAOrB,hCAAcsB,fAAKA;IAClDC,MAAI,CAAA,iDAAA,iCAAA,YAAA,4CAAA,+CAAA,oCAAA,sCAAA,4CAAA,4BAAA,oBAAA,qGAAA,UAAA,sBAAA,MAAA,tGAW+C,AAACT,oDAAUM;AAZpE,AAgBE,oBAAI,AAACI,oBAAUT;AACb,OAAA,AAAI,8DAAA,2CAAA,uEAAA,0DAAA,1OAACU,qDAAUP,KAAKK,8GAAgBJ,qFAC1BlB,mEACC,qBAAA,rBAACyB;;AACZ,0DAAA,nDAACC;;;AAEP,qDAAA,rDAAMC,kHAAUV,KAAKC,QAAQJ;AAA7B,AACE,IAAMA,aAAO,4CAAA,eAAA,uFAAKA,xEAAO,AAACM,iBAAOrB,hCAAcsB,fAAKA;IAC9CO,qBAAa,kBAAA,lBAACC,uBAAaf;IAC3BgB,UAAQ,kBAAIF,oBACF,kCAAA,OAAA,zCAACG,uBAAYjB,sBACbI;IACVc,UAAQ,sDAAA,TAAKF;IACbR,MACA,CAAA,mDAAA,KAAA,oEAAA,gFAAA,qPAAA,0IAAA,6IAAA,KAAA,YAAA,4CAAA,uHAAA,SAAA,2BAAA,8BAAA,n6BAAgDU,+PAI3C,sCAAA,2GAAA,/HAAMJ,oBACJ,CAAA,8EAAA,TAA8BE,8DAEhC,sCAAA,MAAA,1BAAIF,yLAGoChC,6KAGe,AAACiB,oDAAUC;AApB7E,AAwBE,oBAAI,AAACS,oBAAUT;AACb,OAAA,AAAI,8DAAA,2CAAA,uEAAA,0DAAA,1OAACU,qDAAUP,KAAKK,8GAAgBJ,qFAC1BlB,mEACC,qBAAA,rBAACyB;;AACZ,0DAAA,nDAACC","names":["repl-tooling.features.autocomplete.simple/special-forms","cljs.core.mapv","cljs.core/str","repl-tooling.features.autocomplete.simple/valid-prefix","repl-tooling.features.autocomplete.simple/normalize-results","result","cljs.core/vec","G__138329","repl-tooling.editor-helpers/parse-result","cljs.core.map","c","repl-tooling.features.autocomplete.simple/re-char-escapes","cljs.core/set","p1__138333#","cljs.core.juxt","cljs.core/identity","cljs.core.into","repl-tooling.features.autocomplete.simple/re-escape","prefix","clojure.string/escape","repl-tooling.features.autocomplete.simple/for-clj","repl","ns-name","txt-prefix","cljs.core/re-seq","cljs.core/last","cmd","cljs.core/not-empty","repl_tooling.eval.eval","cljs.core/constantly","promesa.core.promise","repl-tooling.features.autocomplete.simple/for-cljs","have-prefix?","cljs.core/re-find","ns-part","clojure.string/replace","ex-name"],"sourcesContent":["(ns repl-tooling.features.autocomplete.simple\n  (:require [clojure.string :as str]\n            [promesa.core :as p]\n            [repl-tooling.eval :as eval]\n            [repl-tooling.editor-helpers :as helpers]))\n\n(def special-forms\n  (mapv str\n       '(case* catch def defrecord* deftype* do finally fn* if js* let*\n          letfn* loop* new ns quote recur set! throw try)))\n\n(def ^:private valid-prefix #\"/?([a-zA-Z0-9\\-.$!?\\/><*=\\?_]+)\")\n\n(defn- normalize-results [result]\n  (vec (some->> result\n                helpers/parse-result\n                :result\n                (map (fn [c] {:type :function :candidate c})))))\n\n(def ^:private re-char-escapes\n  (->> \"\\\\.*+|?()[]{}$^\"\n       set\n       (map (juxt identity #(str \"\\\\\" %)))\n       (into {})))\n\n(defn- re-escape [prefix]\n  (str/escape (str prefix) re-char-escapes))\n\n(defn for-clj [repl ns-name txt-prefix]\n  (let [prefix (->> txt-prefix (re-seq valid-prefix) last last)\n        cmd (str \"(clojure.core/let [collect #(clojure.core/map \"\n                                               \"(clojure.core/comp str first) \"\n                                               \"(%1 %2)) \"\n                                     \"refers (collect clojure.core/ns-map *ns*)\"\n                                     \"from-ns (->> (clojure.core/ns-aliases *ns*) \"\n                                               \"(clojure.core/mapcat (fn [[k v]] \"\n                                                 \"(clojure.core/map #(str k \\\"/\\\" %) \"\n                                                 \"(collect clojure.core/ns-publics v)))))] \"\n                  \"(clojure.core/->> refers \"\n                                    \"(concat from-ns) \"\n                                    \"(clojure.core/filter #(re-find #\\\"\"\n                                                           (re-escape txt-prefix) \"\\\" %)) \"\n                                    \"(clojure.core/sort)\"\n                                    \"vec\"\n                  \"))\")]\n    (if (not-empty prefix)\n      (.. (eval/eval repl cmd {:namespace ns-name :ignore true})\n          (then normalize-results)\n          (catch (constantly [])))\n      (p/promise []))))\n\n(defn for-cljs [repl ns-name prefix]\n  (let [prefix (->> prefix (re-seq valid-prefix) last last str)\n        have-prefix? (re-find #\"/\" prefix)\n        ns-part (if have-prefix?\n                  (str/replace prefix #\"/.*\" \"\")\n                  ns-name)\n        ex-name (str ns-part \"/a\")\n        cmd\n        (str \"(cljs.core/let [ns-name (cljs.core/str `\" ex-name \") \"\n             \"                splitted (js->clj (.split ns-name #\\\"[\\\\./]\\\"))\\n\"\n             \"                ns-part (map cljs.core/munge (clojure.core/butlast splitted))\"\n             \"                from-ns (js->clj (.keys js/Object (apply aget (.-global js/goog) ns-part)))\"\n             (when have-prefix?\n               (str \" from-ns (map #(str \\\"\" ns-part \"/\\\" %) from-ns)\"))\n             \"      from-core \"\n             (if have-prefix?\n               \"nil\"\n               \"(js->clj (.keys js/Object (aget js/goog \\\"global\\\" \\\"cljs\\\" \\\"core\\\")))\")\n             \"      both (concat from-ns from-core \" special-forms \")]\"\n             \"(->> both\"\n             \"     (clojure.core/map cljs.core/demunge)\"\n             \"     (clojure.core/filter #(clojure.core/re-find #\\\"\" (re-escape prefix) \"\\\" %))\"\n             \"     (clojure.core/sort)\"\n             \"     (clojure.core/take 50)\"\n             \"))\")]\n    (if (not-empty prefix)\n      (.. (eval/eval repl cmd {:namespace ns-name :ignore true})\n          (then normalize-results)\n          (catch (constantly [])))\n      (p/promise []))))\n"]}