{"version":3,"sources":["com/wsscode/pathom3/format/eql.cljc"],"mappings":";AAWA,AAAA,AAEA,AAAAA,yBAAA,AAAA,yHAAA,AAAA,qRAAA,AAAAC,yDAAA,AAAA,kQAAA,AAAAC,yDAAA,AAAA,uQAAA,wGAAA,0GAAA,2CAAA,qDAAA,mCAAA,6FAAA,AAAA,2EAAA,oFAAA,WAAAC,zgBAA4BK;AAA5B,AAAA,OAAAJ,qBAAAD;GAAA,qDAAAC,qBAAA,+EAAA,WAAAC,iBAAAC;AAAA,AAAA,OAAAC,4CAAAD,iBAAA;GAAA,8FAAA,KAAA,0FAAA,AAAA,6RAAA;AACA,AAAAN,yBAAA,AAAA,6IAAA,AAAA,mIAAA;AAEA;;;;;;;;;;;;;;uDAAA,vDAAMS,sHAaHC;AAbH,AAcE,GAAI,AAACN,qBAAKM;AACR,oDAAA,7CAACC,8EAAQ,AAACC,mDAAU,AAACC,8CAAMC,iBAAO,AAACC,4CAAIN,qDAAsB,AAACO,eAAKN;;yOAC9DA,tCAAMO,nMAAyB,oDAAA,oDAAA,AAAA,2FAAA,5LAACC;;;AAEzC,sCAAA,tCAAMC,oFAAMC;AAAZ,AAAA,kDAAA,qDAAA,qDAAA,sEAAA,FAA0CA,sDAAOA;;AAEjD;;;uDAAA,vDAAMC,sHAEHC;AAFH,AAGE,iDAAA,1CAACC,iGAA0B,iBAAAC,YAAQF;IAARE,gBAAA,EAAA,CAAAA,aAAA,OAAA,KAAA,AAAA,2FAAAA;IAAAA,gBAAA,EAAA,CAAAA,iBAAA,OAAA,KAAA,gBAAAA,hBAAsBC;AAAtB,AAAA,GAAA,CAAAD,iBAAA;AAAA;;AAAA,OAAA,mFAAAA;;;;AAE7B;;;gDAAA,hDAAME,wGAEHJ;AAFH,AAGE,GAAI,AAACD,qDAAgBC;AACnB,OAAA,2FAAA,gBAAA,AAAA,2FAAIA,3GAAcG;;AADpB;;;AAGF;;;gDAAA,hDAAME,wGAEHL;AAFH,2GAGMA,9CAAI,kDAAA,qDAAA,vGAACM,7DAAmB,0NAAA,iHAAA,pUAACC;;AAE/B,0DAAA,kEAAAC,5HAAMI,sIAAwCE;AAA9C,AAAA,IAAAL,cAAAD;IAAAC,kBAAA,AAAAC,4BAAAD;gBAAA,AAAAE,4CAAAF,gBAAA,xEAAkCI;AAAlC,AACE,OAACE,0BAAUD,EAAED;;AAEf;;;;kDAAA,lDAAMG,4GAGHhB,IAAIc;AAHP,AAIE,GAAI,AAACf,qDAAgBC;AACnB,OAACiB,eAAK,WAAKC;AAAL,AACE,GAAI,AAACN,wDAAmBM,iBAAKJ;AAC3B,OAACT,8CAAYa;;AADf;;GAEN,AAACd,8CAAeJ;;AAClBA;;;AAEJ;;;;uDAAA,vDAAMmB,sHAGHnB;AAHH,AAIE,GAAI,AAACD,qDAAgBC;AACnB,IAAMoB,kBAAgB,6CAAA,7CAAC/B,8EAAQ,+CAAA,/CAACgC,6GAAkB,iBAAAC,YAAQtB;IAARsB,gBAAA,EAAA,CAAAA,aAAA,OAAA,KAAA,AAAA,2FAAAA;IAAAA,gBAAA,EAAA,CAAAA,iBAAA,OAAA,KAAA,gBAAAA,hBAAsBnB;AAAtB,AAAA,GAAA,CAAAmB,iBAAA;AAAA;;AAAA,OAAA,2FAAAA;;;AAAlD,AACE,gEAAA,+HAAA,xLAAChB,qDAAMN,iEACKoB,0HACH,sCAAA,2CAAA,qDAAA,qDAAA,3LAACG,wPAAsCH;;AAClDpB;;;AAEJ;;;2CAAA,3CAAOwB,8FAEJC;AAFH,AAIE,GAAI,AAACC,wBAAQD;AAAK,OAACtB,gBAAMsB;;AAAzB;;;AAEF,2CAAA,mDAAAE,9FAAOE;AAAP,AAAA,IAAAD,cAAAD;IAAAC,kBAAA,AAAAlB,4BAAAkB;eAAA,AAAAjB,4CAAAiB,gBAAA,vEAA0BE;AAA1B,sDAGM,+BAAA,/BAACC,mFAAmBD,zIACpB,mJAAA,AAAA,5IAACvB;;AAEP,wDAAA,xDAAMyB,wHAAkB5C;AAAxB,AACE,SAAI,6CAAA,AAAA,7CAAC6C,qGAAO7C,YAAO,AAAC8C,qBAAK9C;;AAE3B,kDAAA,qEAAA+C,vHAAME,4GACHC,IAAIC;AADP,AAAA,IAAAH,cAAAD;IAAAC,kBAAA,AAAA1B,4BAAA0B;UAAAA,NAC0CpC;UAD1C,AAAAW,4CAAAyB,gBAAA,lEACsBX;YADtB,AAAAd,4CAAAyB,gBAAA,pEAC0BhD;WAD1B,AAAAuB,4CAAAyB,gBAAA,nEACgCI;AADhC,AAEE,IAAAC,qBAAW,AAACE,eAAKJ,OAAOd;AAAxB,AAAA,oBAAAgB;AAAA,QAAAA,JAASC;AAAT,AACE,IAAME,MAAI,AAACC,cAAIH;IACT1C,UAAI,EAAI,AAACgC,sDAAiB5C,QAAO,AAAA,gGAAaY,KAAKA;IACnDA,UAAI,uDAAA,6DAAA,WAAA8C,/HAACC,+CAAO/C;AAAR,AAAuB,IAAAgD,mBAAAF;AAAA,AAAA,oBAAAE;AAAAA;;AAAA,0FAAA,2CAAA,oDAAA,AAAA,kDAAA,oEAAA,AAAA;;;AAFjC,AAIE,OAACC,qCACCxB,IACA,kBACE,iBAAAyB,oBAAK,+CAAA,/CAACjD,0CAAmBuC;AAAzB,AAAA,GAAAU;AACK,OAAA,0KAAoDN;;AADzDM;;UADF,qRAAA,zRAGEN,MAEA,AAAC9D,qBAAK8D,MACN,CAACO,8EAAAA,+FAAAA,nBAAeb,2EAAAA,vEAAIM,2EAAAA,vEAAI5C,2EAAAA,YAExB,AAACoD,wCAAiBR,MAClB,AAACvD,6CAAK,AAACgE,gBAAMT,KAAK,4CAAA,WAAAU,vDAAC7D;AAAD,AAAM,sKAAA6D,yFAAAA,vPAACH,8EAAAA,6GAAAA,jCAAeb,yFAAAA,nEAAMtC,yFAAAA;IACxC,iBAAAuD,YAAQX;AAAR,AAAA,GACE,AAACY,iDAA0BZ;AAD7B,yBAAAW,lBAEEE;;AAFFF;;MAVR,AAeEX;;;AAtBR;;;AAwBF;;;8DAAA,sEAAAc,pIAAME;AAAN,AAAA,IAAAD,cAAAD;IAAAC,kBAAA,AAAAjD,4BAAAiD;eAAA,AAAAhD,4CAAAgD,gBAAA,vEAEW7B;AAFX,AAGE,OAAC+B,mBAAQ,eAAA,iFAAA,AAAA,hGAAC5C,sKAAW,4CAAA,5CAACxB,gGAASqC;;AAEjC,0DAAA,1DAAMgC,4HAA0BvB,OAAOT;AAAvC,AACE,IAAMiC,2BAAmB,WAAKjE;AAAL,AAAQ,0BAAA,oNAAKgC,pMACA,AAACkC,+CAAO,6CAAA,mDAAA,hGAACC,4FAAOnE,3JAChBK,nBACA0D;;AAHtC,AAIE,OAACK,+CACC,WAAKpC,aAAShC;AAAd,AACE,GAAI,AAACiE,yBAAmBjE;AACtBgC;;AACA,iEAAA,2CAAA,qDAAA,qDAAA,sDAAA,rQAACqC,6CAAKrC,sNACwBhC,sEACAA;;GAClCgC,SACA,AAACsC,eAAK7B;;AAEZ,qDAAA,rDAAM8B,kHAAqBvC,SAASwC;AAApC,AACE,OAACjF,6CAAKyC,SAAS,AAACrC,4CAAI,WAAKK;AAAL,AAAA,kDAAA,qDAAA,qDAAA,sDAAA,FACuBA,sEACAA;IAAKwE;;AAElD;;;gDAAA,wDAAAC,xGAAOpB,kHAEkCZ,OAAOvC;AAFhD,AAAA,IAAAwE,cAAAD;IAAAC,kBAAA,AAAA9D,4BAAA8D;UAAAA,NAEoClC;yBAFpC,AAAA3B,4CAAA6D,gBAAA,jFAEYC;AAFZ,AAKE,GAAI,AAACC,wCAAiBnC;AACpB,IAAMoC,QAAM,oBAAA,pBAACC,uDAAa,AAACC,eAAKtC;AAAhC,AACE,OAAClD,6CAAKsF,MAAM,6CAAA,WAAAG,xDAACC;AAAD,AAAO,qFAAA,9EAACC,0EAA0B1C,qJACzBD,gDAAiBC,IAAIC,OAAO,8CAAAuC,kBAAA,hEAACxE,kIAAoBN;yMAC5DA,hDACA,AAACgB,oDAAiBuB,5KAElB,iBAAA0C,YAAA,AAAA,1DAGA,iBAAAC;AAHA,AAAA,oBACET;AACA,0DAAAQ,nDAACZ,6DAAoBI;;AAFvBQ;;;AAGA,AAAA,GACE,AAACrB,4DAAuB5D;AACxB,sEAAAkF,/DAACpB,wDAAyBvB;;AAF5B2C;;;;AAGZ3C;;;AAEJ;;;;;;;;4CAAA,5CAAO4C,gGAOJ7C,IAAIC,OAAO6C;AAPd,AASE,OAACjC,8CAAeb,IAAIC,OAAO,AAAC5C,sCAAeyF;;AAE7C;;;gDAAA,hDAAOC,wGAEJC;AAFH,AAIE,GAAI,AAACxG,qBAAKwG;AACR,qBA2BK,AAACW,gDAAQ,8DAAA,WAAAC,zEAACjC,6CAAKkC,3GACfE;AADS,AAAc,GAAI,qBAAAH,rBAACpH;AAAQ,wBAAAoH,jBAACE;;AAAdF;;IA3BvB,AAACX,oBACC,WAAKC,IAAI1F,EAAE2F;AAAX,AACE,GAAI,EAAI,cAAAC,bAAU5F,qCACV,AAAC6F,qCAAW7F;AAClB,OAACqE,6CAAKqB,IACJ,EACE,AAAC1G,qBAAK2G,IACN,iBAAMG,IAAE,CAACP,8EAAAA,iFAAAA,LAAYI,6DAAAA;AAArB,AACE,GAAI,AAACI,cAAID;AAAT,uDACG9F,EAAE8F;;AACH9F;;KALN,EAOE,AAACgG,4BAAYL,IACb,iBAAMM,QAAM,AAAC7B,+CACC,WAAK0B,EAAElD;AAAP,AACE,OAACsD,sCAAkBJ,EAAE,CAACP,8EAAAA,iFAAAA,LAAY3C,6DAAAA;GAFtC,iCAIE+C;AAJd,AAKE,GAAI,AAACI,cAAIE;AAAT,uDACGjG,EAAEiG;;AACHjG;;KAfN,AAkBEA;;;AACJ0F;;GAxBN,iCA0BEF;;AA3BT;;;AA+BF,2DAAA,3DAAMgB,8HAAwBC;AAA9B,AACE,OAAChB,oBACC,WAAKzD,SAAS0E,EAAExG;AAAhB,AACE,OAACmE,6CAAKrC,SAAS,iBAAA2E,YAAQzG;AAAR,AAAA,oBAAY,AAAA,2FAAWA;AAAK,sDAAAyG,UAAA,zDAAC1D,sHAAiBuD;;AAA9CG;;;GAFnB,iCAIEF;;AAEJ,oDAAA,pDAAMG,gHAAoBC,KAAKC;AAA/B,AACE,IAAMC,MAAK,+BAAA,/BAAC9E,mFAAmB,AAAA,2FAAW4E;IACpCG,mBAAK,AAAC5C,+CACC,mBAAA6C,RAAKF;AAAL,AAAA,IAAAG,cAAAD;IAAAC,kBAAA,AAAAtG,4BAAAsG;WAAAA,PAA0BC;UAA1B,AAAAtG,4CAAAqG,gBAAA,lEAAiBvF;AAAjB,AACE,IAAMwF,WAAK,oDAAA,pDAAC1G,+CAAO0G;AAAnB,AACE,GAAI,AAAClG,0BAAU8F,QAAIpF;AACjB,OAACsB,+CAAO8D,QAAIpF,IAAIiF,kDAAmBO;;AACnC,OAAC3G,8CAAMuG,QAAIpF,IAAIwF;;GACrBJ,IACA,AAAA,2FAAWD;AARxB,mFASM,AAACM,uGAAMN,KAAKD,zIACZ,iBAAAQ,vEAMA,OAAC5G;IAND4G,gBAAA,oOAAAA,lOACE,AAACtB,cAAIiB,mBACL,8CAAAK,UAAA,xDAAC7G,qHAAgB,AAACgG,yDAAuBQ;AAF3C,AAAA,GAIE,EAAK,AAACjB,cAAIiB,uBAAM,GAAK,0BAAA,iFAAA,0DAAA,rKAAC/F,8OAAyB,AAAA,mFAAO4F;AACtD,qDAAAQ,cAAA,qDAAA,jHAAC7G;;AALH6G;;KAMA","names":["cljs.spec.alpha/def-impl","cljs.spec.alpha.every_impl","cljs.spec.alpha.tuple_impl","G__157819","cljs.core/map?","i__11949__auto__","v__11950__auto__","cljs.core.nth","cljs.core/any?","com.wsscode.pathom3.format.eql/query-root-properties","query","cljs.core.into","cljs.core.distinct","cljs.core.apply","cljs.core/concat","cljs.core.map","cljs.core/vals","edn-query-language.core/query->ast","cljs.core.mapv","com.wsscode.pathom3.format.eql/prop","k","com.wsscode.pathom3.format.eql/union-children?","ast","com.wsscode.misc.refs/kw-identical?","G__157822","cljs.core/first","com.wsscode.pathom3.format.eql/union-children","com.wsscode.pathom3.format.eql/union->root","cljs.core.assoc","cljs.core.dissoc","p__157823","map__157824","cljs.core/--destructure-map","cljs.core.get","com.wsscode.pathom3.format.eql/union-key-on-data?","union-key","m","cljs.core/contains?","com.wsscode.pathom3.format.eql/pick-union-entry","cljs.core/some","ast'","com.wsscode.pathom3.format.eql/maybe-merge-union-ast","merged-children","cljs.core.mapcat","G__157825","edn-query-language.core/ast->query","com.wsscode.pathom3.format.eql/ident-key","key","cljs.core/vector?","p__157826","map__157827","com.wsscode.pathom3.format.eql/index-ast","children","com.wsscode.misc.coll/index-by","com.wsscode.pathom3.format.eql/recursive-query?","cljs.core._EQ_","cljs.core/int?","p__157830","map__157831","com.wsscode.pathom3.format.eql/map-select-entry","env","source","type","temp__5751__auto__","x","cljs.core/find","val","cljs.core/val","p1__157828#","cljs.core.update","or__4223__auto__","com.wsscode.misc.coll/make-map-entry","and__4221__auto__","com.wsscode.pathom3.format.eql/map-select-ast","com.wsscode.misc.coll/collection?","cljs.core/empty","p1__157829#","G__157834","com.wsscode.misc.coll/coll-append-at-head?","cljs.core/reverse","p__157835","map__157836","com.wsscode.pathom3.format.eql/ast-contains-wildcard?","cljs.core/boolean","com.wsscode.pathom3.format.eql/extend-ast-with-wildcard","children-contains?","cljs.core.filter","cljs.core.comp","cljs.core.reduce","cljs.core.conj","cljs.core/keys","com.wsscode.pathom3.format.eql/include-extra-attrs","attrs","p__157846","map__157847","map-select-include","com.wsscode.misc.coll/native-map?","start","cljs.core/with-meta","cljs.core/meta","p1__157842#","cljs.core.keep","com.wsscode.pathom3.plugin.run_with_plugins","G__157853","G__157852","com.wsscode.pathom3.format.eql/map-select","tx","com.wsscode.pathom3.format.eql/data->query","data","cljs.core/reduce-kv","out","v","cljs.core/Keyword","edn-query-language.core/ident?","q","cljs.core/seq","cljs.core/sequential?","shape","edn-query-language.core/merge-queries","cljs.core.sort_by","p1__157855#","cljs.core/pr-str","cljs.core/ffirst","cljs.core/vec","com.wsscode.pathom3.format.eql/map-children->children","map-children","_","G__157858","com.wsscode.pathom3.format.eql/merge-ast-children","ast1","ast2","idx","idx'","p__157859","map__157860","node","cljs.core.merge","G__157861"],"sourcesContent":["(ns com.wsscode.pathom3.format.eql\n  \"Helpers to manipulate EQL.\"\n  (:require\n    [clojure.spec.alpha :as s]\n    [com.fulcrologic.guardrails.core :refer [<- => >def >defn >fdef ? |]]\n    [com.wsscode.misc.coll :as coll]\n    [com.wsscode.misc.refs :as refs]\n    [com.wsscode.pathom3.attribute :as p.attr]\n    [com.wsscode.pathom3.plugin :as p.plugin]\n    [edn-query-language.core :as eql]))\n\n(declare map-select-ast)\n\n(>def ::prop->ast (s/map-of any? :edn-query-language.ast/node))\n(>def ::map-select-include ::p.attr/attributes-set)\n\n(defn query-root-properties\n  \"Returns a vector with the properties at the root of the query.\n\n  For example:\n\n    (query-root-properties [{:a [:b]} :c])\n    => [:a :c]\n\n  In case the query is a union query, it will merge the roots of then will merge:\n\n    (query-root-properties {:foo [{:a [:b]} :c]\n                            :bar [:a :d]})\n    => [:a :c :d]\"\n  [query]\n  (if (map? query)\n    (into [] (distinct) (apply concat (map query-root-properties (vals query))))\n    (->> query eql/query->ast :children (mapv :key))))\n\n(defn prop [k] {:type :prop :dispatch-key k :key k})\n\n(defn union-children?\n  \"Given an AST point, check if the children is a union query type.\"\n  [ast]\n  (refs/kw-identical? :union (some-> ast :children first :type)))\n\n(defn union-children\n  \"Get union children when its an union, otherwise return nil.\"\n  [ast]\n  (if (union-children? ast)\n    (-> ast :children first :children)))\n\n(defn union->root\n  \"Convert a union entry to a root.\"\n  [ast]\n  (-> ast (assoc :type :root) (dissoc :union-key :query)))\n\n(defn union-key-on-data? [{:keys [union-key]} m]\n  (contains? m union-key))\n\n(defn pick-union-entry\n  \"Check if ast children is a union type. If so, makes a decision to choose a path and\n  return that AST.\"\n  [ast m]\n  (if (union-children? ast)\n    (some (fn [ast']\n            (if (union-key-on-data? ast' m)\n              (union->root ast')))\n      (union-children ast))\n    ast))\n\n(defn maybe-merge-union-ast\n  \"Check if AST entry is a union, if so it computes a new AST entry by combining\n  all union paths as a single entry.\"\n  [ast]\n  (if (union-children? ast)\n    (let [merged-children (into [] (mapcat :children) (some-> ast :children first :children))]\n      (assoc ast\n        :children merged-children\n        :query (eql/ast->query {:type :root :children merged-children})))\n    ast))\n\n(>defn ident-key\n  \"When key is an ident, return the first part of it. Otherwise returns nil.\"\n  [key]\n  [any? => (? ::p.attr/attribute)]\n  (if (vector? key) (first key)))\n\n(>defn index-ast [{:keys [children]}]\n  [:edn-query-language.ast/node => ::prop->ast]\n  ; TODO consider merging issues when key is repeated\n  (-> (coll/index-by :key children)\n      (dissoc '*)))\n\n(defn recursive-query? [query]\n  (or (= '... query) (int? query)))\n\n(defn map-select-entry\n  [env source {:keys [key query type] :as ast}]\n  (if-let [x (find source key)]\n    (let [val (val x)\n          ast (if (recursive-query? query) (:parent-ast ast) ast)\n          ast (update ast :children #(or % [{:key          '*\n                                             :dispatch-key '*}]))]\n      (coll/make-map-entry\n        key\n        (cond\n          (and (refs/kw-identical? type :call)\n               (:com.wsscode.pathom3.connect.runner/mutation-error val))\n          val\n\n          (map? val)\n          (map-select-ast env val ast)\n\n          (coll/collection? val)\n          (into (empty val) (map #(map-select-ast env % ast))\n                (cond-> val\n                  (coll/coll-append-at-head? val)\n                  reverse))\n\n          :else\n          val)))))\n\n(defn ast-contains-wildcard?\n  \"Check if some of the AST children is the wildcard value, which is *.\"\n  [{:keys [children]}]\n  (boolean (some #{'*} (map :key children))))\n\n(defn extend-ast-with-wildcard [source children]\n  (let [children-contains? (fn [k] (->> children\n                                        (filter (comp #{k} :key))\n                                        first\n                                        boolean))]\n    (reduce\n      (fn [children k]\n        (if (children-contains? k)\n          children\n          (conj children {:type         :prop\n                          :key          k\n                          :dispatch-key k})))\n      children\n      (keys source))))\n\n(defn include-extra-attrs [children attrs]\n  (into children (map (fn [k] {:type         :prop\n                               :key          k\n                               :dispatch-key k})) attrs))\n\n(>defn map-select-ast\n  \"Same as map-select, but using AST as source.\"\n  [{::keys [map-select-include] :as env} source ast]\n  [map? any? (s/keys :opt-un [:edn-query-language.ast/children])\n   => any?]\n  (if (coll/native-map? source)\n    (let [start (with-meta {} (meta source))]\n      (into start (keep #(p.plugin/run-with-plugins env ::wrap-map-select-entry\n                           map-select-entry env source (assoc % :parent-ast ast)))\n            (-> ast\n                (pick-union-entry source)\n                :children\n                (cond->\n                  map-select-include\n                  (include-extra-attrs map-select-include))\n                (cond->>\n                  (ast-contains-wildcard? ast)\n                  (extend-ast-with-wildcard source)))))\n    source))\n\n(>defn map-select\n  \"Starting from a map, do a EQL selection on that map. Think of this function as\n  a power up version of select-keys.\n\n  Example:\n  (p/map-select {:foo \\\"bar\\\" :deep {:a 1 :b 2}} [{:deep [:a]}])\n  => {:deep {:a 1}}\"\n  [env source tx]\n  [map? any? ::eql/query => any?]\n  (map-select-ast env source (eql/query->ast tx)))\n\n(>defn data->query\n  \"Helper function to transform a data into an output shape.\"\n  [data]\n  [any? => (? ::eql/query)]\n  (if (map? data)\n    (->> (reduce-kv\n           (fn [out k v]\n             (if (or (keyword? k)\n                     (eql/ident? k))\n               (conj out\n                 (cond\n                   (map? v)\n                   (let [q (data->query v)]\n                     (if (seq q)\n                       {k q}\n                       k))\n\n                   (sequential? v)\n                   (let [shape (reduce\n                                 (fn [q x]\n                                   (eql/merge-queries q (data->query x)))\n                                 []\n                                 v)]\n                     (if (seq shape)\n                       {k shape}\n                       k))\n\n                   :else\n                   k))\n               out))\n           []\n           data)\n         (sort-by (comp pr-str #(if (map? %) (ffirst %) %))) ; sort results\n         vec)))\n\n(defn map-children->children [map-children]\n  (reduce-kv\n    (fn [children _ ast]\n      (conj children (cond-> ast (:children ast) (update :children map-children->children))))\n    []\n    map-children))\n\n(defn merge-ast-children [ast1 ast2]\n  (let [idx  (coll/index-by :key (:children ast1))\n        idx' (reduce\n               (fn [idx {:keys [key] :as node}]\n                 (let [node (dissoc node :query)]\n                   (if (contains? idx key)\n                     (update idx key merge-ast-children node)\n                     (assoc idx key node))))\n               idx\n               (:children ast2))]\n    (-> (merge ast2 ast1)\n        (cond->\n          (seq idx')\n          (assoc :children (map-children->children idx'))\n\n          (and (seq idx') (not (contains? #{:join :root} (:type ast1))))\n          (assoc :type :join))\n        (dissoc :query))))\n"]}