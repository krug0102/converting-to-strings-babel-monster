{"version":3,"sources":["com/wsscode/pathom3/format/shape_descriptor.cljc"],"mappings":"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","names":["cljs.spec.alpha/def-impl","cljs.spec.alpha.every_impl","cljs.spec.alpha.tuple_impl","G__157818","cljs.core/map?","i__11949__auto__","v__11950__auto__","cljs.core.nth","cljs.core/any?","var_args","G__157821","com.wsscode.pathom3.format.shape-descriptor/merge-shapes","js/Error","a","b","cljs.core.merge_with","com.wsscode.pathom3.format.shape-descriptor/data->shape-descriptor","data","cljs.core/reduce-kv","out","k","v","cljs.core.assoc","cljs.core/sequential?","shape","cljs.core.reduce","q","x","com.wsscode.misc.coll.merge_grow","cljs.core/seq","com.wsscode.pathom3.format.shape-descriptor/ast->shape-descriptor","ast","p__157832","map__157833","cljs.core/--destructure-map","cljs.core.get","m","key","type","children","node","com.wsscode.misc.refs/kw-identical?","unions","cljs.core.into","cljs.core.map","com.wsscode.pathom3.format.shape-descriptor/query->shape-descriptor","output","edn-query-language.core/query->ast","com.wsscode.pathom3.format.shape-descriptor/shape-descriptor->ast-children","p__157837","vec__157838","com.wsscode.pathom3.format.shape-descriptor/shape-descriptor->ast","com.wsscode.pathom3.format.shape-descriptor/shape-descriptor->query","p__157841","vec__157843","com.wsscode.pathom3.format.shape-descriptor/relax-empty-collections","required","p__157848","vec__157849","r","cljs.core/contains?","com.wsscode.misc.coll/collection?","cljs.core/empty?","cljs.core.not_EQ_","cljs.core.update","cljs.core/first","G__157857","com.wsscode.pathom3.format.shape-descriptor/missing","available","res","cljs.core.keep","el","attr","cljs.core/key","sub-query","cljs.core/val","temp__5751__auto__","sub-req","and__4221__auto__","com.wsscode.pathom3.format.shape_descriptor.missing","com.wsscode.misc.coll/make-map-entry","com.wsscode.pathom3.format.shape-descriptor/difference","s1","s2","sub","cljs.core/find","sub-diff","or__4223__auto__","cljs.core/empty","com.wsscode.pathom3.format.shape-descriptor/intersection","sub-inter","com.wsscode.pathom3.format.shape-descriptor/select-shape","p1__157865#","com.wsscode.pathom3.format.shape-descriptor/select-shape-filter-coll","sub-keys","cljs.core/keys","p1__157866#","s'","com.wsscode.pathom3.format.shape-descriptor/select-shape-filtering","cljs.core/every?","G__157868","com.wsscode.pathom3.format.shape_descriptor.select_shape_filtering","required-shape"],"sourcesContent":["(ns com.wsscode.pathom3.format.shape-descriptor\n  \"Shape descriptor is a format to describe data. This format optimizes for fast detection\n  of value present given a shape and a value path.\n\n  This namespace contains functions to operate on maps in the shape descriptor format.\"\n  (:require\n    [clojure.spec.alpha :as s]\n    [com.fulcrologic.guardrails.core :refer [<- => >def >defn >fdef ? |]]\n    [com.wsscode.misc.coll :as coll]\n    [com.wsscode.misc.refs :as refs]\n    [edn-query-language.core :as eql]))\n\n(>def ::shape-descriptor\n  \"Describes the shape of a nested map using maps, this is a way to efficiently check\n  for the presence of a specific path on data.\"\n  (s/map-of any? ::shape-descriptor))\n\n(defn merge-shapes\n  \"Deep merge of shapes, it takes in account that values are always maps.\"\n  ([a] a)\n  ([a b]\n   (cond\n     (and (map? a) (map? b))\n     (merge-with merge-shapes a b)\n\n     (map? a) a\n     (map? b) b\n\n     :else b)))\n\n(defn data->shape-descriptor\n  \"Helper function to transform a map into an shape descriptor.\n\n  Edges of shape descriptor are always an empty map. If a value of the map is a sequence.\n  This will combine the keys present in all items on the final shape description.\n\n  WARN: this idea of merging is still under test, this may change in the future.\"\n  [data]\n  (if (map? data)\n    (reduce-kv\n      (fn [out k v]\n        (assoc out\n          k\n          (cond\n            (map? v)\n            (data->shape-descriptor v)\n\n            (sequential? v)\n            (let [shape (reduce\n                          (fn [q x]\n                            (coll/merge-grow q (data->shape-descriptor x)))\n                          {}\n                          v)]\n              (if (seq shape)\n                shape\n                {}))\n\n            :else\n            {})))\n      {}\n      data)))\n\n(>defn ast->shape-descriptor\n  \"Convert EQL AST to shape descriptor format.\"\n  [ast]\n  [:edn-query-language.ast/node => ::shape-descriptor]\n  (reduce\n    (fn [m {:keys [key type children] :as node}]\n      (if (refs/kw-identical? :union type)\n        (let [unions (into [] (map ast->shape-descriptor) children)]\n          (reduce merge-shapes m unions))\n        (assoc m key (ast->shape-descriptor node))))\n    {}\n    (:children ast)))\n\n(>defn query->shape-descriptor\n  \"Convert pathom output format into shape descriptor format.\"\n  [output]\n  [:edn-query-language.core/query => ::shape-descriptor]\n  (ast->shape-descriptor (eql/query->ast output)))\n\n(>defn shape-descriptor->ast-children\n  \"Convert pathom output format into shape descriptor format.\"\n  [shape]\n  [::shape-descriptor => vector?]\n  (into []\n        (map (fn [[k v]]\n               (if (seq v)\n                 {:type         :join\n                  :key          k\n                  :dispatch-key k\n                  :children     (shape-descriptor->ast-children v)}\n                 {:type         :prop\n                  :key          k\n                  :dispatch-key k})))\n        shape))\n\n(>defn shape-descriptor->ast\n  \"Convert pathom output format into shape descriptor format.\"\n  [shape]\n  [::shape-descriptor => map?]\n  {:type     :root\n   :children (shape-descriptor->ast-children shape)})\n\n(>defn shape-descriptor->query\n  \"Convert pathom output format into shape descriptor format.\"\n  [shape]\n  [::shape-descriptor => :edn-query-language.core/query]\n  (into []\n        (map (fn [[k v]]\n               (if (seq v)\n                 {k (shape-descriptor->query v)}\n                 k)))\n        shape))\n\n(defn relax-empty-collections\n  \"This helper will remove nested requirements when data is an empty collection. This\n  allows for nested inputs with empty collections to still be valid in shape.\"\n  [required data]\n  (reduce\n    (fn [r [k v]]\n      (cond\n        (and (contains? r k)\n             (coll/collection? v)\n             (empty? v))\n        (assoc r k {})\n\n        (and (contains? r k)\n             (not= (get r k) {}))\n        (update r k relax-empty-collections v)\n\n        :else\n        r))\n    required\n    (cond\n      (map? data)\n      data\n\n      (coll/collection? data)\n      (first data)\n\n      :else\n      nil)))\n\n(>defn missing\n  \"Given some available and required shapes, returns which items are missing from available\n  in the required. Returns nil when nothing is missing.\"\n  ([available required]\n   [::shape-descriptor ::shape-descriptor\n    => (? ::shape-descriptor)]\n   (let [res (into\n               {}\n               (keep (fn [el]\n                       (let [attr      (key el)\n                             sub-query (val el)]\n                         (if (contains? available attr)\n                           (if-let [sub-req (and (seq sub-query)\n                                                 (missing (get available attr) sub-query))]\n                             (coll/make-map-entry attr sub-req))\n                           el))))\n               required)]\n     (if (seq res) res)))\n  ([available required data]\n   [::shape-descriptor ::shape-descriptor map? => (? ::shape-descriptor)]\n   (missing available (relax-empty-collections required data))))\n\n(>defn difference\n  \"Like set/difference, for shapes.\"\n  [s1 s2]\n  [(? ::shape-descriptor) (? ::shape-descriptor) => ::shape-descriptor]\n  (reduce-kv\n    (fn [out k sub]\n      (if-let [x (find s2 k)]\n        (let [v (val x)]\n          (if (and (seq sub) (seq v))\n            (let [sub-diff (difference sub v)]\n              (if (seq sub-diff)\n                (assoc out k sub-diff)\n                out))\n            out))\n        (assoc out k sub)))\n    (or (empty s1) {})\n    s1))\n\n(>defn intersection\n  \"Like set/intersection, for shapes.\"\n  [s1 s2]\n  [(? ::shape-descriptor) (? ::shape-descriptor) => ::shape-descriptor]\n  (reduce-kv\n    (fn [out k sub]\n      (if-let [x (find s2 k)]\n        (let [v (val x)]\n          (if (and (seq sub) (seq v))\n            (let [sub-inter (intersection sub v)]\n              (if (seq sub-inter)\n                (assoc out k sub-inter)\n                (assoc out k {})))\n            (assoc out k {})))\n        out))\n    (or (empty s1) {})\n    s1))\n\n(>defn select-shape\n  \"Select the parts of data covered by shape. This is similar to select-keys, but for\n  nested shapes.\"\n  [data shape]\n  [map? ::shape-descriptor => map?]\n  (reduce-kv\n    (fn [out k sub]\n      (if-let [x (find data k)]\n        (let [v (val x)]\n          (if (seq sub)\n            (cond\n              (map? v)\n              (assoc out k (select-shape v sub))\n\n              (coll/collection? v)\n              (assoc out k (into (empty v) (map #(select-shape % sub)) v))\n\n              :else\n              (assoc out k v))\n            (assoc out k v)))\n        out))\n    (empty data)\n    shape))\n\n(declare select-shape-filtering)\n\n(defn- select-shape-filter-coll [out k v sub sub-req]\n  (let [sub-keys (keys sub-req)]\n    (assoc out k\n      (into (empty v)\n            (keep #(let [s' (select-shape-filtering % sub sub-req)]\n                     (if (every? (fn [x] (contains? s' x)) sub-keys)\n                       s'))) v))))\n\n(>defn select-shape-filtering\n  \"Like select-shape, but in case of collections, if some item doesn't have all the\n  required keys, its removed from the collection.\"\n  ([data shape]\n   [map? ::shape-descriptor => map?]\n   (select-shape-filtering data shape shape))\n  ([data shape required-shape]\n   [map? ::shape-descriptor (? ::shape-descriptor) => map?]\n   (reduce-kv\n     (fn [out k sub]\n       (if-let [x (find data k)]\n         (let [v (val x)]\n           (if (seq sub)\n             (let [sub-req (get required-shape k)]\n               (cond\n                 (map? v)\n                 (assoc out k (select-shape-filtering v sub sub-req))\n\n                 (coll/collection? v)\n                 (select-shape-filter-coll out k v sub sub-req)\n\n                 :else\n                 (assoc out k v)))\n             (assoc out k v)))\n         out))\n     (empty data)\n     shape)))\n"]}