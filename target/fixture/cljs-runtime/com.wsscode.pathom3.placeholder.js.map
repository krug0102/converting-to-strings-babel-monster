{"version":3,"sources":["com/wsscode/pathom3/placeholder.cljc"],"mappings":";AAMA,AAAAA,yBAAA,AAAA,mJAAA,AAAA,6TAAA,AAAAC,yDAAA,AAAA,wFAAA,2CAAA,6FAAA,AAAA,2EAAA,oFAAA,WAAAC,1UAAwCC;AAAxC,AAAA,4BAAAD,rBAAsDE;GAAtD,0EAAA,8FAAA,KAAA,0FAAA,AAAA,qUAAA,vhBAAsDA;AAEtD;;;yDAAA,iEAAAC,1HAAOI,oIAEmCE;AAF1C,AAAA,IAAAL,cAAAD;IAAAC,kBAAA,AAAAC,4BAAAD;2BAAA,AAAAE,4CAAAF,gBAAA,nFAEmBI;AAFnB,AAKE,IAAMA,2BAAqB,iBAAAE,mBAAIF;AAAJ,AAAA,oBAAAE;AAAAA;;AAAA,wFAAA;;;AAA3B,AACE,SAAK,cAAAC,bAAUF,qCACV,AAACG,0BAAUJ,yBAAqB,AAACK,oBAAUJ;;AAEpD;;;+EAAA,uFAAAK,tKAAOE;AAAP,AAAA,IAAAD,cAAAD;IAAAC,kBAAA,AAAAV,4BAAAU;UAAAA,NAE6BG;WAF7B,AAAAZ,4CAAAS,gBAAA,nEAEmBE;AAFnB,AAKE,uBAAgC,+CAAA,WAAAI,1DAACC,hBAAkCC;AAAnC,AAAS,kEAAAF,3DAACd,uDAAiBW;mEAAtD,iBAAAR,mBAAIO,nDAASE,jDAAK,6CAAA,IAAA,jDAACC;AAAnB,AAAA,oBAAAV;AAAAA;;AAAA","names":["cljs.spec.alpha/def-impl","cljs.spec.alpha.every_impl","G__157960","cljs.core/string?","cljs.core/set?","p__157961","map__157962","cljs.core/--destructure-map","cljs.core.get","com.wsscode.pathom3.placeholder/placeholder-key?","placeholder-prefixes","k","or__4223__auto__","cljs.core/Keyword","cljs.core/contains?","cljs.core/namespace","p__157968","map__157969","com.wsscode.pathom3.placeholder/find-closest-non-placeholder-parent-join-key","path","env","cljs.core/rseq","cljs.core.drop","p1__157966#","cljs.core.remove","cljs.core/first"],"sourcesContent":["(ns com.wsscode.pathom3.placeholder\n  (:require\n    [clojure.spec.alpha :as s]\n    [com.fulcrologic.guardrails.core :refer [<- => >def >defn >fdef ? |]]\n    [com.wsscode.pathom3.path :as p.path]))\n\n(>def ::placeholder-prefixes (s/coll-of string? :kind set?))\n\n(>defn placeholder-key?\n  \"Check if a given key is a placeholder.\"\n  [{::p.path/keys [placeholder-prefixes]} k]\n  [(s/keys :opt [::placeholder-prefixes]) any?\n   => boolean?]\n  (let [placeholder-prefixes (or placeholder-prefixes #{\">\"})]\n    (and (keyword? k)\n         (contains? placeholder-prefixes (namespace k)))))\n\n(>defn find-closest-non-placeholder-parent-join-key\n  \"Find the closest parent key that's not a placeholder key.\"\n  [{::p.path/keys [path] :as env}]\n  [(s/keys :opt [::p.path/path])\n   => (? ::p.path/path-entry)]\n  (->> (or path []) rseq (drop 1) (remove #(placeholder-key? env %)) first))\n"]}