{"version":3,"sources":["repl_tooling/processor.cljs"],"mappings":"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","names":["repl-tooling.processor/process-message","t","m","p-exc/process-errors","repl-tooling.processor/macro-spec?","cause","via","and__4221__auto__","cljs.core._EQ_","cljs.core/first","cljs.core/re-matches","repl-tooling.processor/invalid-signature?","repl-tooling.processor/spec-ref","repl-tooling.processor/length-ref","repl-tooling.processor/stringify","vector-of-keywords","cljs.core/count","or__4223__auto__","G__37968","cljs.core/rest","p1__37962#","cljs.core.map","p1__37965#","cljs.core.filter","p__37988","map__37991","cljs.core/--destructure-map","cljs.core.get","repl-tooling.processor/has-alpha-nil?","path","repl-tooling.processor/BABEL-NS","repl-tooling.processor/babel-fn-spec?","probs","p","sp/select","sp/ALL","sp/multi-path","p1__37997#","sp/selected-any?","sp/if-path","cljs.core/seqable?","sp/STAY","clojure.string/starts-with?","cljs.core/simple-symbol?","cljs.core/vector?","cljs.core/map?","cljs.core/qualified-keyword?","cljs.core/sequential?","repl-tooling.processor/macro-predicates","repl-tooling.processor/predicate-name","cljs.core/Symbol","G__38000","cljs.core/Var","cljs.core/set?","cljs.core/seq?","cljs.core/re-find","cljs.core.apply","cljs.core/str","cljs.core/flatten","G__38013","repl-tooling.processor/print-failed-predicates","p1__38019#","cljs.core.distinct","p1__38020#","p1__38021#","p2__38022#","cljs.core.sort","p1__38023#","cljs.core/second","clojure.string.join","repl-tooling.processor/invalid-macro-params?","problems","via-lasts","cljs.core/last","cljs.core/empty?","p1__38037#","cljs.core/every?","repl-tooling.processor/invalid-sig-message","s","vec__38064","cljs.core.nth","_","what","should-be","cljs.core.println"],"sourcesContent":["(ns repl-tooling.processor\n (:require [clojure.string :as s]\n           ; [com.rpl.specter :as sp]\n           ; [errors.prettify-exception :as p-exc]\n           ; [errors.utils :as u]\n           ; [errors.dictionaries :as d]\n           ; [clojure.core.specs.alpha]\n           ))\n\n;;an atom that record original error response\n; (def recorder (atom {:msg [] :detail []}))\n;\n; (defn reset-recorder\n;   \"This function reset the recorder atom\"\n;   []\n;   (reset! recorder {:msg [] :detail []}))\n;\n; (defn update-recorder-msg\n;   \"takes an unfixed error message, and put it into the recorder\"\n;   [inp-message]\n;   (swap! recorder update-in [:msg] conj inp-message))\n;   ;(swap! recorder assoc :msg inp-message))\n;\n; (defn update-recorder-detail\n;   \"takes error message details, and put them into the recorder\"\n;   [inp-message]\n;   (swap! recorder update-in [:detail] conj inp-message))\n\n (defn process-message\n   \"Takes a type and a message and returns a string based on the match found in error\n   dictionary\"\n   [t m]\n   (p-exc/process-errors t m))\n\n(defn macro-spec?\n  \"Takes an exception cause and via. Returns a true value\n   if it's a spec error for a macro, a false value otherwise.\"\n  [cause via]\n   (and (= :macro-syntax-check (:clojure.error/phase (:data (first via))))\n        (and cause (re-matches #\"Call to (.*) did not conform to spec.\" cause))))\n\n(defn invalid-signature?\n  \"Takes an exception cause and via. Returns a true value\n   if it's an invalid signature error, a false value otherwise.\"\n  [cause via]\n   (and (= :macro-syntax-check (:clojure.error/phase (:data (first via))))\n        (and cause (re-matches #\"Invalid signature (.*) should be a (.*)\" cause))))\n\n(def spec-ref {:number \"a number\", :collection \"a sequence\", :string \"a string\", :coll \"a sequence\",\n                :map-arg \"a two-element-vector\", :function \"a function\", :ratio \"a ratio\", :future \"a future\", :key \"a key\", :map-or-vector \"a map or a vector\",\n                :regex \"a regular expression\", :num-non-zero \"a number that's not zero\", :num \"a number\", :lazy \"a lazy sequence\"\n                :wrong-path \"of correct type and length\", :sequence \"a sequence of vectors with only 2 elements or a map with key-value pairs\",\n                :number-greater-than-zero \"a number that's greater than zero\",\n                :collection-map \"a sequence\" :only-collection \"a collection\"})\n\n(def length-ref {:b-length-one \"one argument\", :b-length-two \"two arguments\", :b-length-three \"three arguments\", :b-length-zero-or-greater \"zero or more arguments\",\n                 :b-length-greater-zero \"one or more arguments\", :b-length-greater-one \"two or more arguments\", :b-length-greater-two \"three or more arguments\",\n                 :b-length-zero-to-one \"zero or one arguments\", :b-length-one-to-two \"one or two arguments\", :b-length-two-to-three \"two or three arguments\",\n                 :b-length-two-to-four \"two or up to four arguments\", :b-length-one-to-three \"one or up to three arguments\", :b-length-zero-to-three \"zero or up to three arguments\"})\n\n(defn stringify\n  \"Takes a vector of keywords of failed predicates. If there is\n  only one, returns the result of looking it up in spec-ref.\n  Otherwise returns the first result of looking up the rest of\n  the keywords in spec-ref, as a string.\n  Returns an empty string if no matches are found\"\n  [vector-of-keywords]\n  (if (= (count vector-of-keywords) 1)\n      (or (spec-ref (first vector-of-keywords)) \"unknown condition\")\n      (or (->> (rest vector-of-keywords)\n               (map #(spec-ref %))\n               (filter #(not (nil? %)))\n               first)\n           \"unknown condition\")))\n\n(defn has-alpha-nil?\n  [{:keys [path]}]\n  (.contains path :clojure.spec.alpha/nil))\n\n; (defn filter-extra-spec-errors\n;    \"problem-maps looks like [{:path [:a :b ...] ~~} {:path [] ~~} ...]\n;    Filters through problem-maps removing any map that contains :clojure.spec.apha/nil in :path or :reason\"\n;    [problem-maps]\n;    (if (> (count problem-maps) 1)\n;        (->> problem-maps\n;             (filter #(not (has-alpha-nil? %)))\n;             (filter #(not (contains? % :reason))))\n;        problem-maps))\n;\n; (defn- multi-spec-fails->str\n;   \"Takes a list of spec failure problems and the :in path and returns\n;    a string of failed predicates.\"\n;   [probs in]\n;   (->> probs\n;       (sp/select [sp/ALL (sp/pred #(= (:in %) in)) :pred])\n;       (s/join \" or \")))\n\n\n; (defn babel-spec-message\n;   \"Takes ex-info data of our babel spec error, returns a modified message as a string\"\n;   [ex-data]\n;   (let [{problem-list :clojure.spec.alpha/problems fn-full-name :clojure.spec.alpha/fn args-val :clojure.spec.alpha/args} ex-data\n;         {:keys [path pred val via in reason]} (-> problem-list\n;                                            filter-extra-spec-errors\n;                                            first)\n;         fn-name (d/get-function-name (str fn-full-name))\n;         function-args-val (s/join \" \" (map d/non-macro-spec-arg->str args-val))\n;         arg-number (first in)\n;         [print-type print-val] (d/type-and-val val)]\n;     (cond reason \"babel specs are inconsistent, sorry\" ; If the only spec contains :reason, this means that babel specs for length aren't set up right\n;           (re-matches #\"corefns\\.corefns/b-length(.*)\" (str pred))\n;                       (str \"Wrong number of arguments in (\"\n;                            fn-name\n;                            \" \"\n;                            function-args-val\n;                            \"): the function \"\n;                            fn-name\n;                            \" expects \"\n;                            (length-ref (keyword (d/get-function-name (str (first via)))))\n;                            \" but was given \"\n;                            (if (or (nil? val) (= (count val) 0)) \"no\" (d/number-word (count val)))\n;                            (if (= (count val) 1) \" argument.\" \" arguments.\"))\n;            :else\n;                       (str \"The \"\n;                            (d/arg-str arg-number)\n;                            \" of (\"\n;                            fn-name\n;                            \" \"\n;                            function-args-val\n;                            \") was expected to be \"\n;                            (stringify path)\n;                            \" but is \"\n;                            print-type\n;                            (d/anon-fn-handling print-val)\n;                            \" instead.\"))))\n\n; (defn third-party-spec\n;   \"Handles spec that's not from babel: takes the exc-data\n;   and returns the message as a string.\"\n;   [ex-data]\n;   (let [{problem-list :clojure.spec.alpha/problems fn-full-name :clojure.spec.alpha/fn args-val :clojure.spec.alpha/args} ex-data\n;          filtered-probs (filter-extra-spec-errors problem-list)\n;          {:keys [path pred val via in]} (first filtered-probs)\n;          fn-name (d/get-function-name (str fn-full-name))\n;          function-args-val (s/join \" \" (map d/non-macro-spec-arg->str args-val))\n;          arg-number (first in)\n;          [print-type print-val] (d/type-and-val val)]\n;      (cond\n;        (= (:reason (first problem-list)) \"Extra input\")\n;           (str\n;             \"Wrong number of arguments in (\"\n;             fn-name\n;             \" \"\n;             function-args-val\n;             \"): the function \"\n;             fn-name\n;             \" requires fewer than \"\n;             (d/number-word (count args-val))\n;             \" arguments.\")\n;        (and (= (:reason (first problem-list)) \"Insufficient input\") (> (count args-val) 0))\n;           (str\n;             \"Wrong number of arguments in (\"\n;             fn-name\n;             \" \"\n;             function-args-val\n;             \"): the function \"\n;             fn-name\n;             \" requires more than \"\n;             (d/number-word (count args-val))\n;             \" arguments.\")\n;       (= (:reason (first problem-list)) \"Insufficient input\") ;; (= (count args-val) 0)\n;          (str\n;            \"Wrong number of arguments in (\"\n;            fn-name\n;            \" \"\n;            function-args-val\n;            \"): the function \"\n;            fn-name\n;            \" cannot be called with no arguments.\")\n;        (= 1 (count filtered-probs))\n;           (str\n;             \"In (\"\n;             fn-name\n;             \" \"\n;             function-args-val\n;             \") the \"\n;             (d/arg-str arg-number)\n;             \", which is \"\n;             print-type\n;             (d/anon-fn-handling print-val)\n;             \", fails a requirement: \"\n;             pred)\n;          ;; if there are more errors with the same :in, pull all the pred names\n;          :else\n;            (str\n;              \"In (\"\n;              fn-name\n;              \" \"\n;              function-args-val\n;              \") the \"\n;              (d/arg-str arg-number)\n;              \", which is \"\n;              print-type\n;              (d/anon-fn-handling print-val)\n;              \", fails a requirement: \"\n;              (multi-spec-fails->str filtered-probs in)))))\n\n(def BABEL-NS \":corefns.corefns\")\n\n(defn- babel-fn-spec?\n  \"Takes a list of spec problems, returns true if any of the :via or :pred\n   starts with :corefns.corefns\"\n  [probs]\n  (let [p (sp/select [sp/ALL (sp/multi-path :via :pred)] probs)]\n        (sp/selected-any? [sp/ALL\n                           ;; Can handle a vector or a list of predicates or a single predicate:\n                           (sp/if-path seqable? sp/ALL sp/STAY)\n                           #(s/starts-with? (str %) BABEL-NS)]\n                          p)))\n\n\n; (defn spec-message\n;  \"Takes exception data and calls either babel spec processing or third-party spec\n;   processing.\"\n;  [data]\n;  (let [{probs :clojure.spec.alpha/problems} data]\n;  (if (babel-fn-spec? probs)\n;      (babel-spec-message data)\n;      (third-party-spec data))))\n\n\n;; Predicates are mapped to a pair of a position and a beginner-friendly\n;; name. Negative positions are later discarded\n(def macro-predicates {#'clojure.core/simple-symbol? [0 \" a name\"],\n  #'clojure.core/vector? [1 \" a vector\"], #'clojure.core/map? [2 \" a hashmap\"],\n  #'clojure.core/qualified-keyword? [-1 \" a keyword\"],\n  #'clojure.core/sequential? [1 \" a vector\"]}) ; while other sequential constructs are possible, for beginners \"a vector\" is sufficient\n\n(defn- predicate-name\n  \"Takes a failed predicate from a macro spec, returns a vector\n   of its name and position\"\n  [p]\n  (cond (symbol? p) (or (macro-predicates (resolve (quote p))) [10 \" unknown type\"]) ; for debugging purposes\n        (set? p) [-1 \" one of specific keywords\"]\n        (= (str p) \"(clojure.core/fn [%] (clojure.core/not= (quote &) %))\") [-1 \" not &\"]\n        (and (seq? p) (re-find #\"clojure.core/sequential\\?\" (apply str (flatten p))))\n             (macro-predicates #'clojure.core/sequential?)\n        :else  [10 (str \" unknown type \" p)]))\n\n(defn- print-failed-predicates\n  \"Takes a vector of hashmaps of failed predicates and returns a string\n   that describes them for beginners\"\n  [probs]\n  (->> probs\n       (filter #(nil? (:reason %))) ; eliminate \"Extra input\" and \"Insufficient input\"\n       (map :pred) ; get the failed predicates\n       (distinct) ; eliminate duplicates\n       (map #(predicate-name %)) ; get position/name pairs\n       (sort #(< (first %1) (first %2))) ; sort by the position\n       (filter #(>= (first %) 0)); remove negative positions\n       (map second) ; take names only\n       (distinct) ; eliminate duplicates\n       (s/join \" or\"))) ; join into a string with \" or\" as a separator\n\n; (defn- process-group\n;   \"Takes a vector of a value and hashmaps of predicates it failed and returns\n;    a string describing the problems\"\n;   [[val probs]]\n;   (let [printed-group (print-failed-predicates probs)]\n;        (if (not= printed-group \"\")\n;            (str \"In place of \"\n;                 (d/print-macro-arg val :nil)\n;                 \" the following are allowed:\"\n;                 (print-failed-predicates probs) \"\\n\")\n;            \"\")))\n\n; (defn- process-paths-macro\n;   \"Takes the 'problems' part of a spec for a macro and returns a description\n;    of the problems as a string\"\n;   [problems]\n;   (let [grouped (group-by :val (map #(select-keys % [:pred :val :reason]) problems))]\n;        (apply str (map process-group grouped))))\n\n(defn- invalid-macro-params?\n  \"Takes the 'problems' part of a spect for a macro and returns true\n   if all problems refer to the parameters and false otherwise\"\n   [problems]\n   (let [via-lasts (distinct (map str (map last (map :via problems))))]\n        (and (not (empty? via-lasts)) (every? #(or (re-find #\"param-list\" %) (re-find #\"param+body\" %)) via-lasts))))\n\n; (defn- let-macros\n;   \"Takes parts of the spec message for let and related macros and returns an error message as a string\"\n;   [fn-name value problems]\n;   (str \"Syntax problems with (\"\n;         fn-name\n;         \" \"\n;         (d/print-macro-arg (first value))\n;         ;; The 'if' is needed so that there is a space before the args, but no space when there\n;         ;; are no args:\n;         (if (= (count (rest value)) 0)\n;             \"\"\n;             (str \" \" (d/print-macro-arg (rest value) :no-parens)))\n;         \"):\\n\"\n;         (process-paths-macro problems)))\n\n; (defn- defn-macros\n;   \"Takes parts of the spec message for defn and defn- and returns an error message as a string\"\n;   [fn-name value problems]\n;   (let [n (count problems)\n;         val-str (d/print-macro-arg value :no-parens)\n;         probs-labeled (u/label-vect-maps problems) ; each spec fail is labeled with its position in 'problems'\n;         probs-grouped (group-by :in probs-labeled)\n;         error-name (str \"Syntax problems with (\" fn-name (u/with-space-if-needed val-str) \"):\\n\")]\n;         (cond (u/has-match? probs-grouped {:path [:fn-name]})\n;                    (str error-name  (u/missing-name (:val (first problems))))\n;               ;; Multi-arity defn fails with a non-informtive spec failure\n;               (= n 0) (str error-name\n;                            \"Unexpected element(s) outside of the first clause: \"\n;                            (d/print-macro-arg (rest (drop-while #(not (seq? %)) value)) :no-parens))\n;               ;; Special case for defn since a string could be a doc-string and a map\n;               ;; could be a pre/post-conditions map:\n;               (and (= n 1) (u/has-match? probs-grouped {:path [:fn-tail] :reason \"Insufficient input\"}))\n;                    (str error-name fn-name \" is missing a vector of parameters.\")\n;               (u/has-match? probs-grouped {:reason \"Insufficient input\", :pred :clojure.core.specs.alpha/binding-form})\n;                    (str error-name fn-name \" is missing a name after &.\")\n;               (u/has-every-match? probs-grouped\n;                    [{:pred 'clojure.core/vector?}\n;                     {:pred '(clojure.core/fn [%] (clojure.core/or (clojure.core/nil? %) (clojure.core/sequential? %)))}])\n;                    (str error-name (u/missing-vector-message probs-grouped value))\n;               (and (> n 1) (u/all-match? probs-grouped {:reason \"Extra input\"}))\n;                    (str error-name (u/process-nested-error probs-grouped))\n;               (u/has-every-match? probs-grouped\n;                   [{:pred 'clojure.core/vector?, :path [:fn-tail :arity-1 :params]}\n;                    {:pred 'clojure.core/vector?, :path [:fn-tail :arity-n :bodies :params]}])\n;                   (str error-name (u/missing-vector-message-seq\n;                                     (first (u/get-match probs-grouped\n;                                                  {:pred 'clojure.core/vector?, :path [:fn-tail :arity-1 :params]}))\n;                                        value))\n;               (u/has-every-match? probs-grouped\n;                    [{:reason \"Extra input\", :path [:fn-tail :arity-1 :params]}\n;                     {:pred 'clojure.core/vector?, :path [:fn-tail :arity-n :bodies :params]}])\n;                    (str error-name (u/parameters-not-names\n;                                      (first (u/get-match probs-grouped\n;                                                  {:reason \"Extra input\", :path [:fn-tail :arity-1 :params]}))\n;                                       value))\n;               (u/has-every-match? probs-grouped\n;                    [{:reason \"Extra input\", :path [:fn-tail :arity-1 :params]}\n;                     {:path [:fn-tail :arity-n :bodies :params :var-params :var-form :local-symbol]}])\n;                    (str error-name (u/parameters-not-names\n;                                      (first (u/get-match probs-grouped\n;                                                  {:path [:fn-tail :arity-n :bodies :params :var-params :var-form :local-symbol]}))\n;                                       value))\n;               (u/has-every-match? probs-grouped\n;                    [{:path [:fn-tail :arity-1 :params :var-params :var-form :local-symbol]}\n;                     {:path [:fn-tail :arity-1 :params :var-params :var-form :seq-destructure]}\n;                     {:path [:fn-tail :arity-1 :params :var-params :var-form :map-destructure]}\n;                     {:pred 'clojure.core/vector?, :path [:fn-tail :arity-n :bodies :params]}])\n;                   (str error-name (u/parameters-not-names\n;                                      (first (u/get-match probs-grouped\n;                                                   {:path [:fn-tail :arity-1 :params :var-params :var-form :local-symbol]}))\n;                                      value))\n;               :else \"Placeholder message for defn\")))\n\n; (defn- fn-macros\n;   \"Takes parts of the spec message for fn and returns an error message as a string\"\n;   [fn-name value problems]\n;   (let [n (count problems)\n;        val-str (d/print-macro-arg value :no-parens)\n;        probs-labeled (u/label-vect-maps problems) ; each spec fail is labeled with its position in 'problems'\n;        probs-grouped (group-by :in probs-labeled)\n;        error-name (str \"Syntax problems with (\" fn-name (u/with-space-if-needed val-str) \"):\\n\")\n;        multi-clause? (u/multi-clause-fn? value)]\n;        (cond (and (= n 1) ((u/key-vals-match {:reason \"Insufficient input\", :path [:fn-tail]}) (first problems)))\n;                   (str error-name \"fn is missing a vector of parameters.\")\n;              (u/has-match? probs-grouped {:reason \"Insufficient input\", :pred :clojure.core.specs.alpha/binding-form})\n;                   (str error-name\n;                        (if multi-clause?\n;                            (u/err-clause-str value\n;                                              (:in (first problems)))\n;                             \"\")\n;                        \"fn is missing a name after &.\")\n;              (u/has-every-match? probs-grouped\n;                   [{:pred 'clojure.core/vector?}\n;                    {:pred '(clojure.core/fn [%] (clojure.core/or (clojure.core/nil? %) (clojure.core/sequential? %)))}])\n;                    (str error-name (u/missing-vector-message probs-grouped value))\n;              (and (> n 1) (u/all-match? probs-grouped {:reason \"Extra input\"}))\n;                   (str error-name (u/process-nested-error probs-grouped))\n;              (u/has-every-match? probs-grouped\n;                   [{:pred 'clojure.core/vector?, :path [:fn-tail :arity-1 :params]}\n;                    {:pred 'clojure.core/vector?, :path [:fn-tail :arity-n :params]}])\n;                   (str error-name (u/missing-vector-message-seq\n;                                     (first (u/get-match probs-grouped\n;                                                  {:pred 'clojure.core/vector?, :path [:fn-tail :arity-1 :params]}))\n;                                      value))\n;              (u/has-every-match? probs-grouped\n;                   [{:reason \"Extra input\", :path [:fn-tail :arity-1 :params]}\n;                    {:pred 'clojure.core/vector?, :path [:fn-tail :arity-n :params]}])\n;                   (str error-name (u/parameters-not-names\n;                                     (first (u/get-match probs-grouped\n;                                                  {:reason \"Extra input\", :path [:fn-tail :arity-1 :params]}))\n;                                     value))\n;               ;; multi-arity case, first clause\n;              (u/has-every-match? probs-grouped\n;                  [{:reason \"Extra input\", :path [:fn-tail :arity-n :params]}\n;                   {:pred 'clojure.core/vector?, :path [:fn-tail :arity-1 :params]}])\n;                  (let [prob1 (first (u/get-match probs-grouped\n;                               {:reason \"Extra input\", :path [:fn-tail :arity-n :params]}))]\n;                        (str error-name\n;                             (if multi-clause?\n;                                 (u/err-clause-str value\n;                                                   (:in prob1))\n;                                 \"\")\n;                             (u/parameters-not-names prob1\n;                                                     value)))\n;              (u/has-every-match? probs-grouped\n;                  [{:reason \"Extra input\", :path [:fn-tail :arity-1 :params]}\n;                   {:path [:fn-tail :arity-n :params :var-params :var-form :local-symbol]}])\n;                  (str error-name (u/parameters-not-names\n;                                    (first (u/get-match probs-grouped\n;                                                 {:path [:fn-tail :arity-n :params :var-params :var-form :local-symbol]}))\n;                                    value))\n;              (u/has-every-match? probs-grouped\n;                  [{:pred 'clojure.core/vector?, :path [:fn-tail :arity-1 :params]}\n;                   {:reason \"Insufficient input\", :path [:fn-tail :arity-n :params]}])\n;                  (str error-name (u/parameters-not-names\n;                                    (first (u/get-match probs-grouped\n;                                                 {:pred 'clojure.core/vector?, :path [:fn-tail :arity-1 :params]}))\n;                                    value))\n;               (u/has-every-match? probs-grouped\n;                    [{:path [:fn-tail :arity-1 :params :var-params :var-form :local-symbol]}\n;                     {:path [:fn-tail :arity-1 :params :var-params :var-form :seq-destructure]}\n;                     {:path [:fn-tail :arity-1 :params :var-params :var-form :map-destructure]}\n;                     {:pred 'clojure.core/vector?, :path [:fn-tail :arity-n :params]}])\n;                   (str error-name (u/parameters-not-names\n;                                      (first (u/get-match probs-grouped\n;                                                   {:path [:fn-tail :arity-1 :params :var-params :var-form :local-symbol]}))\n;                                      value))\n;               (and (= n 1) (u/has-match-by-prefix? probs-grouped {:path [:fn-tail :arity-n]}))\n;                    (str error-name\n;                         (if multi-clause?\n;                             (u/err-clause-str value\n;                                               (:in (first problems)))\n;                             \"\")\n;                         (u/clause-single-spec (first problems) ; n=1, so there is only one prob\n;                                               value))\n;               :else (str error-name \"Placeholder for a message for fn\"))))\n\n\n; (defn spec-macro-message\n;   \"Takes the cause and data of a macro spec failure and returns the description of\n;    the problem as a string\"\n;   [cause data]\n;   (let [fn-name-match (nth (re-matches #\"Call to (.*) did not conform to spec.\" cause) 1)\n;         fn-name (if (= (str fn-name-match) \"clojure.core/fn\") \"fn\" (d/get-function-name fn-name-match))\n;         {problems :clojure.spec.alpha/problems value :clojure.spec.alpha/value args :clojure.spec.alpha/args} data\n;         val-str (d/print-macro-arg args :no-parens) ; args is present in cases when there is no value (e.g. multi-arity defn)\n;         n (count problems)]\n;         (cond (#{\"fn\"} fn-name) (fn-macros fn-name args problems)\n;               (#{\"defn\" \"defn-\"} fn-name) (defn-macros fn-name args problems)\n;               (and (= n 1) (= \"Insufficient input\" (:reason (first problems))))\n;                    (str fn-name\n;                         \" requires more parts than given here: (\"\n;                         fn-name\n;                         val-str\n;                         \")\\n\")\n;               ;; should we report the extra parts?\n;               (and (= n 1) (= \"Extra input\" (:reason (first problems))))\n;                    (str fn-name\n;                         \" has too many parts here: (\"\n;                         fn-name\n;                         \" \"\n;                         val-str\n;                         \")\"\n;                         (d/extra-macro-args-info (first problems))\n;                         \"\\n\")\n;               (and (= n 1) (= (resolve (:pred (first problems))) #'clojure.core.specs.alpha/even-number-of-forms?))\n;                    (str fn-name\n;                         \" requires pairs of a name and an expression, but in (\"\n;                         fn-name\n;                         val-str\n;                         \") one element doesn't have a match.\\n\")\n;               (and (= n 1) (= (resolve (:pred (first problems))) #'clojure.core/vector?))\n;                    (str fn-name\n;                         \" requires a vector of name/expression pairs, but is given \"\n;                         (d/print-macro-arg (:val (first problems)) :nil)\n;                         \" instead.\\n\")\n;               (invalid-macro-params? problems)\n;                     (str \"The parameters are invalid in (\"\n;                          fn-name\n;                          \" \"\n;                          val-str\n;                          \")\\n\")\n;               (and (#{\"let\" \"if-let\"} fn-name) (seqable? value))\n;                    (let-macros fn-name value problems)\n;               :else (str \"Syntax problems with (\"\n;                          fn-name\n;                          \" \"\n;                          val-str\n;                          \"):\\n\"\n;                          (process-paths-macro problems)))))\n\n (defn invalid-sig-message\n   \"Takes the cause and symbol of an invalid signature macroexpansion error and\n    returns the description of the problem as a string\"\n   [cause s]\n   (let [[_ what should-be] (re-matches #\"Invalid signature \\\"(.*)\\\" should be a (.*)\" cause)]\n        (str \"Syntax problems in \"\n              s\n              \": instead of \"\n              what\n              \" you need a \" ;; Encountered cases are: list, vector. Later we may need \"an\" article for some cases\n              should-be\n              \".\")))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;;;;;;;;;;;;;;;;;;;;;;;;; Location and stacktrace ;;;;;;;;;;;;;;;;;;;;;;\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n; (defn location-macro-spec\n;   \"Takes the first element of via for a macro spec, returns a string\n;    with the location of the error.\"\n;   [[via1]]\n;   (let [{source :clojure.error/source\n;          line :clojure.error/line\n;          column :clojure.error/column} (:data via1)]\n;          (u/location->str {:source source :line line :column column})))\n;\n;  (defn location-function-spec\n;    \"Takes data of a function spec, returns a string with the location\n;    of the error.\"\n;    [data]\n;    (let [{:keys [source file line]} (:clojure.spec.test.alpha/caller data)\n;          src (or source file)]\n;          (u/location->str {:source src :line line})))\n;\n; (defn location-non-spec\n;   \"Takes the via list of an exception and its stacktrace and returns the location\n;    of the error as a string.\"\n;   [via trace]\n;   (let [loc-via (u/location->str (u/get-line-info via))\n;         ;; The result of u/location->str always has a . at the end\n;         loc-at (if (= loc-via \".\") (u/location->str (u/get-line-info-from-at via)) loc-via)\n;         loc (if (= loc-at \".\") (u/location->str (u/get-line-info-from-stacktrace trace)) loc-at)]\n;         (if (= loc \".\") \"\" loc)))\n\n; (defn location-print-phase-spec\n;   \"Takes the data of a spec error for a print-eval phase and returns\n;    the location of the error as a string.\"\n;   [data]\n;   (let [{:keys [var-scope]} (:clojure.spec.test.alpha/caller data)\n;         fname (d/get-function-name (str var-scope))]\n;         (if (= fname \"anonymous function\")\n;             (str \"Called from an anonymous function; location unknown.\")\n;             (str \"Called from the function: \"\n;                  fname\n;                  \"; location unknown.\"))))\n\n; (defn location-print-phase\n;   \"Takes the via and the trace of an exception and returns available\n;    info about the error location, as a string.\n;    Assumes that the phase of the exception is :print-eval-result\"\n;   [via trace]\n;   (let [f (->> via\n;                last\n;                :at\n;                first)\n;          f1 (u/get-name-from-tr-element f)\n;          fname (if (= f1 \"\") (u/get-fname-from-stacktrace trace) f1)]\n;          (if (= fname \"anonymous function\")\n;              \"In an anonymous function; location unknown.\"\n;              (str \"In function: \" fname \"; location unknown.\"))))\n\n; (defn print-stacktrace\n;   \"Takes an exception and returns its filtered and formatted stacktrace\n;    as a string (with newlines)\"\n;   [exc]\n;   (->> exc\n;        Throwable->map\n;        :trace\n;        u/filter-stacktrace\n;        (take 20)\n;        u/format-stacktrace))\n\n(println \"babel.processor loaded\")\n"]}