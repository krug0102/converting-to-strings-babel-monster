{"version":3,"sources":["duck_repled/repl_protocol.cljc"],"mappings":";AAIA,AAAA;AAAA;;;sCAAA,tCAAaO;;AAAb,IAAAP,2DAAA,WAEKQ,KAAKC,QAAQC;AAFlB,AAAA,IAAAT,kBAAA,EAAA,SAAA,OAAA,fAEKO,oBAAAA;IAFLN,kBAAA,CAAAC,oCAAA,AAAAC,YAAAH;AAAA,AAAA,GAAA,GAAA,CAAAC,mBAAA;AAAA,QAAAA,gDAAAA,sEAAAA,xBAEKM,kDAAAA,7CAAKC,kDAAAA,1CAAQC,kDAAAA;;AAFlB,IAAAL,kBAAA,CAAAF,oCAAA;AAAA,AAAA,GAAA,GAAA,CAAAE,mBAAA;AAAA,QAAAA,gDAAAA,sEAAAA,xBAEKG,kDAAAA,7CAAKC,kDAAAA,1CAAQC,kDAAAA;;AAFlB,MAAA,AAAAJ,2BAAA,sBAEKE;;;;AAFL,AAAA;;;;;;;;;;;;;;;sCAAA,tCACGL,oFACEK,KAAKC,QAAQC;AAFlB,AAAA,GAAA,EAAA,GAAA,SAAA,aAAA,GAAA,CAAA,8DAAA,vFAEKF,yBAAAA;AAFL,OAEKA,2DAAAA,KAAKC,QAAQC;;AAFlB,OAAAV,yDAEKQ,KAAKC,QAAQC;;;;AAFlB,AAiBA,AAAA;;;;;;;;;;;;;;iCAAA,yCAAAC,1EAAME;AAAN,AAAA,IAAAD,YAAA,AAAA;AAAA,AAAA,QAAAA;KAAA;AAAA,OAAAC,6DAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;KAAA;AAAA,OAAAA,6DAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;;AAAA,MAAA,KAAAC,MAAA,CAAA,8DAAA,AAAA;;;;;AAAA,CAAA,+DAAA,/DAAMD,0EAaFL,KAAKC;AAbT,AAakB,iFAAA,1EAACM,6DAAKP,KAAKC;;;AAb7B,CAAA,+DAAA,/DAAMI,0EAcFL,KAAKC,QAAQC;AAdjB,AAeG,IAAMM,SAAO,AAACb,oCAAUK,KAAKC,QAAQ,uDAAA,vDAACQ,+CAAOP;IACvCQ,OAAK,AAAA,2FAAA,RAAOR;AADlB,AAEE,GAAI,AAACS,4BAAWH;AACd,8DAAA,WAAAI,lEAACC,gDAAOL;AAAR,AAAgB,mHAAAI,5GAACE,uGAAMJ;;;AACvB,OAACI,uGAAMJ,KAAKF;;;;AAnBnB,CAAA,yDAAA,zDAAMH;;AAAN","names":["duck-repled$repl-protocol$Evaluator$_evaluate$dyn","x__4521__auto__","m__4522__auto__","duck-repled.repl-protocol/-evaluate","goog/typeOf","m__4519__auto__","cljs.core/missing-protocol","duck-repled.repl-protocol/Evaluator","repl","command","options","var_args","G__159585","duck-repled.repl-protocol/eval","js/Error","duck_repled.repl_protocol.eval","result","cljs.core.dissoc","pass","promesa.core/promise?","p1__159583#","promesa.core.then","cljs.core.merge"],"sourcesContent":["(ns duck-repled.repl-protocol\n  (:refer-clojure :exclude [eval])\n  (:require [promesa.core :as p]))\n\n(defprotocol Evaluator\n  (-evaluate\n    [repl command options]\n    \"Evaluates a command (defined by `command` - a string) into the\nREPL. Command can be multiple forms, and have comments, etc; it can\nalso be invalid Clojure code.\n\n`options` is a map of `:namespace`, `:file`, `:row`, and `:col` (0-based).\nOther keys are allowed, and are REPL-specific - for example, for Shadow-CLJS\nyou can use \\\"shadow remote API\\\" commands, etc.\n\nNeeds to return either a {:result <value>}, value being a valid EDN, or\n{:error <error>}, also value being a valid EDN. Probably on Clojure, <error>\nwill always be an exception, and in JS, can be anything. You can also return\nPromises / Futures, as long as they are Promesa-Compatible. For more information,\nsee Promesa's documentation (specifically, promesa.protocols)\"))\n\n(defn eval\n  \"Evaluates a command. `repl` is an instance of Evaluator, command is a\nstring with clojure command(s) to eval, and `options` is a map containing:\n\n:namespace - a string that points to the namespace the command will run\n:file - the current filename (some REPLs do not support this yet)\n:row  - the current 0-based line (some REPLs do not support this yet)\n:col  - the current 0-based column (some REPLs do not support this yet)\n:pass - a map with parameters that will be included on the result, without any change\nOther keys are allowed, and are REPL-specific - for example, for Shadow-CLJS can\nuse additional keys to change JS targets, for example\n\nReturns {:succes <edn>} or {:error <edn>}, merged with keys passed to `:pass` parameter\"\n  ([repl command] (eval repl command {}))\n  ([repl command options]\n   (let [result (-evaluate repl command (dissoc options :pass))\n         pass (:pass options {})]\n     (if (p/promise? result)\n       (p/then result #(merge pass %))\n       (merge pass result)))))\n"]}