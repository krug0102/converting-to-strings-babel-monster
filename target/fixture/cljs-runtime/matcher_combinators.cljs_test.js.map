{"version":3,"sources":["matcher_combinators/cljs_test.cljc"],"mappings":";AAWA,yDAAA,zDAAMA,0HAAqBC;AAA3B,AACW,OAACC,uGAAM,sCAAA,tCAACC,wBAAgB,KAAAC,cAAeH;;AA0FzC,AACT,AAAAI,6DAAA,mFAAA,6EAAA,+HAAA,WAA2EC;AAA3E,AACE,mCAAA,nCAACC;;AACD,yGAAA,zGAACC,qHAAoB,AAACC,2BAAmBH;;AACzC,GAAM,AAACI,cAAI,AAAA,4GAAmB,AAACC;AAA/B,AACE,AAACH,yGAAQ,AAACI;;AADZ;;AAEA,IAAAC,4BAAmB,AAAA,yFAAUP;AAA7B,AAAA,oBAAAO;AAAA,AAAA,qBAAAA,jBAAWC;AAAX,AACE,AAACN,yGAAQM;;AADX;;AAEA,sMAAA,tMAACN,yGAAQ,AAAA,0FAAWF;;AACpB,OAACS,yCAAqB,AAAA,uFAAST;;;AAEjC,AAAAD,6DAAA,mFAAA,6EAAA,2GAAA,WAAiEC;AAAjE,AACE,mCAAA,nCAACC;;AACD,yGAAA,zGAACC,qHAAoB,AAACC,2BAAmBH;;AACzC,GAAM,AAACI,cAAI,AAAA,4GAAmB,AAACC;AAA/B,AACE,AAACH,yGAAQ,AAACI;;AADZ;;AAEA,IAAAC,4BAAmB,AAAA,yFAAUP;AAA7B,AAAA,oBAAAO;AAAA,AAAA,qBAAAA,jBAAWC;AAAX,AACE,AAACN,yGAAQM;;AADX;;AAEA,yGAAA,zGAACN;;AACD,OAACO,yCAAqB,AAAA,uFAAST","names":["matcher-combinators.cljs-test/with-file+line-info","report","cljs.core.merge","cljs.test/file-and-line","js/Error","cljs.test/report","m","cljs.test/inc-report-counter!","cljs.core.println","cljs.test/testing-vars-str","cljs.core/seq","cljs.test/get-current-env","cljs.test/testing-contexts-str","temp__5753__auto__","message","matcher-combinators.printer/pretty-print"],"sourcesContent":["(ns matcher-combinators.cljs-test\n  \"Internal use. Require `matcher-combinators.test` instead of this\n  namespace.\"\n  #?(:cljs\n     (:require-macros [matcher-combinators.cljs-test]))\n  (:require [matcher-combinators.core :as core]\n            [matcher-combinators.printer :as printer]\n            [matcher-combinators.parser]\n            [matcher-combinators.result :as result]\n            [cljs.test :as t :refer-macros [deftest is]]))\n\n(defn with-file+line-info [report]\n  #?(:cljs (merge (t/file-and-line (js/Error.) 4) report)))\n\n;; This technique was copied from https://github.com/tonsky/datascript\n;; below is the reasoning from the datascript repo:\n\n;;  The matcher-combinators.cljs-test namespace exists only for the side\n;;  effect of extending the cljs.test/assert-expr multimethod.\n\n;;  This has to be done on the clj side of cljs compilation, and\n;;  so we have a separate namespace that is only loaded by cljs\n;;  via a :require-macros clause in datascript.test.core. This\n;;  means we have a clj namespace that should only be loaded by\n;;  cljs compilation.\n\n#?(:clj (do\n(defmethod t/assert-expr 'match? [_ msg form]\n  `(let [args#              (list ~@(rest form))\n         [matcher# actual#] args#]\n     (cond\n       (not (= 2 (count args#)))\n       (t/do-report\n        {:type     :fail\n         :message  ~msg\n         :expected (symbol \"`match?` expects 2 arguments: a `matcher` and the `actual`\")\n         :actual   (symbol (str (count args#) \" were provided: \" '~form))})\n\n       (core/matcher? matcher#)\n       (let [result# (core/match matcher# actual#)]\n         (t/do-report\n           (if (core/indicates-match? result#)\n             {:type     :pass\n              :message  ~msg\n              :expected '~form\n              :actual   (list 'match? matcher# actual#)}\n             (with-file+line-info\n               {:type     :matcher-combinators/mismatch\n                :message  ~msg\n                :expected '~form\n                :actual   (list '~'not (list 'match? matcher# actual#))\n                :markup   (::result/value result#)}))))\n       :else\n       (t/do-report\n         {:type     :fail\n          :message  ~msg\n          :expected (str \"The first argument of match? needs to be a matcher (implement the match protocol)\")\n          :actual   '~form}))))\n\n(defmethod t/assert-expr 'match-with? [_ msg form]\n  `(clojure.test/do-report\n     {:type     :fail\n      :message  ~msg\n      :expected (symbol \"`match-with?` not yet implemented for cljs\")\n      :actual   '~form}))\n\n(defmethod t/assert-expr 'thrown-match? [_ msg form]\n  ;; (is (thrown-with-match? exception-class matcher expr))\n  ;; Asserts that evaluating expr throws an exception of class c.\n  ;; Also asserts that the exception data satisfies the provided matcher.\n  (let [klass   (nth form 1)\n        matcher (nth form 2)\n        body    (nthnext form 3)]\n    `(try ~@body\n          (let [args# (list ~@(rest form))]\n            (if (not (= 3 (count args#)))\n              (clojure.test/do-report\n               {:type     :fail\n                :message  ~msg\n                :expected (symbol \"`thrown-match?` expects 3 arguments: an exception class, a `matcher`, and the `actual`\")\n                :actual   (symbol (str (count args#) \" were provided: \" '~form))})\n              (t/do-report {:type     :fail\n                            :message  ~msg\n                            :expected '~form\n                            :actual   (symbol \"the expected exception wasn't thrown\")})))\n          (catch ~klass e#\n            (let [result# (core/match ~matcher (ex-data e#))]\n              (t/do-report\n               (if (core/indicates-match? result#)\n                 {:type     :pass\n                  :message  ~msg\n                  :expected '~form\n                  :actual   (list 'thrown-match? ~klass ~matcher '~body)}\n                 (with-file+line-info\n                   {:type     :matcher-combinators/exception-mismatch\n                    :message  ~msg\n                    :expected '~form\n                    :actual   (list '~'not (list 'thrown-match? ~klass ~matcher '~body))\n                    :ex-class ~klass\n                    :markup   (::result/value result#)}))))\n            e#))))))\n\n#?(:cljs (do\n(defmethod t/report [::t/default :matcher-combinators/exception-mismatch] [m]\n  (t/inc-report-counter! :fail)\n  (println \"\\nFAIL in\" (t/testing-vars-str m))\n  (when (seq (:testing-contexts (t/get-current-env)))\n    (println (t/testing-contexts-str)))\n  (when-let [message (:message m)]\n    (println message))\n  (println (:ex-class m) \"data mismatches:\")\n  (printer/pretty-print (:markup m)))\n\n(defmethod t/report [::t/default :matcher-combinators/mismatch] [m]\n  (t/inc-report-counter! :fail)\n  (println \"\\nFAIL in\" (t/testing-vars-str m))\n  (when (seq (:testing-contexts (t/get-current-env)))\n    (println (t/testing-contexts-str)))\n  (when-let [message (:message m)]\n    (println message))\n  (println \"mismatch:\")\n  (printer/pretty-print (:markup m)))))\n"]}