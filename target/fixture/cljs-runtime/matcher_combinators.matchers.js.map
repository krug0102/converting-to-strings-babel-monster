{"version":3,"sources":["matcher_combinators/matchers.cljc"],"mappings":"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","names":["matcher-combinators.matchers/non-internal-record?","v","cljs.core/record?","clojure.string/starts-with?","cljs.core/type","matcher-combinators.matchers/equals","expected","cljs.core/sequential?","matcher-combinators.core/->EqualsSeq","cljs.core/set?","matcher-combinators.core/->SetEquals","matcher-combinators.core/->EqualsRecord","cljs.core/map?","matcher-combinators.core/->EqualsMap","matcher-combinators.core/->Value","matcher-combinators.matchers/set-equals","matcher-combinators.matchers/embeds","matcher-combinators.core/->EmbedsSeq","matcher-combinators.core/->SetEmbeds","matcher-combinators.core/->EmbedsMap","matcher-combinators.core/->InvalidType","matcher-combinators.matchers/set-embeds","matcher-combinators.matchers/in-any-order","matcher-combinators.core/->InAnyOrder","matcher-combinators.matchers/prefix","matcher-combinators.core/->Prefix","matcher-combinators.matchers/regex","matcher-combinators.core/->Regex","matcher-combinators.matchers/absent","matcher-combinators.core/->Absent","matcher-combinators.matchers/pred","pred","cljs.core.sequence","cljs.core/seq","cljs.core.concat","cljs.core/List","matcher-combinators.core/->PredMatcher","matcher-combinators.matchers/mismatch","matcher-combinators.core/->Mismatcher","matcher-combinators.matchers/cljs-uri","matcher-combinators.core/->CljsUriEquals","var_args","G__148691","matcher-combinators.matchers/matcher-for","js/Error","matcher-combinators.core/-matcher-for","overrides","matcher-combinators.matchers/->pred","class-or-pred","cljs.core/fn?","cljs.core.partial","cljs.core/instance?","matcher-combinators.matchers/format-overrides","cljs.core.partition","matcher-combinators.matchers/lookup-matcher","value","pred->matcher-overrides","or__4223__auto__","cljs.core.filter","p__148693","vec__148694","cljs.core.nth","matcher","fexpr__148697","cljs.core/first","cljs.core/last","matcher_combinators.matchers.matcher_for","matcher-combinators.matchers/match-with-values","m","cljs.core/reduce-kv","m*","k","cljs.core.assoc","matcher-combinators.matchers/match-with","matcher-combinators.matchers/match-with-elements","coll","cljs.core.reduce","c","cljs.core.conj","cljs.core.vary_meta","cljs.core/meta","cljs.core.update","cljs.core/coll?","cljs.core._EQ_","matcher-combinators.core/Absent","G__148701","fexpr__148700","G__148703","fexpr__148702","fexpr__148705","cljs.core/assoc","G__148707","matcher-combinators.matchers/within-delta","delta","matcher_combinators.matchers.within_delta","actual","matcher-combinators.utils/within-delta?"],"sourcesContent":["(ns matcher-combinators.matchers\n  (:require [clojure.string :as string]\n            [matcher-combinators.core :as core]\n            [matcher-combinators.utils :as utils]\n            #?(:cljs [matcher-combinators.core :refer [Absent]]))\n  #?(:clj (:import [matcher_combinators.core Absent])))\n\n(defn- non-internal-record? [v]\n  (and (record? v)\n       (not (string/starts-with? (-> v type str) \"class matcher_combinators.core\"))))\n\n(defn equals\n  \"Matcher that will match when the given value is exactly the same as the\n  `expected`.\"\n  [expected]\n  (cond\n    (sequential? expected)          (core/->EqualsSeq expected)\n    (set? expected)                 (core/->SetEquals expected false)\n    (non-internal-record? expected) (core/->EqualsRecord expected)\n    (map? expected)                 (core/->EqualsMap expected)\n    :else                           (core/->Value expected)))\n\n(defn set-equals\n  \"Matches a set in the way `(equals some-set)` would, but accepts sequences as\n  the expected matcher argument, allowing one to use matchers with the same\n  submatcher appearing more than once.\"\n  [expected]\n  (core/->SetEquals expected true))\n\n(defn embeds\n  \"Matcher for asserting that the expected is embedded in the actual.\n\n  Behaviour differs depending on the form of the `expected`:\n\n  - map:      matches when the map contains some of the same key/values as the\n              `expected` map.\n  - sequence: order-agnostic matcher that will match when provided a subset of\n              the `expected` sequence.\n  - set:      matches when all the matchers in the `expected` set can be\n              matched with an element in the provided set. There may be more\n              elements in the provided set than there are matchers.\"\n  [expected]\n  (cond\n    (sequential? expected)          (core/->EmbedsSeq expected)\n    (set? expected)                 (core/->SetEmbeds expected false)\n    (non-internal-record? expected) (core/->EqualsRecord expected)\n    (map? expected)                 (core/->EmbedsMap expected)\n    :else                           (core/->InvalidType expected \"embeds\" \"seq, set, map\")))\n\n(defn set-embeds\n  \"Matches a set in the way `(embeds some-set)` would, but accepts sequences\n  as the expected matcher argument, allowing one to use matchers with the same\n  submatcher appearing more than once.\"\n  [expected]\n  (core/->SetEmbeds expected true))\n\n(defn in-any-order\n  \"Matcher that will match when the given a list that is the same as the\n  `expected` list but with elements in a different order.\n\n  Similar to Midje's `(just expected :in-any-order)`\"\n  [expected] (core/->InAnyOrder expected))\n\n(defn prefix\n  \"Matcher that will match when provided a (ordered) prefix of the `expected`\n  list.\n\n  Similar to Midje's `(embeds expected)`\"\n  [expected]\n  (core/->Prefix expected))\n\n(defn regex\n  \"Matcher that will match when given value matches the `expected` regular expression.\"\n  [expected]\n  (core/->Regex expected))\n\n(def absent\n  \"Value-position matcher for maps that matches when containing map doesn't\n  have the key pointing to this matcher.\"\n  (core/->Absent))\n\n(defn pred\n  \"Matcher that will match when `pred` of the actual value returns true.\"\n  [pred]\n  (core/->PredMatcher pred `(~'pred ~pred)))\n\n(defn mismatch\n  \"Negation matcher that takes in an `expected` matcher and passes when it\n  doesn't match the `actual`.\n\n  When possible use positive matching instead as negation matching quickly\n  leads to very unreadable match assertions\"\n  [expected]\n  (core/->Mismatcher expected))\n\n#?(:cljs (defn- cljs-uri [expected]\n           (core/->CljsUriEquals expected)))\n\n(defn matcher-for\n  \"Returns the type-specific matcher object for an expected\n  value. This is used internally to support the match-with matcher,\n  and is also useful for discovery when you want to know which Matcher\n  type is associated to a value.\n\n  Adds :matcher-object? metadata to the returned matcher so that\n  other functions can differentiate between matcher objects and\n  objects that happen to implement the Matcher protocol (which should\n  be all other objects).\"\n  ([expected]\n   (core/-matcher-for expected))\n  ([expected overrides]\n   (core/-matcher-for expected overrides)))\n\n(defn- ->pred [class-or-pred]\n  (if (fn? class-or-pred)\n    class-or-pred\n    (partial instance? class-or-pred)))\n\n(defn- format-overrides [overrides]\n  (if (sequential? overrides)\n    (partition 2 overrides)\n    overrides))\n\n(defn lookup-matcher\n  \"Internal use only. Iterates through pred->matcher-overrides and\n  returns the value (a matcher) bound to the first pred that returns\n  true for value. If no override is found, returns the default matcher\n  for value.\n\n  The legacy API called for a map of type->matcher, which is still\n  supported by wrapping types in (instance? type %) predicates.\"\n  [value pred->matcher-overrides]\n  (or (->> (format-overrides pred->matcher-overrides)\n           (filter (fn [[class-or-pred matcher]] (when ((->pred class-or-pred) value) matcher)))\n           first\n           last)\n      (matcher-for value)))\n\n(declare match-with)\n\n(defn- match-with-values [m overrides]\n  (reduce-kv (fn [m* k v] (assoc m* k (match-with overrides v)))\n             {}\n             m))\n\n(defn- match-with-elements [coll overrides]\n  (reduce (fn [c v] (conj c (match-with overrides v)))\n          (if (set? coll)\n            #{}\n            [])\n          coll))\n\n(defn match-with\n  \"Given a vector (or map) of overrides, returns the appropriate matcher\n  for value (with value wrapped). If no matcher for value is found in\n  overrides, uses the default:\n    embeds for maps\n    regex  for regular expressions\n    equals for everything else\n\n  If value is a collection, recursively applies match-with to its nested\n  values, ignoring nested values that are already wrapped in matchers.\n\n  NOTE that each nested match-with creates a new context, and nested contexts\n  do not inherit the overrides of their parent contexts.\"\n  [overrides value]\n  (vary-meta\n         ;; don't re-wrap a value we've already wrapped\n   (cond (::match-with? (meta value))\n         value\n\n         ;; functions are special because they get treated as predicates\n         (fn? value)\n         value\n\n         ;; TODO: all of the built in matchers are records, but users\n         ;; define matchers by reifying the Matcher protocol, so this\n         ;; would break down. Also, what if a user's domain includes a\n         ;; record with an `:expected` key? Ideally, we should have\n         ;; some other marker to identify a matcher object, and document\n         ;; it in terms of \"your custom Matcher implementations must do\n         ;; x in order to particpate in match-with\"\n         (and (record? value) (map? (:expected value)))\n         (update value :expected match-with-values overrides)\n\n         (and (record? value) (coll? (:expected value)))\n         (update value :expected match-with-elements overrides)\n\n         (= Absent (type value))\n         value\n\n         (map? value)\n         ((matcher-for value overrides)\n          (match-with-values value overrides))\n\n         (coll? value)\n         ((matcher-for value overrides)\n          (match-with-elements value overrides))\n\n         :else\n         ((matcher-for value overrides) value))\n   assoc ::match-with? true))\n\n(defn within-delta\n  \"Given `delta` and `expected`, returns a Matcher that will match\n  when the actual value is within `delta` of `expected`. Given only\n  `delta`, returns a function to be used in the context of `match-with`,\n  e.g.\n\n    (is (match? (m/match-with [number? (m/within-delta 0.01M)]\n                              <expected>)\n                <actual>))\"\n  ([delta]\n   (fn [expected] (within-delta delta expected)))\n  ([delta expected]\n   (core/->PredMatcher\n    (fn [actual] (utils/within-delta? delta expected actual))\n    (str \"within-delta \" expected \" (+/- \" delta \")\"))))\n"]}