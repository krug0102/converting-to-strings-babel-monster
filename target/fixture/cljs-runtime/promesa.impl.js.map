{"version":3,"sources":["promesa/impl.cljc"],"mappings":"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","names":["promesa.impl/*default-promise*","js/Promise","promesa.impl/resolved","v","promesa.impl/rejected","promesa.impl/deferred","state","obj","resolve","reject","x145994","cljs.core/PROTOCOL_SENTINEL","_","promesa.impl/extend-promise!","t","p","it","f","p1__145995#","e","p1__145996#","p1__145997#","p1__145998#","p1__145999#","p1__146000#","p1__146001#","p1__146002#","p1__146003#","p1__146004#","p1__146005#","p1__146006#","p1__146007#","p1__146008#","p1__146009#","p1__146010#","executor","p1__146011#","p1__146012#","goog.object/set","promesa.protocols/IPromise","promesa.protocols/-map","promesa.protocols/-bind","promesa.protocols/-then","promesa.protocols/-mapErr","promesa.protocols/-thenErr","promesa.protocols/-handle","promesa.protocols/-finally","promesa.protocols/-promise","promesa.protocols/IPromiseFactory","js/Error","promesa.impl/promise->str","writer","opts","cljs.core/-write"],"sourcesContent":[";; Copyright (c) 2015-2019 Andrey Antukh <niwi@niwi.nz>\n;; All rights reserved.\n;;\n;; Redistribution and use in source and binary forms, with or without\n;; modification, are permitted provided that the following conditions\n;; are met:\n;;\n;; 1. Redistributions of source code must retain the above copyright\n;;    notice, this list of conditions and the following disclaimer.\n;; 2. Redistributions in binary form must reproduce the above copyright\n;;    notice, this list of conditions and the following disclaimer in the\n;;    documentation and/or other materials provided with the distribution.\n;;\n;; THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n;; IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n;; OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n;; IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,\n;; INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n;; NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n;; DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n;; THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n;; (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n;; THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n(ns ^:no-doc promesa.impl\n  \"Implementation of promise protocols.\"\n  (:require [promesa.protocols :as pt]\n            [promesa.util :as pu]\n            [promesa.exec :as exec])\n  #?(:clj (:import\n           java.util.concurrent.CompletableFuture\n           java.util.concurrent.CompletionStage\n           java.util.concurrent.TimeoutException\n           java.util.concurrent.ExecutionException\n           java.util.concurrent.CompletionException\n           java.util.concurrent.Executor\n           java.util.function.Function\n           java.util.function.Supplier)))\n\n;; --- Global Constants\n\n#?(:cljs (def ^:dynamic *default-promise* js/Promise))\n\n(defn resolved\n  [v]\n  #?(:cljs (.resolve *default-promise* v)\n     :clj (CompletableFuture/completedFuture v)))\n\n(defn rejected\n  [v]\n  #?(:cljs (.reject *default-promise* v)\n     :clj (let [p (CompletableFuture.)]\n            (.completeExceptionally ^CompletableFuture p v)\n            p)))\n\n;; --- Promise Impl\n\n(defn deferred\n  []\n  #?(:clj (CompletableFuture.)\n     :cljs\n     (let [state #js {}\n           obj (new *default-promise*\n                    (fn [resolve reject]\n                      (set! (.-resolve state) resolve)\n                      (set! (.-reject state) reject)))]\n       (specify! obj\n         pt/ICompletable\n         (-resolve! [_ v]\n           (.resolve state v))\n         (-reject! [_ v]\n           (.reject state v))))))\n\n#?(:cljs\n   (defn extend-promise!\n     [t]\n     (extend-type t\n       pt/IPromiseFactory\n       (-promise [p] p)\n\n       pt/IPromise\n       (-map\n         ([it f] (.then it #(f %)))\n         ([it f e] (.then it #(f %))))\n       (-bind\n         ([it f] (.then it #(f %)))\n         ([it f e] (.then it #(f %))))\n       (-then\n         ([it f] (.then it #(f %)))\n         ([it f e] (.then it #(f %))))\n       (-mapErr\n         ([it f] (.catch it #(f %)))\n         ([it f e] (.catch it #(f %))))\n       (-thenErr\n         ([it f] (.catch it #(f %)))\n         ([it f e] (.catch it #(f %))))\n       (-handle\n         ([it f] (.then it #(f % nil) #(f nil %)))\n         ([it f e] (.then it #(f % nil) #(f nil %))))\n       (-finally\n         ([it f] (.then it #(f % nil) #(f nil %)) it)\n         ([it f executor] (.then it #(f % nil) #(f nil %)) it)))))\n\n#?(:cljs\n   (extend-promise! js/Promise))\n\n;; This code allows execute `then`, `map` and all the other promise\n;; chaining functions on any object if the object is a thenable but\n;; does not inherit from js/Promise, this code will automatically\n;; coerce it to a js/Promise instance.\n\n#?(:cljs\n   (extend-type default\n     pt/IPromise\n     (-map\n       ([it f] (pt/-map (pt/-promise it) f))\n       ([it f e] (pt/-map (pt/-promise it) f e)))\n     (-bind\n       ([it f] (pt/-bind (pt/-promise it) f))\n       ([it f e] (pt/-bind (pt/-promise it) f e)))\n     (-then\n       ([it f] (pt/-then (pt/-promise it) f))\n       ([it f e] (pt/-then (pt/-promise it) f e)))\n     (-mapErr\n       ([it f] (pt/-mapErr (pt/-promise it) f))\n       ([it f e] (pt/-mapErr (pt/-promise it) f e)))\n     (-thenErr\n       ([it f] (pt/-thenErr (pt/-promise it) f))\n       ([it f e] (pt/-thenErr (pt/-promise it) f e)))\n     (-handle\n       ([it f] (pt/-handle (pt/-promise it) f))\n       ([it f e] (pt/-handle (pt/-promise it) f e)))\n     (-finally\n       ([it f] (pt/-finally (pt/-promise it) f))\n       ([it f e] (pt/-finally (pt/-promise it) f e)))))\n\n#?(:clj (def fw-identity (pu/->FunctionWrapper identity)))\n\n#?(:clj\n   (extend-protocol pt/IPromise\n     CompletionStage\n     (-map\n       ([it f]\n        (.thenApply ^CompletionStage it\n                    ^Function (pu/->FunctionWrapper f)))\n\n       ([it f executor]\n        (.thenApplyAsync ^CompletionStage it\n                         ^Function (pu/->FunctionWrapper f)\n                         ^Executor (exec/resolve-executor executor))))\n\n     (-bind\n       ([it f]\n        (.thenCompose ^CompletionStage it\n                      ^Function (pu/->FunctionWrapper f)))\n\n       ([it f executor]\n        (.thenComposeAsync ^CompletionStage it\n                           ^Function (pu/->FunctionWrapper f)\n                           ^Executor (exec/resolve-executor executor))))\n\n     (-then\n       ([it f]\n        (.thenCompose ^CompletionStage it\n                      ^Function (pu/->FunctionWrapper (comp pt/-promise f))))\n\n       ([it f executor]\n        (.thenComposeAsync ^CompletionStage it\n                           ^Function (pu/->FunctionWrapper (comp pt/-promise f))\n                           ^Executor (exec/resolve-executor executor))))\n\n     (-mapErr\n       ([it f]\n        (letfn [(handler [e]\n                  (if (instance? CompletionException e)\n                    (f (.getCause ^Exception e))\n                    (f e)))]\n          (.exceptionally ^CompletionStage it\n                          ^Function (pu/->FunctionWrapper handler))))\n\n       ([it f executor]\n        (letfn [(handler [e]\n                  (if (instance? CompletionException e)\n                    (f (.getCause ^Exception e))\n                    (f e)))]\n          ;; ONLY on JDK >= 12 it is there but in jdk<12 will throw an\n          ;; error\n          (.exceptionallyAsync ^CompletionStage it\n                               ^Function (pu/->FunctionWrapper handler)\n                               ^Executor (exec/resolve-executor executor)))))\n\n     (-thenErr\n       ([it f]\n        (letfn [(handler [v e]\n                  (if e\n                    (if (instance? CompletionException e)\n                      (pt/-promise (f (.getCause ^Exception e)))\n                      (pt/-promise (f e)))\n                    it))]\n          (as-> ^CompletionStage it $$\n            (.handle $$ ^BiFunction (pu/->BiFunctionWrapper handler))\n            (.thenCompose $$ ^Function fw-identity))))\n\n       ([it f executor]\n        (letfn [(handler [v e]\n                  (if e\n                    (if (instance? CompletionException e)\n                      (pt/-promise (f (.getCause ^Exception e)))\n                      (pt/-promise (f e)))\n                    (pt/-promise v)))]\n          (as-> ^CompletionStage it $$\n            (.handleAsync $$\n                          ^BiFunction (pu/->BiFunctionWrapper handler)\n                          ^Executor (exec/resolve-executor executor))\n            (.thenCompose $$ ^Function fw-identity)))))\n\n     (-handle\n       ([it f]\n        (as-> ^CompletionStage it $$\n          (.handle $$ ^BiFunction (pu/->BiFunctionWrapper (comp pt/-promise f)))\n          (.thenCompose $$ ^Function fw-identity)))\n\n       ([it f executor]\n        (as-> ^CompletionStage it $$\n          (.handleAsync $$\n                        ^BiFunction (pu/->BiFunctionWrapper (comp pt/-promise f))\n                        ^Executor (exec/resolve-executor executor))\n          (.thenCompose $$ ^Function fw-identity))))\n\n     (-finally\n       ([it f]\n        (.whenComplete ^CompletionStage it\n                       ^BiConsumer (pu/->BiConsumerWrapper f)))\n\n       ([it f executor]\n        (.whenCompleteAsync ^CompletionStage it\n                            ^BiConsumer (pu/->BiConsumerWrapper f)\n                            ^Executor (exec/resolve-executor executor))))\n\n\n     Object\n     (-map\n       ([it f] (pt/-map (pt/-promise it) f))\n       ([it f e] (pt/-map (pt/-promise it) f e)))\n     (-bind\n       ([it f] (pt/-bind (pt/-promise it) f))\n       ([it f e] (pt/-bind (pt/-promise it) f e)))\n     (-handle\n       ([it f] (pt/-handle (pt/-promise it) f))\n       ([it f e] (pt/-handle (pt/-promise it) f e)))\n     (-mapErr\n       ([it f] (pt/-mapErr (pt/-promise it) f))\n       ([it f e] (pt/-mapErr (pt/-promise it) f e)))\n     (-thenErr\n       ([it f] (pt/-thenErr (pt/-promise it) f))\n       ([it f e] (pt/-thenErr (pt/-promise it) f e)))\n     (-finally\n       ([it f] (pt/-finally (pt/-promise it) f))\n       ([it f e] (pt/-finally (pt/-promise it) f e)))\n\n     nil\n     (-map\n       ([it f] (pt/-map (pt/-promise it) f))\n       ([it f e] (pt/-map (pt/-promise it) f e)))\n     (-bind\n       ([it f] (pt/-bind (pt/-promise it) f))\n       ([it f e] (pt/-bind (pt/-promise it) f e)))\n     (-mapErr\n       ([it f] (pt/-mapErr (pt/-promise it) f))\n       ([it f e] (pt/-mapErr (pt/-promise it) f e)))\n     (-thenErr\n       ([it f] (pt/-thenErr (pt/-promise it) f))\n       ([it f e] (pt/-thenErr (pt/-promise it) f e)))\n     (-handle\n       ([it f] (pt/-handle (pt/-promise it) f))\n       ([it f e] (pt/-handle (pt/-promise it) f e)))\n     (-finally\n       ([it f] (pt/-finally (pt/-promise it) f))\n       ([it f e] (pt/-finally (pt/-promise it) f e)))))\n\n#?(:clj\n   (extend-type CompletableFuture\n     pt/ICancellable\n     (-cancel! [it]\n       (.cancel it true))\n     (-cancelled? [it]\n       (.isCancelled it))\n\n     pt/ICompletable\n     (-resolve! [f v] (.complete f v))\n     (-reject! [f v] (.completeExceptionally f v))\n\n     pt/IState\n     (-extract [it]\n       (try\n         (.getNow it nil)\n         (catch ExecutionException e\n           (.getCause e))\n         (catch CompletionException e\n           (.getCause e))))\n\n     (-resolved? [it]\n       (and (not (.isCompletedExceptionally it))\n            (not (.isCancelled it))\n            (.isDone it)))\n\n     (-rejected? [it]\n       (.isCompletedExceptionally it))\n\n     (-pending? [it]\n       (and (not (.isCompletedExceptionally it))\n            (not (.isCancelled it))\n            (not (.isDone it))))))\n\n;; --- Promise Factory\n\n;; This code is responsible of coercing the incoming value to a valid\n;; promise type. In some cases we will receive a valid promise object,\n;; in this case we return it as is. This is useful when you want to\n;; `then` or `map` over a plain value that can be o can not be a\n;; promise object\n\n#?(:clj\n   (extend-protocol pt/IPromiseFactory\n     CompletionStage\n     (-promise [cs] cs)\n\n     Throwable\n     (-promise [e]\n       (rejected e))\n\n     Object\n     (-promise [v]\n       (resolved v))\n\n     nil\n     (-promise [v]\n       (resolved v)))\n\n   :cljs\n   (extend-protocol pt/IPromiseFactory\n     js/Error\n     (-promise [e]\n       (rejected e))\n\n     default\n     (-promise [v]\n       (resolved v))))\n\n;; --- Pretty printing\n\n(defn promise->str\n  [p]\n  \"#<Promise[~]>\")\n\n#?(:clj\n   (defmethod print-method java.util.concurrent.CompletionStage\n     [p ^java.io.Writer writer]\n     (let [status (cond\n                    (pt/-pending? p) \"pending\"\n                    (pt/-rejected? p) \"rejected\"\n                    :else \"resolved\")]\n       (.write writer ^String (format \"#object[java.util.concurrent.CompletableFuture 0x%h \\\"%s\\\"]\" (hash p) status)))))\n\n#?(:cljs\n   (extend-type js/Promise\n     IPrintWithWriter\n     (-pr-writer [p writer opts]\n       (-write writer (promise->str p)))))\n"]}