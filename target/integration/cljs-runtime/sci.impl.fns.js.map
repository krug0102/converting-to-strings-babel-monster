{"version":3,"sources":["sci/impl/fns.cljc"],"mappings":"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","names":["sci.impl.fns/throw-arity","fn-name","macro?","args","js/Error","actual-count","cljs.core/count","cljs.core/PROTOCOL_SENTINEL","this__4461__auto__","writer__4462__auto__","opt__4463__auto__","cljs.core/-write","sci.impl.fns/Recur","sci.impl.fns/->Recur","val","this","p__70324","map__70326","cljs.core/--destructure-map","cljs.core.get","sci.impl.fns/parse-fn-args+body","ctx","interpret","eval-do*","fixed-arity","var-arg-name","params","body","_m","with-meta?","min-var-args-arity","f","bindings","cljs.core/seq","ret","fp","cljs.core/first","cljs.core._EQ_","cljs.core.assoc","cljs.core/second","cljs.core/next","G__70376","G__70377","recur?","recur-val","sci.impl.types/getVal","vec__70393","cljs.core.nth","vec__70397","fixed-args","rest-args","cljs.core.subvec","cljs.core.into","cljs.core/with-meta","sci.impl.fns/lookup-by-arity","arities","arity","cljs.core/some","map__70451","cljs.core/meta","or__4223__auto__","and__4221__auto__","p__70494","map__70500","sci.impl.fns/eval-fn","fn-bodies","self-ref","cljs.core.atom","call-self","cljs.core/deref","cljs.core.apply","cljs.core/assoc-in","single-arity?","p1__70477#","cljs.core.map","arg-count","temp__5751__auto__","p1__70480#","cljs.core.vary_meta","cljs.core/reset!"],"sourcesContent":["(ns sci.impl.fns\n  {:no-doc true}\n  (:require [sci.impl.types :as t]))\n\n(defn throw-arity [fn-name macro? args]\n  (throw (new #?(:clj Exception\n                 :cljs js/Error)\n              (let [actual-count (if macro? (- (count args) 2)\n                                     (count args))]\n                (str \"Cannot call \" fn-name \" with \" actual-count \" arguments\")))))\n\n(deftype Recur #?(:clj [val]\n                  :cljs [val])\n  t/IBox\n  (getVal [this] val))\n\n(defn parse-fn-args+body\n  [ctx interpret eval-do*\n   {:sci.impl/keys [fixed-arity var-arg-name params body] :as _m}\n   fn-name macro? with-meta?]\n  (let [min-var-args-arity (when var-arg-name fixed-arity)\n        f (fn run-fn [& args]\n            (let [;; tried making bindings a transient, but saw no perf improvement (see #246)\n                  bindings (:bindings ctx)\n                  bindings\n                  (loop [args (seq args)\n                         params (seq params)\n                         ret bindings]\n                    (if params\n                      (let [fp (first params)]\n                        (if (= '& fp)\n                          (assoc ret (second params) args)\n                          (do\n                            (when-not args\n                              (throw-arity fn-name macro? args))\n                            (recur (next args) (next params)\n                                   (assoc ret fp (first args))))))\n                      (do\n                        (when args\n                          (throw-arity fn-name macro? args))\n                        ret)))\n                  ctx (assoc ctx :bindings bindings)\n                  ret (if (= 1 (count body))\n                        (interpret ctx (first body))\n                        (eval-do* ctx body))\n                  ;; m (meta ret)\n                  recur? (instance? Recur ret)]\n              (if recur?\n                (let [recur-val (t/getVal ret)]\n                  (if min-var-args-arity\n                    (let [[fixed-args [rest-args]]\n                          [(subvec recur-val 0 min-var-args-arity)\n                           (subvec recur-val min-var-args-arity)]]\n                      (recur (into fixed-args rest-args)))\n                    (recur recur-val)))\n                ret)))]\n    (if with-meta?\n      (with-meta\n        f\n        (if min-var-args-arity\n          {:sci.impl/min-var-args-arity min-var-args-arity}\n          {:sci.impl/fixed-arity fixed-arity}))\n      f)))\n\n(defn lookup-by-arity [arities arity]\n  (some (fn [f]\n          (let [{:sci.impl/keys [fixed-arity min-var-args-arity]} (meta f)]\n            (when (or (= arity fixed-arity )\n                      (and min-var-args-arity\n                           (>= arity min-var-args-arity)))\n              f))) arities))\n\n(defn eval-fn [ctx interpret eval-do* {:sci.impl/keys [fn-bodies fn-name] :as f}]\n  (let [macro? (:sci/macro f)\n        self-ref (atom nil)\n        call-self (fn [& args]\n                    (apply @self-ref args))\n        ctx (if fn-name (assoc-in ctx [:bindings fn-name] call-self)\n                ctx)\n        single-arity? (= 1 (count fn-bodies))\n        f (if single-arity?\n            (parse-fn-args+body ctx interpret eval-do* (first fn-bodies) fn-name macro? false)\n            (let [arities (map #(parse-fn-args+body ctx interpret eval-do* % fn-name macro? true) fn-bodies)]\n              (fn [& args]\n                (let [arg-count (count args)]\n                  (if-let [f (lookup-by-arity arities arg-count)]\n                    (apply f args)\n                    (throw (new #?(:clj Exception\n                                   :cljs js/Error)\n                                (let [actual-count (if macro? (- arg-count 2)\n                                                       arg-count)]\n                                  (str \"Cannot call \" fn-name \" with \" actual-count \" arguments\")))))))))\n        f (if macro?\n            (vary-meta\n             f\n             #(assoc % :sci/macro macro?))\n            f)]\n    (reset! self-ref f)\n    f))\n\n;;;; Scratch\n\n(comment\n  )\n"]}