{"version":3,"sources":["sci/impl/destructure.cljc"],"mappings":"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","names":["sci.impl.destructure/destructure*","bindings","bents","cljs.core.partition","pb","bvec","b","v","pvec","val","gvec","sci.impl.utils.gensym_STAR_","gseq","gfirst","has-rest","cljs.core/some","ret","cljs.core.conj","sci.impl.utils/mark-eval-call","cljs.core/List","cljs.core/seq","n","bs","seen-rest?","firstb","cljs.core/first","cljs.core._EQ_","cljs.core/second","cljs.core/nnext","js/Error","cljs.core.sequence","cljs.core.concat","cljs.core/next","cljs.core/nth","pmap","gmap","defaults","cljs.core/seq?","cljs.core/apply","cljs.core/hash-map","bes","transforms","cljs.core.reduce","mk","cljs.core/Keyword","mkns","cljs.core/namespace","mkn","cljs.core/name","p1__69113#","cljs.core.assoc","cljs.core.keyword","or__4223__auto__","p1__69114#","cljs.core.symbol","cljs.core/str","cljs.core/keys","entry","p1__69117#","p2__69118#","fexpr__69182","cljs.core/val","cljs.core.dissoc","cljs.core/key","fexpr__69184","bb","bk","local","cljs.core/PROTOCOL_SENTINEL","cljs.core/with-meta","cljs.core/meta","cljs.core/not","bv","temp__5751__auto__","default","cljs.core.get","cljs.core/get","cljs.core/Symbol","cljs.core/vector?","cljs.core/map?","process-entry","cljs.core/every?","cljs.core/symbol?","cljs.core.map","kwbs","p1__69120#","cljs.core.filter","cljs.core/ffirst","sci.impl.destructure/destructure"],"sourcesContent":["(ns sci.impl.destructure\n  \"Destructure function, adapted from Clojure and ClojureScript.\"\n  {:no-doc true}\n  (:refer-clojure :exclude [destructure])\n  (:require [sci.impl.utils :refer [gensym* mark-eval-call]]))\n\n(defn destructure* [bindings]\n  (let [bents (partition 2 bindings)\n        pb (fn pb [bvec b v]\n             (let [pvec\n                   (fn [bvec b val]\n                     (let [gvec (gensym* \"vec__\")\n                           gseq (gensym* \"seq__\")\n                           gfirst (gensym* \"first__\")\n                           has-rest (some #{'&} b)]\n                       (loop [ret (let [ret (conj bvec gvec val)]\n                                    (if has-rest\n                                      (conj ret gseq (mark-eval-call (list seq gvec)))\n                                      ret))\n                              n 0\n                              bs b\n                              seen-rest? false]\n                         (if (seq bs)\n                           (let [firstb (first bs)]\n                             (cond\n                               (= firstb '&) (recur (pb ret (second bs) gseq)\n                                                    n\n                                                    (nnext bs)\n                                                    true)\n                               (= firstb :as) (pb ret (second bs) gvec)\n                               :else (if seen-rest?\n                                       (throw #?(:clj (new Exception \"Unsupported binding form, only :as can follow & parameter\")\n                                                 :cljs (new js/Error \"Unsupported binding form, only :as can follow & parameter\")))\n                                       (recur (pb (if has-rest\n                                                    (conj ret\n                                                          gfirst (mark-eval-call `(~first ~gseq))\n                                                          gseq (mark-eval-call `(~next ~gseq)))\n                                                    ret)\n                                                  firstb\n                                                  (if has-rest\n                                                    gfirst\n                                                    (mark-eval-call (list nth gvec n nil))))\n                                              (inc n)\n                                              (next bs)\n                                              seen-rest?))))\n                           ret))))\n                   pmap\n                   (fn [bvec b v]\n                     (let [gmap (gensym* \"map__\")\n                           defaults (:or b)]\n                       (loop [ret (-> bvec (conj gmap) (conj v)\n                                      (conj gmap) (conj (mark-eval-call\n                                                         `(if ~(mark-eval-call `(~seq? ~gmap))\n                                                            ~(mark-eval-call `(~apply ~hash-map ~gmap))\n                                                            ~gmap)))\n                                      ((fn [ret]\n                                         (if (:as b)\n                                           (conj ret (:as b) gmap)\n                                           ret))))\n                              bes (let [transforms\n                                        (reduce\n                                         (fn [transforms mk]\n                                           (if (keyword? mk)\n                                             (let [mkns (namespace mk)\n                                                   mkn (name mk)]\n                                               (cond (= mkn \"keys\")\n                                                     (assoc transforms mk\n                                                            #(keyword (or mkns (namespace %))\n                                                                      (name %)))\n                                                     (= mkn \"syms\")\n                                                     (assoc transforms mk\n                                                            #(symbol (or mkns\n                                                                         (namespace %))\n                                                                     (name %)))\n                                                     (= mkn \"strs\") (assoc transforms mk str)\n                                                     :else transforms))\n                                             transforms))\n                                         {}\n                                         (keys b))]\n                                    (reduce\n                                     (fn [bes entry]\n                                       (reduce #(assoc %1 %2 ((val entry) %2))\n                                               (dissoc bes (key entry))\n                                               ((key entry) bes)))\n                                     (dissoc b :as :or)\n                                     transforms))]\n                         (if (seq bes)\n                           (let [bb (key (first bes))\n                                 bk (val (first bes))\n                                 local (if #?(:clj  (instance? clojure.lang.Named bb)\n                                              :cljs (implements? INamed bb))\n                                         (with-meta (symbol nil (name bb)) (meta bb))\n                                         bb)\n                                 ;; if bk has metadata (:line, :column, etc)\n                                 ;; then it's a binding that needs eval\n                                 bk (if-not (meta bk)\n                                      (list 'quote bk)\n                                      bk)\n                                 bv (if-let [default (get defaults local)]\n                                      (mark-eval-call (list get gmap bk default))\n                                      (mark-eval-call (list get gmap bk)))]\n                             (recur\n                              (if (or (keyword? bb) (symbol? bb)) ;(ident? bb)\n                                (-> ret (conj local bv))\n                                (pb ret bb bv))\n                              (next bes)))\n                           ret))))]\n               (cond\n                 (symbol? b) (-> bvec (conj (if (namespace b)\n                                              (symbol (name b)) b)) (conj v))\n                 (keyword? b) (-> bvec (conj (symbol (name b))) (conj v))\n                 (vector? b) (pvec bvec b v)\n                 (map? b) (pmap bvec b v)\n                 :else (throw\n                        #?(:clj (new Exception (str \"Unsupported binding form: \" b))\n                           :cljs (new js/Error (str \"Unsupported binding form: \" b)))))))\n        process-entry (fn [bvec b] (pb bvec (first b) (second b)))]\n    (if (every? symbol? (map first bents))\n      bindings\n      (if-let [kwbs (seq (filter #(keyword? (first %)) bents))]\n        (throw\n         #?(:clj (new Exception (str \"Unsupported binding key: \" (ffirst kwbs)))\n            :cljs (new js/Error (str \"Unsupported binding key: \" (ffirst kwbs)))))\n        (reduce process-entry [] bents)))))\n\n(defn destructure [b]\n  (destructure* b))\n"]}