{"version":3,"sources":["expectations/platform.cljc"],"mappings":";AAyBA,gCAAA,hCAAMA,wEAASC;AAAf,AAEW,GAAI,eAAAC,dAASD;AAAIA;;AAAjB;;;AAEX;;;AAAKE,qCAEM;6DAAOC;AAAP,AAAa,8BAAA,WAAAC,lCAACC;AAAD,AAAS,uBAAAD,hBAACE;GAASH;;;IAAzBA;;;;EAAAA;;8DAAAA;;;IAAAA;oDAAAA;;;;;;AAElB,AAAKI,+BAEMC;AAEX,sCAAA,tCAAMC;AAAN,AAEW,oEAAA,7DAACC,6CAAE;;AAEd,+BAAA,/BAAMC,sEAAQC;AAAd,AAEW,QAAM,EAAI,AAACH,uCAASI,YAAeC,QAAWF;;AAEzD,oCAAA,pCAAMG,gFAAaC;AAAnB,AAAsB,OAAIA;;AAI1B,kCAAA,lCAAMC;AAAN,AAEW,GAAI,AAACR;AAEC,OAAA,WAAAW;AAAA,AAAE,QAAG,CAAA,QAAO,CAAAA,iDAAAA,+CAAA,OAAAA,2BAAA,SAAO,CAAAA,iDAAAA,+CAAA,OAAAA,2BAAA;sDADnBF,nDAAmBC,AACnB,mDAAA;;AACJ,OAACE;;;AAGd,0CAAA,1CAAMC;AAAN,AACE,yBAAA,lBAACC,2BAEiB,0DAAA,xDAAI,AAACd,uCAAS,AAAYS;;AAE9C,AAAKM,+BAEMC;AAEX,0CAAA,1CAAMC,4FAAmBV;AAAzB,AACE,gHAAA,AAAIA,zGAEkBW;;AAExB,mCAAA,nCAAKC,kFAEQC","names":["expectations.platform/ns-name","ns","cljs.core/Symbol","expectations.platform/bound?","vars","p1__51461#","cljs.core/every?","cljs.core/deref","expectations.platform/format","goog.string/format","expectations.platform/nodejs?","cljs.core._EQ_","expectations.platform/getenv","var","js/process.env","js/window","expectations.platform/get-message","e","expectations.platform/nano-time","js/process","cljs.core.js__GT_clj","p1__51465#","js/performance.now","expectations.platform/on-windows?","cljs.core/re-find","expectations.platform/pprint","cljs.core/println","expectations.platform/print-stack-trace","cljs.core.println","expectations.platform/iref-types","cljs.core/Atom"],"sourcesContent":["(ns expectations.platform\n  (:refer-clojure :exclude [bound? format ns-name])\n  (:require #?(:clj [clojure.pprint :as pprint])\n            #?(:cljs [cljs.analyzer])\n            #?(:cljs [goog.string])\n            #?(:cljs [goog.string.format]))\n  #?(:cljs (:require-macros expectations.platform))\n  #?(:clj (:import (clojure.lang Agent Atom Ref))))\n\n#?(:clj\n   (defmacro cljs? []\n     (boolean (:ns &env))))\n\n#?(:clj\n   (defn expanding [n]\n     (if (cljs?)\n       `(cljs.analyzer/macroexpand-1 {} '~n)\n       `(macroexpand-1 '~n))))\n\n#?(:clj\n   (defmacro try [& body]\n     (let [[_ & catch-body] (last body)]\n       `(try ~@(butlast body)\n          (catch ~(if (:ns &env) `js/Error `Throwable) ~@catch-body)))))\n\n(defn ns-name [ns]\n  #?(:clj (if (symbol? ns) ns (clojure.core/ns-name ns))\n     :cljs (if (symbol? ns) ns)))\n\n(def bound?\n  #?(:clj clojure.core/bound?\n     :cljs (fn [& vars] (every? #(deref %) vars))))\n\n(def format\n  #?(:clj clojure.core/format\n     :cljs goog.string/format))\n\n(defn nodejs? []\n  #?(:clj false\n     :cljs (= (js* \"typeof(process)\") \"object\")))\n\n(defn getenv [var]\n  #?(:clj (System/getenv var)\n     :cljs (aget (if (nodejs?) js/process.env js/window) var)))\n\n(defn get-message [e] (-> e\n                          #?(:clj .getMessage\n                             :cljs .-message)))\n\n(defn nano-time []\n  #?(:clj (System/nanoTime)\n     :cljs (if (nodejs?)\n             (-> js/process .hrtime js->clj\n                 (#(+ (* 1e9 (% 0)) (% 1))))\n             (js/performance.now))))\n\n\n(defn on-windows? []\n  (re-find #\"[Ww]in\"\n           #?(:clj (System/getProperty \"os.name\")\n              :cljs (if (nodejs?) (.-platform js/process) \"\"))))\n\n(def pprint\n  #?(:clj pprint/pprint\n     :cljs println))                                           ;until there's a usable cljs pprint port\n\n(defn print-stack-trace [e]\n  (-> e\n      #?(:clj .printStackTrace\n         :cljs .-stack) println))\n\n(def iref-types\n  #?(:clj #{Agent Atom Ref}\n     :cljs #{cljs.core/Atom}))\n"]}