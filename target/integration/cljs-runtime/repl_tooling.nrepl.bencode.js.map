{"version":3,"sources":["repl_tooling/nrepl/bencode.cljs"],"mappings":"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","names":["repl-tooling.nrepl.bencode/encode","this","js/shadow.js.shim.module$buffer.Buffer","cljs.core/Keyword","G__60792","clojure.string/replace-first","cljs.core/Symbol","G__60793","cljs.core/map?","cljs.core.map","p__60798","vec__60799","cljs.core.nth","k","v","clojure.string.join","cljs.core/coll?","cljs.core.ex_info","cljs.core/type","repl-tooling.nrepl.bencode/decode-fragment","fragment","acc","f","cljs.core/first","cljs.core._EQ_","temp__5751__auto__","vec__60804","res","value","cljs.core/re-find","cljs.core.subs","cljs.core/count","cljs.core.conj","js/parseInt","vec__60807","rest","inner","G__60810","G__60811","vec__60813","G__60816","G__60817","cljs.core.apply","cljs.core/hash-map","vec__60818","_","c","chars","start","js/Buffer","repl-tooling.nrepl.bencode/old-decoder","state","cljs.core.atom","cljs.core.swap_BANG_","cljs.core/str","vec__60822","parsed","cljs.core/deref","cljs.core/reset!","repl-tooling.nrepl.bencode/remove-chars","char-size","cljs.core/update","cljs.core/subs","repl-tooling.nrepl.bencode/parse-int","vec__60826","buffer","total","number","term?","repl-tooling.nrepl.bencode/extract-string","acc-str","bytes-expected","acc-bytes","cut-frag","curr-bytes","cut-str","G__60830","G__60831","G__60832","G__60833","repl-tooling.nrepl.bencode/parse-str","vec__60834","repl-tooling.nrepl.bencode/parse-list","result","cljs.core/fn?","decode-inner","G__60839","G__60840","repl-tooling.nrepl.bencode/decode-one","repl-tooling.nrepl.bencode/parse-map","repl-tooling.nrepl.bencode/remove-chars-and-continue","cont","p1__60842#","p1__60843#","p1__60844#","repl-tooling.nrepl.bencode/decode-cont","cljs.core/assoc","repl-tooling.nrepl.bencode/decoder"],"sourcesContent":["(ns repl-tooling.nrepl.bencode\n  (:require [\"buffer\" :refer [Buffer]]\n            [clojure.string :as str]))\n\n(defn encode\n  \"Encodes a map/vector/string/number into BEncode format\"\n  [this]\n  (cond\n    (number? this) (str \"i\" this \"e\")\n    (string? this) (str (.byteLength Buffer this) \":\" this)\n    (keyword? this) (-> this str (str/replace-first #\":\" \"\") encode)\n    (symbol? this) (-> this str encode)\n    (map? this) (str \"d\"\n                     (->> this\n                          (map (fn [[k v]] (str (encode k) (encode v))))\n                          (str/join \"\"))\n                     \"e\")\n    (coll? this) (str \"l\" (->> this (map encode) (str/join \"\")) \"e\")\n    :else (throw (ex-info \"Can't encode this object\" {:object this\n                                                      :type (type this)}))))\n\n(defn- decode-fragment [fragment acc]\n  (let [f (-> fragment first str)]\n    (cond\n      (= \"i\" f)\n      (if-let [[res value] (re-find #\"i(\\-?\\d+)e\" fragment)]\n        (recur (subs fragment (count res)) (conj acc (js/parseInt value)))\n        [fragment acc])\n\n      (= \"l\" f)\n      (let [[rest inner] (decode-fragment (subs fragment 1) [])]\n        (if (= \"e\" (first rest))\n          (recur (subs rest 1) (conj acc inner))\n          [fragment acc]))\n\n      (= \"d\" f)\n      (let [[rest inner] (decode-fragment (subs fragment 1) [])]\n        (if (= \"e\" (first rest))\n          (recur (subs rest 1) (conj acc (apply hash-map inner)))\n          [fragment acc]))\n\n      (re-find #\"\\d\" f)\n      (let [[_ c] (re-find #\"^(\\d+):\" fragment)\n            chars (js/parseInt c)\n            start (-> c count inc)\n            value (str (.slice (.from js/Buffer fragment) start (+ start chars)))]\n        (if (->> value (.byteLength js/Buffer) (= chars))\n          (recur (subs fragment (-> value count (+ start))) (conj acc value))\n          [fragment acc]))\n\n      :else\n      [fragment acc])))\n\n(defn old-decoder\n  []\n  (let [state (atom \"\")]\n    (fn [fragment]\n      (swap! state str fragment)\n      (let [[rest parsed] (decode-fragment @state [])]\n        (reset! state rest)\n        parsed))))\n\n(defn- remove-chars [state char-size]\n  (swap! state update :buffer subs char-size))\n\n(defn- parse-int [state fragment]\n  (let [buffer (:buffer @state)\n        total (str fragment buffer)\n        [res number term?] (re-find #\"(\\-?\\d*)(e)?\" total)]\n    (cond\n      term?\n      (do\n        (->> buffer (re-find #\"\\-?\\d*e\") count (remove-chars state))\n        (js/parseInt number))\n\n      res\n      (do\n        (remove-chars state (count buffer))\n        #(parse-int state total))\n\n      :else\n      (throw (ex-info \"Error parsing INT\" {:string total})))))\n\n(defn- extract-string\n  \"Extracts string. Accumulates in acc-str, counts how many bytes are accumulated (on\nacc-bytes), until the total (bytes-expected) is fulfilled\"\n  [state acc-str bytes-expected acc-bytes]\n  (let [fragment (:buffer @state)\n        cut-frag (.. Buffer (from fragment) (slice 0 (- bytes-expected acc-bytes)))\n        curr-bytes (+ acc-bytes (.-length cut-frag))\n        cut-str (str cut-frag)]\n    (remove-chars state (count cut-str))\n    (if (= curr-bytes bytes-expected)\n      (str acc-str cut-str)\n      #(extract-string state (str acc-str cut-str) bytes-expected curr-bytes))))\n\n(defn- parse-str [state fragment]\n  (let [buffer (:buffer @state)\n        total (str fragment buffer)\n        [res number term?] (re-find #\"^(\\d+)(:)?\" total)]\n    (->> buffer (re-find #\"\\d*:?\") count (remove-chars state))\n    (if term?\n      (extract-string state \"\" (js/parseInt number) 0)\n      #(parse-str state total))))\n\n(declare decode-one)\n(defn- parse-list [state acc]\n  (let [inner (fn decode-inner [result]\n                (if (fn? result)\n                  #(decode-inner (result))\n                  (parse-list state (conj acc result))))]\n    (cond\n      (-> @state :buffer first (= \"e\"))\n      (do (remove-chars state 1) acc)\n\n      (-> @state :buffer (= \"\"))\n      #(parse-list state acc)\n\n      :else\n      (inner (decode-one state)))))\n\n(defn- parse-map [state acc]\n  (let [inner (fn decode-inner [result]\n                (if (fn? result)\n                  #(decode-inner (result))\n                  (apply hash-map result)))]\n    (inner (parse-list state acc))))\n\n(defn- remove-chars-and-continue [state char-size cont]\n  (remove-chars state char-size)\n  (cont state))\n\n(defn- decode-one [state]\n  (let [fragment (:buffer @state)\n        f (str (first fragment))]\n    (cond\n      (= \"i\" f)\n      (remove-chars-and-continue state 1 #(parse-int % \"\"))\n\n      (re-find #\"\\d\" f)\n      (parse-str state \"\")\n\n      (= \"l\" f)\n      (remove-chars-and-continue state 1 #(parse-list % []))\n\n      (= \"d\" f)\n      (remove-chars-and-continue state 1 #(parse-map % []))\n\n      :else\n      (throw (ex-info \"Garbage on parsing bencode\" {:string fragment})))))\n\n; Tries to use continuations to decode\n(defn- decode-cont [state acc]\n  (if (= \"\" (:buffer @state))\n    acc\n    (let [cont (:cont @state)\n          fragment (:buffer @state)\n          f (first fragment)\n          res (if cont\n                (cont)\n                (decode-one state))]\n\n      (if (fn? res)\n        (do\n          (swap! state assoc :cont res)\n          [])\n        (do\n          (swap! state assoc :cont nil)\n          (recur state (conj acc res)))))))\n\n(defn decoder\n  \"Starts a stateful decoder. It will return a function that accepts one parameter\n(a string) and it'll try to decode it as a BEncode value. It'll return the BEncode\nstructures it finds, or an empty vector if it didn't found anything.\n\nEx:\n(let [decode! (decoder)]\n  (is (= [10] (decode! \\\"i10e\\\")))\n  (is (= [] (decode! \\\"i1\\\")))\n  (is (= [10] (decode! \\\"0e\\\"))))\"\n  []\n  (let [state (atom {:buffer \"\" :cont nil})]\n    (fn [fragment]\n      (swap! state update :buffer str fragment)\n      (decode-cont state []))))\n\n;; Performance tests\n#_\n(->> 100000 range pr-str encode (def encoded))\n#_\n(time\n (let [decode! (decoder)]\n   (->> encoded\n        (partition-all 20 20)\n        (map #(apply str %))\n        (map decode!)\n        last\n        last\n        last)))\n#_\n(time\n (let [decode! (old-decoder)]\n   (->> encoded\n        (partition-all 20 20)\n        (map #(apply str %))\n        (map decode!)\n        last\n        last\n        last)))\n"]}