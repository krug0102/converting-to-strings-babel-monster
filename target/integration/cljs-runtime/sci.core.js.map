{"version":3,"sources":["sci/core.cljc"],"mappings":"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","names":["var_args","G__79494","sci.core/new-var","js/Error","name","G__79495","sci.core.new_var","sci.impl.vars/unbind","init-val","cljs.core/meta","meta","sci.impl.vars/SciVar","G__79497","sci.core/new-dynamic-var","G__79498","sci.core.new_dynamic_var","cljs.core.assoc","G__79500","sci.core/new-macro-var","sci.core.new_macro_var","cljs.core.vary_meta","cljs.core/assoc","sci.core/in","sci.impl.io/in","sci.core/out","sci.impl.io/out","sci.core/err","sci.impl.io/err","sci.core/ns","sci.impl.vars/current-ns","sci.core/file","sci.impl.vars/current-file","sci.core/print-length","sci.impl.io/print-length","args__4835__auto__","len__4829__auto__","i__4830__auto__","argseq__4836__auto__","cljs.core/IndexedSeq","sci.core/alter-var-root","seq79535","G__79536","cljs.core/first","cljs.core/next","G__79537","self__4816__auto__","v","f","args","cljs.core.apply","sci.impl.vars/alter-var-root","G__79542","sci.core/eval-string","s","sci.core.eval_string","opts","sci.impl.interpreter.eval_string","sci.core/init","sci.impl.opts/init","sci.core/fork","ctx","cljs.core.update","env","cljs.core/deref","cljs.core.atom","sci.core/eval-string*","sci.impl.interpreter/eval-string*","G__79544","sci.core/create-ns","sym","sci.core.create_ns","sci.impl.vars/->SciNamespace"],"sourcesContent":["(ns sci.core\n  (:refer-clojure :exclude [with-bindings with-in-str with-out-str\n                            with-redefs binding future pmap alter-var-root\n                            ns create-ns])\n  (:require\n   [sci.impl.interpreter :as i]\n   [sci.impl.io :as sio]\n   [sci.impl.macros :as macros]\n   [sci.impl.opts :as opts]\n   [sci.impl.vars :as vars])\n  #?(:cljs (:require-macros\n            [sci.core :refer [with-bindings with-out-str copy-var]])))\n\n#?(:clj (set! *warn-on-reflection* true))\n\n(defn new-var\n  \"Returns a new sci var.\"\n  ([name] (doto (new-var name nil nil)\n            (vars/unbind)))\n  ([name init-val] (new-var name init-val (meta name)))\n  ([name init-val meta] (sci.impl.vars.SciVar. init-val name meta false)))\n\n(defn new-dynamic-var\n  \"Same as new-var but adds :dynamic true to meta.\"\n  ([name] (doto (new-dynamic-var name nil nil)\n            (vars/unbind)))\n  ([name init-val] (new-dynamic-var name init-val (meta name)))\n  ([name init-val meta] (sci.impl.vars.SciVar. init-val name (assoc meta :dynamic true) false)))\n\n(defn new-macro-var\n  \"Same as new-var but adds :macro true to meta as well\n  as :sci/macro true to meta of the fn itself.\"\n  ([name init-val] (new-macro-var name init-val (meta name)))\n  ([name init-val meta] (sci.impl.vars.SciVar.\n                         (vary-meta init-val\n                                    assoc :sci/macro true)\n                         name (assoc meta :macro true) false)))\n\n(defmacro copy-var\n  \"Copies contents from var `sym` to a new sci var. The value `ns` is an\n  object created with `sci.core/create-ns`.\"\n  ([sym ns]\n   `(let [ns# ~ns\n          var# (var ~sym)\n          val# (deref var#)\n          m# (-> var# meta)\n          ns-name# (vars/getName ns#)\n          name# (:name m#)\n          name-sym# (symbol (str ns-name#) (str name#))\n          new-m# {:doc (:doc m#)\n                  :name name#\n                  :arglists (:arglists m#)\n                  :ns ns#}]\n      (cond (:dynamic m#)\n            (new-dynamic-var name# val# new-m#)\n            (:macro m#)\n            (new-macro-var name# val# new-m#)\n            :else (new-var name# val# new-m#)))))\n\n(macros/deftime\n  (defmacro with-bindings\n    \"Macro for binding sci vars. Must be called with map of sci dynamic\n  vars to values. Used in babashka.\"\n    [bindings-map & body]\n    `(let [bm# ~bindings-map]\n       (assert (map? bm#))\n       (vars/push-thread-bindings bm#) ;; important: outside try\n       (try\n         (do ~@body)\n         (finally (vars/pop-thread-bindings)))))\n\n  (defmacro binding\n    \"Macro for binding sci vars. Must be called with a vector of sci\n  dynamic vars to values.\"\n    [bindings & body]\n    (assert (vector? bindings))\n    `(with-bindings ~(apply hash-map bindings)\n       (do ~@body))))\n\n(def in \"Sci var that represents sci's `clojure.core/*in*`\" sio/in)\n(def out \"Sci var that represents sci's `clojure.core/*out*`\" sio/out)\n(def err \"Sci var that represents sci's `clojure.core/*err*`\" sio/err)\n(def ns \"Sci var that represents sci's `clojure.core/*ns*`\" vars/current-ns)\n(def file \"Sci var that represents sci's `clojure.core/*file*`\" vars/current-file)\n(def print-length \"Sci var that represents sci's `clojure.core/*print-length*`\" sio/print-length)\n\n(macros/deftime\n  (defmacro with-in-str\n    \"Evaluates body in a context in which sci's *in* is bound to a fresh\n  StringReader initialized with the string s.\"\n    [s & body]\n    `(let [in# (-> (java.io.StringReader. ~s)\n                   (clojure.lang.LineNumberingPushbackReader.))]\n       (with-bindings {in in#}\n         (do ~@body)))))\n\n(macros/deftime\n  (defmacro with-out-str\n    \"Evaluates exprs in a context in which sci's *out* is bound to a fresh\n  StringWriter.  Returns the string created by any nested printing\n  calls.\"\n    [& body]\n    `(let [out# (macros/? :clj (java.io.StringWriter.)\n                          :cljs (goog.string/StringBuffer.))]\n       (with-bindings {out out#}\n         (do ~@body)\n         (str out#)))))\n\n(macros/deftime\n  (defmacro future\n    \"Like clojure.core/future but also conveys sci bindings to the thread.\"\n    [& body]\n    `(let [f# (-> (fn [] ~@body)\n                  (vars/binding-conveyor-fn))]\n       (future-call f#))))\n\n#?(:clj (defn pmap\n          \"Like clojure.core/pmap but also conveys sci bindings to the threads.\"\n          ([f coll]\n           (let [n (+ 2 (.. Runtime getRuntime availableProcessors))\n                 rets (map #(future (f %)) coll)\n                 step (fn step [[x & xs :as vs] fs]\n                        (lazy-seq\n                         (if-let [s (seq fs)]\n                           (cons (deref x) (step xs (rest s)))\n                           (map deref vs))))]\n             (step rets (drop n rets))))\n          ([f coll & colls]\n           (let [step (fn step [cs]\n                        (lazy-seq\n                         (let [ss (map seq cs)]\n                           (when (every? identity ss)\n                             (cons (map first ss) (step (map rest ss)))))))]\n             (pmap #(apply f %) (step (cons coll colls)))))))\n\n(defn alter-var-root\n  \"Atomically alters the root binding of sci var v by applying f to its\n  current value plus any args.\"\n  [v f & args]\n  (apply vars/alter-var-root v f args))\n\n(defn eval-string\n  \"Evaluates string `s` as one or multiple Clojure expressions using the Small Clojure Interpreter.\n\n  The map `opts` may contain the following:\n\n  - `:bindings`: a map of symbols to values, e.g.: `{'x 1}`. The\n  symbols will acts as names bound to the corresponding values in the\n  expressions.\n\n  - `:namespaces`: a map of symbols to namespaces, where a namespace\n  is a map with symbols to values, e.g.: `{'foo.bar {'x 1}}`. These\n  namespaces can be used with `require`.\n\n  - `:allow`: a seqable of allowed symbols. All symbols, even those\n  brought in via `:bindings` or `:namespaces` have to be explicitly\n  enumerated.\n\n  - `:deny`: a seqable of disallowed symbols, e.g.: `[loop quote\n  recur]`.\n\n  - `:realize-max`: integer; when provided, program may realize a\n  maximum number of elements from sequences, e.g. `(vec (range))` will\n  throw for any number. This also applies to sequences returned from\n  the expression to the caller.\n\n  - `:preset`: a pretermined set of options. Currently only\n  `:termination-safe` is supported, which will set `:realize-max` to\n  `100` and disallows the symbols `loop`, `recur` and `trampoline`.\n\n  - `:features`: when provided a non-empty set of keywords, sci will process reader conditionals using these features (e.g. #{:bb}).\n\n  - `:env`: an atom with a map in which state from the\n  evaluation (defined namespaced and vars) will be persisted for\n  re-use over multiple calls.\n  \"\n  ([s] (eval-string s nil))\n  ([s opts]\n   (i/eval-string s opts)))\n\n(defn init\n  \"Creates an initial sci context from given options `opts`. The context\n  can be used with `eval-string*`. See `eval-string` for available\n  options. The internal organization of the context is implementation\n  detail and may change in the future.\"\n  [opts]\n  (opts/init opts))\n\n(defn fork\n  \"Forks a context (as produced with `init`) into a new context. Any new\n  vars created in the new context won't be visible in the original\n  context.\"\n  [ctx]\n  (update ctx :env (fn [env] (atom @env))))\n\n(defn eval-string*\n  \"Evaluates string `s` in the context of `ctx` (as produced with\n  `init`).\"\n  [ctx s]\n  (sci.impl.interpreter/eval-string* ctx s))\n\n(defn create-ns\n  \"Creates namespace object. Can be used in var metadata.\"\n  ([sym] (create-ns sym nil))\n  ([sym meta]\n   (vars/->SciNamespace sym meta)))\n\n;;;; Scratch\n\n(comment\n  (eval-string \"(inc x)\" {:bindings {'x 2}})\n  )\n"]}