{"version":3,"sources":["com/wsscode/pathom3/connect/planner.cljc"],"mappings":";AAqBA,AAAAA,yBAAA,AAAA,gIAAA,AAAA,mFAEEC;AAEF,AAAAD,yBAAA,AAAA,uIAAA,AAAA,4WAAA,AAAAE,yDAAA,AAAA,gIAAA,gIAAA,2CAAA,6FAAA,AAAA,2EAAA,oFAAA,WAAAC;AAAA,AAAA,4BAAAA,rBAE6BC;GAF7B,0EAAA,8FAAA,KAAA,0FAAA,AAAA,oXAAA,tkBAE6BA;AAE7B,AAAAJ,yBAAA,AAAA,6HAAA,AAAA,+WAAA,AAAAK,8BAAA,wCAAA,yDAAA,wDAAA,kDAAA,iEAAA,8DAAA,6DAAA,8DAAA,mDAAA,4DAAA,+DAAA,gEAAA,qDAAA,AAAA,KAAA,AAAA,KAAA,KAAA,mFAAA,WAAAC;AAAA,AAAA,OAAAC,qBAAAD;GAAA,WAAAA;AAAA,AAAA,OAAAE,0BAAAF,SAAA;WAAA,WAAAA;AAAA,AAAA,SAAA,AAAAC,qBAAAD,eAAA,AAAAE,0BAAAF,SAAA;GAAA,AAAA,iCAAA,AAAA,sNAAA,AAAA,sNAAA,AAAA,sNAAA,AAAA,iCAAA,AAAA,q8BAAA,AAAA;AAIA,AAAAN,yBAAA,AAAA,6IAAA,AAAA,kKAAA;AAIA,AAAAA,yBAAA,AAAA,0IAAA,AAAA,uIAAA;AAMA,AAAAA,yBAAA,AAAA,+IAAA,AAAA,mIAAA;AAIA,AAAAA,yBAAA,AAAA,wIAAA,AAAA,6WAAA,iFAAA,sIAAA;AAIA,AAAAA,yBAAA,AAAA,sIAAA,AAAA,2EAEES;AAEF,AAAAT,yBAAA,AAAA,wIAAA,AAAA,iGAAA;AAIA,AAAAA,yBAAA,AAAA,qIAAA,AAAA,qpBAAA,iFAAA,gJAAA,sIAAA,uIAAA;AAIA,AAAAA,yBAAA,AAAA,4HAAA,AAAA,kKAAA;AAIA,AAAAA,yBAAA,AAAA,yIAAA,AAAA,wWAAA,AAAAE,yDAAA,AAAA,uWAAA,AAAAQ,yDAAA,AAAA,0VAAA,mFAAA,wHAAA,gJAAA,2CAAA,qDAAA,mCAAA,6FAAA,AAAA,2EAAA,oFAAA,WAAAC;AAAA,AAAA,OAAAJ,qBAAAI;GAAA,qDAAAJ,qBAAA,+EAAA,WAAAK,iBAAAC;AAAA,AAAA,OAAAC,4CAAAD,iBAAA;GAAA,8FAAA,KAAA,0FAAA,AAAA,gXAAA;AAIA,AAAAb,yBAAA,AAAA,6JAAA,AAAA,qXAAA,AAAAE,yDAAA,AAAA,oXAAA,AAAAQ,yDAAA,AAAA,uWAAA,mFAAA,qIAAA,gJAAA,2CAAA,qDAAA,mCAAA,6FAAA,AAAA,2EAAA,oFAAA,WAAAK;AAAA,AAAA,OAAAR,qBAAAQ;GAAA,qDAAAR,qBAAA,+EAAA,WAAAK,iBAAAC;AAAA,AAAA,OAAAC,4CAAAD,iBAAA;GAAA,8FAAA,KAAA,0FAAA,AAAA,6XAAA;AAIA,AAAAb,yBAAA,AAAA,uIAAA,AAAA,kFAEEgB;AAEF,AAAAhB,yBAAA,AAAA,oJAAA,AAAA,kFAEEgB;AAEF,AAAAhB,yBAAA,AAAA,mJAAA,AAAA,kFAEEgB;AAEF,kDAAA,lDAAMC,4GAAaC;AAAnB,AACE,oDAAA,7CAACC,gFAAQ,AAACC,+CAAO,WAAAC;AAAA,AAAA,IAAAC,aAAAD;QAAA,AAAAP,4CAAAQ,WAAA,IAAA,/DAAMC;QAAN,AAAAT,4CAAAQ,WAAA,IAAA,/DAAQE;AAAR,AAAY,aAAA,LAAMA;IAAKN;;AAE1C,AAAAlB,yBAAA,AAAA,yHAAA,AAAA,6tCAAA,AAAAyB,8BAAA,AAAA,mtCAAA,mFAAA,AAAAC,wDAAA,AAAA,6SAAA,KAAA,MAAA,AAAArB,8BAAA,wCAAA,yDAAA,wDAAA,kDAAA,iEAAA,8DAAA,6DAAA,8DAAA,mDAAA,4DAAA,+DAAA,gEAAA,qDAAA,AAAA,KAAA,AAAA,KAAA,KAAA,mFAAA,WAAAsB,96BAEsBV;AAFtB,AAAA,OAAAV,qBAAAoB;WAAA,WAAAA;AAAA,AAAA,OAAApB,qBAAAoB;GAAA,AAAA,kuBAAA,AAAA,iCAAA,AAAA,KAAA,AAAA,iCAAA,AAAA,kuBAAA,AAAA,8cAAA,AAAA,6uBAAA;AAIA,AAAA3B,yBAAA,AAAA,2HAAA,AAAA,kWAAA,AAAAE,yDAAA,AAAA,iWAAA,AAAAQ,yDAAA,AAAA,oVAAA,mFAAA,gIAAA,kIAAA,2CAAA,qDAAA,mCAAA,6FAAA,AAAA,2EAAA,oFAAA,WAAAkB;AAAA,AAAA,OAAArB,qBAAAqB;GAAA,qDAAArB,qBAAA,+EAAA,WAAAK,iBAAAC;AAAA,AAAA,OAAAC,4CAAAD,iBAAA;GAAA,8FAAA,KAAA,0FAAA,AAAA,0WAAA;AAIA,AAAAb,yBAAA,AAAA,8HAAA,AAAA,2EAEEO;AAEF,AAAAP,yBAAA,AAAA,gIAAA,AAAA,kKAAA;AAIA,AAAAA,yBAAA,AAAA,yHAAA,AAAA,gIAAA;AAIA,AAAAA,yBAAA,AAAA,iIAAA,AAAA,uIAAA;AAIA,AAAAA,yBAAA,AAAA,8HAAA,AAAA,uIAAA;AAIA,AAAAA,yBAAA,AAAA,iIAAA,AAAA,gIAAA;AAIA,AAAAA,yBAAA,AAAA,iJAAA,AAAA,mIAAA;AAIA,AAAAA,yBAAA,AAAA,sIAAA,AAAA,qIAAA;AAIA,AAAAA,yBAAA,AAAA,mJAAA,AAAA,kKAAA;AAIA,AAAAA,yBAAA,AAAA,0HAAA,AAAA,iFAEE6B;AAEF,AAAA7B,yBAAA,AAAA,iIAAA,AAAA,0dAAA,AAAAE,yDAAA,AAAA,mVAAA,AAAAG,8BAAA,wCAAA,yDAAA,wDAAA,kDAAA,iEAAA,8DAAA,6DAAA,8DAAA,mDAAA,4DAAA,+DAAA,gEAAA,qDAAA,AAAA,KAAA,AAAA,KAAA,KAAA,mFAAA,WAAAyB;AAAA,AAAA,OAAAvB,qBAAAuB;GAAA,WAAAA;AAAA,AAAA,OAAAtB,0BAAAsB,SAAA;WAAA,WAAAA;AAAA,AAAA,SAAA,AAAAvB,qBAAAuB,eAAA,AAAAtB,0BAAAsB,SAAA;GAAA,AAAA,iCAAA,AAAA,qNAAA,AAAA,qNAAA,AAAA,qNAAA,AAAA,iCAAA,AAAA,o8BAAA,AAAA,QAAA,2CAAA,6FAAA,AAAA,KAAA,oFAAA,WAAAC;AAAA,AAAA,OAAAC,sBAAAD;GAAA,8FAAA,KAAA,0FAAA,AAAA,keAAA;AAIA,AAAA/B,yBAAA,AAAA,8IAAA,AAAA,mIAAA;AAIA,AAAAA,yBAAA,AAAA,mIAAA,AAAA,yHAAA;AAIA,AAAAA,yBAAA,AAAA,qIAAA,AAAA,uXAAA,AAAAE,yDAAA,AAAA,qIAAA,qIAAA,2CAAA,6FAAA,AAAA,iFAAA,oFAAA,WAAA+B;AAAA,AAAA,+BAAAA,xBAEiCC;GAFjC,6EAAA,8FAAA,KAAA,0FAAA,AAAA,+XAAA,plBAEiCA;AAEjC,AAAAlC,yBAAA,AAAA,6IAAA,AAAA,mIAAA;AAIA,AAAAA,yBAAA,AAAA,2IAAA,AAAA,mIAAA;AAIA,AAAAA,yBAAA,AAAA,+HAAA,AAAA,+UAAA,AAAAE,yDAAA,AAAA,mGAAA,mGAAA,2CAAA,6FAAA,AAAA,2EAAA,oFAAA,WAAAiC;AAAA,AAAA,4BAAAA,rBAE+B/B;GAF/B,0EAAA,8FAAA,KAAA,0FAAA,AAAA,uVAAA,ziBAE+BA;AAE/B,AAAAJ,yBAAA,AAAA,8IAAA,AAAA,kFAAwBoC;AAExB,AAAApC,yBAAA,AAAA,wIAAA,AAAA,mGAEEqC;AAEF,AAAArC,yBAAA,AAAA,uIAAA,AAAA,mGAEEqC;AAIF,AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,AAKA;;;mDAAA,2DAAAC,9GAAMI;AAAN,AAAA,IAAAH,aAAAD;IAAAC,iBAAA,AAAAC,4BAAAD;iBAAA,AAAAE,4CAAAF,eAAA,xEAEYI;AAFZ,AAGE,OAACC,mDAAMD,WAAWE;;AAEpB,+CAAA,/CAAMC,sGAAUC,IAAIC;AAApB,AACE,+DAAA,xDAACC,8CAAMD,0IAAoB,AAACN,iDAAaK;;AAE3C,AAAA,+CAAA,uDAAAG,tGAAOE;AAAP,AAAA,IAAAD,WAAA,AAAA;AAAA,AAAA,QAAAA;KAAA;AAAA,OAAAC,2EAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;KAAA;AAAA,OAAAA,2EAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;;AAAA,MAAA,KAAAC,MAAA,CAAA,8DAAA,AAAA;;;;;AAAA,CAAA,6EAAA,7EAAOD,wFACHE,MAAMC;AADV,AAIG,4DAAA,mFAAA,xIAACC,+CAAOF,oNAAeC;;;AAJ1B,CAAA,6EAAA,7EAAOH,wFAMHE,MAAMC,QAAQE;AANlB,AASG,4DAAA,mFAAA,xIAACD,+CAAOF,oNAAeC,QAAQE;;;AATlC,CAAA,uEAAA,vEAAOL;;AAAP,AAWA;;;;gEAAA,hEAAMM,wIAGHJ,MAAMP,IAAIQ;AAHb,AAIE,IAAMI,OAAK,AAACC,2EAASN,MAAMC;AAA3B,AACE,IAAAM,qBAAgB,iBAAAE,WAASJ;IAATI,eAAA,EAAA,CAAAA,YAAA,OAAA,KAAA,AAAA,mKAAAA;AAAA,AAAA,GAAA,CAAAA,gBAAA;AAAA;;AAA4B,+DAAAA,xDAACC,oDAAoBjB;;;AAAjE,AAAA,oBAAAc;AAAA,aAAAA,TAASC;AAAT,AACE,OAACG,uGAAMN,KAAKG;;AADd;;;AAGJ;;;iDAAA,jDAAMI,0GAEHZ,MAAMC,QAAQE,EAAEjC;AAFnB,AAGE,oBAAI,AAACoC,2EAASN,MAAMC;AAClB,gCAAA,mFAAA,5GAACY,mBAASb,oNAAeC,QAAQE,UAAGjC;;AACpC8B;;;AAEJ,AAAA;;;kDAAA,0DAAAJ,5GAAMmB;AAAN,AAAA,IAAAD,WAAA,AAAA;AAAA,AAAA,QAAAA;KAAA;AAAA,OAAAC,8EAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;KAAA;AAAA,OAAAA,8EAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;KAAA;AAAA,OAAAA,8EAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;KAAA;AAAA,OAAAA,8EAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;;AAAA,IAAAC,yBAAA;AAAA,AAAA,IAAAC,0BAAA,AAAA;AAAA,AAAA,IAAAC,wBAAA;;AAAA,AAAA,GAAA,CAAAA,wBAAAD;AAAA,AAAA,AAAAD,4BAAA,CAAA,UAAAE;;AAAA,eAAA,CAAAA,wBAAA;;;;AAAA;;;;AAAA,IAAAC,uBAAA,KAAAC,qBAAA,AAAAJ,6BAAA,KAAA,IAAA;AAAA,AAAA,OAAAD,qFAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAAI;;;;;AAAA,CAAA,gFAAA,hFAAMJ,2FAEFf,MAAMC,QAAQE,EAAE6B;AAFpB,AAGG,oBAAI,AAAC1B,2EAASN,MAAMC;AAClB,OAACgC,kDAAUjC,MAAM,iBAAAkC,WAAA,mFAAA,2HAAiBjC;AAAjB,AAAA,oBAA0BE;AAAE,oDAAA+B,7CAACC,sDAAKhC;;AAAlC+B;;KAAsCF;;AACvDhC;;;;AALL,CAAA,gFAAA,hFAAMe,2FAMFf,MAAMC,QAAQE,EAAE6B,EAAE9D;AANtB,AAOG,oBAAI,AAACoC,2EAASN,MAAMC;AAClB,OAACgC,kDAAUjC,MAAM,iBAAAoC,WAAA,mFAAA,2HAAiBnC;AAAjB,AAAA,oBAA0BE;AAAE,oDAAAiC,7CAACD,sDAAKhC;;AAAlCiC;;KAAsCJ,EAAE9D;;AACzD8B;;;;AATL,CAAA,gFAAA,hFAAMe,2FAUFf,MAAMC,QAAQE,EAAE6B,EAAE9D,EAAEmE;AAVxB,AAWG,oBAAI,AAAC/B,2EAASN,MAAMC;AAClB,OAACgC,kDAAUjC,MAAM,iBAAAsC,WAAA,mFAAA,2HAAiBrC;AAAjB,AAAA,oBAA0BE;AAAE,oDAAAmC,7CAACH,sDAAKhC;;AAAlCmC;;KAAsCN,EAAE9D,EAAEmE;;AAC3DrC;;;;AAbL,CAAA,gFAAA,hFAAMe,2FAcFf,MAAMC,QAAQE,EAAE6B,EAAE9D,EAAEmE,GAAGE;AAd3B,AAeG,oBAAI,AAACjC,2EAASN,MAAMC;AAClB,OAACgC,kDAAUjC,MAAM,iBAAAwC,WAAA,mFAAA,2HAAiBvC;AAAjB,AAAA,oBAA0BE;AAAE,oDAAAqC,7CAACL,sDAAKhC;;AAAlCqC;;KAAsCR,EAAE9D,EAAEmE,GAAGE;;AAC9DvC;;;;AAjBL,AAAA,CAAA,uFAAA,vFAAMe,kGAkBFf,MAAMC,QAAQE,EAAE6B,EAAE9D,EAAEmE,GAAGE,GAAKE;AAlBhC,AAmBG,oBAAI,AAACnC,2EAASN,MAAMC;AAClB,OAACyC,qDAAMC,oBAAU3C,MAAM,iBAAA4C,WAAA,mFAAA,2HAAiB3C;AAAjB,AAAA,oBAA0BE;AAAE,oDAAAyC,7CAACT,sDAAKhC;;AAAlCyC;;KAAsCZ,EAAE9D,oDAAEmE,GAAGE,GAAGE;;AACvEzC;;;;AArBL;AAAA,CAAA,oEAAA,WAAAqB,/EAAMN;AAAN,AAAA,IAAAO,WAAA,AAAAC,gBAAAF;IAAAA,eAAA,AAAAG,eAAAH;IAAAI,WAAA,AAAAF,gBAAAF;IAAAA,eAAA,AAAAG,eAAAH;IAAAK,WAAA,AAAAH,gBAAAF;IAAAA,eAAA,AAAAG,eAAAH;IAAAM,WAAA,AAAAJ,gBAAAF;IAAAA,eAAA,AAAAG,eAAAH;IAAAO,WAAA,AAAAL,gBAAAF;IAAAA,eAAA,AAAAG,eAAAH;IAAAQ,WAAA,AAAAN,gBAAAF;IAAAA,eAAA,AAAAG,eAAAH;IAAAS,WAAA,AAAAP,gBAAAF;IAAAA,eAAA,AAAAG,eAAAH;AAAA,AAAA,IAAAU,qBAAA;AAAA,AAAA,OAAAA,wDAAAT,SAAAG,SAAAC,SAAAC,SAAAC,SAAAC,SAAAC,SAAAT;;;AAAA,CAAA,0EAAA,1EAAMN;;AAAN,AAuBA;;;oDAAA,4DAAA8B,hHAAME;AAAN,AAAA,IAAAD,aAAAD;IAAAC,iBAAA,AAAA5D,4BAAA4D;YAAAA,RAEsB9C;WAFtB,AAAAb,4CAAA2D,eAAA,lEAEYE;AAFZ,AAGE,OAAC1C,2EAASN,MAAMgD;;AAElB,oDAAA,pDAAOC,gHACJjD,MAAMC;AADT,AAIE,oBAAIA;AACF,2DAAA,pDAACN,8CAAMK,+HAAaC;;AACpB,4DAAA,rDAACiD,+CAAOlD;;;AAEZ;;;oDAAA,pDAAOmD,gHAEJ9C;AAFH,AAKE,IAAA+C,mBAAI,AAAA,+JAAW/C;AAAf,AAAA,oBAAA+C;AAAAA;;AACI,OAAA,4JAAU/C;;;AAEhB;;;yDAAA,zDAAOgD,0HAEJhD;AAFH,AAIE,OAACiD,mBAAQ,AAACH,kDAAc9C;;AAE1B;;;gDAAA,hDAAOkD,wGAEJlD;AAFH,AAIE,oBACE,AAAA,mKAAeA;AADjB;;AAAA,oBAIE,AAAA,+JAAWA;AAJb;;AAAA,oBAOE,AAAA,4JAAUA;AAPZ;;AAAA,AAAA;;;;;;AAaF;;;;qDAAA,rDAAMmD,kHAGHnD;AAHH,AAIE,mDACE,iBAAA+C,mBACE,AAAA,mKAAe/C;AADjB,AAAA,oBAAA+C;AAAAA;;AAAA,IAAAA,uBAEE,wLAAA,MAAA,5KAAI,AAAA,+JAAW/C;AAFjB,AAAA,oBAAA+C;AAAAA;;AAGE,oBAAI,AAAA,4JAAU/C;AAAd;;AAAA;;;;;;AAEN,sDAAA,tDAAMoD,oHAAiBzD,MAAMC,QAAQyD;AAArC,AACE,oBAAQA;AAAR;AAAA,AAAA,MAAA,KAAA3D,MAAA,CAAA,kBAAA,yCAAA,KAAA;;;AACA,mGAAA,5FAAC4D,8EAAY3D,MAAMC,kJAAuB2D,4BAAWF;;AAEvD,yDAAA,zDAAMG,0HAAoB7D,MAAMC,QAAQyD;AAAxC,AACE,IAAMrD,OAAc,AAACC,2EAASN,MAAMC;IAC9B6D,4BAAc,AAACC,6CAAK,AAAA,6KAAA,LAAgB1D,wCAAUqD;AADpD,AAEE,GAAI,AAACM,cAAIF;AACP,oEAAA,7DAAClD,+CAAWZ,MAAMC,kJAAuB6D;;AACzC,oBAAIzD;AACF,+DAAA,mFAAA,4JAAA,vSAAC4B,kDAAUjC,oNAAeC,gBAASgE;;AACnCjE;;;;AAER;;;;8DAAA,9DAAMkE,oIAGHlE,MAAMC,QAAQkE;AAHjB,AAIE,oBAAIA;AACF,oEAAA,7DAACvD,+CAAWZ,MAAMC,yIAAmBkE;;AACrC,+DAAA,mFAAA,4JAAA,vSAAClC,kDAAUjC,oNAAeC,gBAASgE;;;AAEvC,AAAA;;;;wDAAA,gEAAArE,xHAAMyE;AAAN,AAAA,IAAAD,WAAA,AAAA;AAAA,AAAA,QAAAA;KAAA;AAAA,OAAAC,oFAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;KAAA;AAAA,OAAAA,oFAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;;AAAA,MAAA,KAAAtE,MAAA,CAAA,8DAAA,AAAA;;;;;AAAA,CAAA,sFAAA,tFAAMsE,iGAGFrE,MAAMmE;AAHV,AAGoB,OAACG,oFAAkBtE,MAAM,AAAA,uJAAQA,OAAOmE;;;AAH5D,CAAA,sFAAA,tFAAME,iGAIFrE,MAAMuE,eAAeJ;AAJzB,AAKG,IAAAK,aAAmC,AAAClE,2EAASN,MAAMuE;IAAnDC,iBAAA,AAAAtF,4BAAAsF;sBAAA,AAAArF,4CAAAqF,eAAA,7EAAOC;IACDzE,YAAM,kBAAIyE,iBACF,AAACZ,uDAAmB7D,MAAMyE,gBAAgBF,gBAC1CvE;AAHd,AAIE,GACE,AAAC0E,cAAIP;AACL,OAACD,4DAAmBlE,UAAMuE,eAAeJ;;AAF3C,oBAIE,iBAAAQ,oBAAKR;AAAL,AAAA,oBAAAQ;AAAc,OAACC,gDAAKL,eAAeJ;;AAAnCQ;;;uHACI3E,5DACA,AAACkE,sEAAmBK,eAAeJ,hJACnC,OAACV,mJAAgBU,SAASI;;AAPhC,AAUEvE;;;;;;AAnBP,CAAA,gFAAA,hFAAMqE;;AAAN,AAqBA,AAAA,gEAAA,wEAAAzE,xIAAMkF;AAAN,AAAA,IAAAD,WAAA,AAAA;AAAA,AAAA,QAAAA;KAAA;AAAA,OAAAC,4FAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;KAAA;AAAA,OAAAA,4FAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;;AAAA,MAAA,KAAA/E,MAAA,CAAA,8DAAA,AAAA;;;;;AAAA,CAAA,8FAAA,9FAAM+E,yGACF9E,MAAMP;AADV,AACe,OAACwF,4FAA0BjF,MAAMP,IAAI,AAAA,uJAAQO;;;AAD5D,CAAA,8FAAA,iBAAA+E,/GAAMD,yGAEF9E,eAAkCC;AAFtC,AAAA,IAAA+E,aAAAD;IAAAC,iBAAA,AAAA9F,4BAAA8F;gBAAA,AAAA7F,4CAAA6F,eAAA,vEAE0BE;AAF1B,AAGG,oBAAIjF;yDACED,zDACA,+DAAA,mFAAA,3IAACiC,oRAAyBiD,kBAAWtB,4BAAW3D;;AACpDD;;;;AANL,CAAA,wFAAA,xFAAM8E;;AAAN,AAQA,yDAAA,zDAAMK,0HACHnF,MAAMuE,eAAea,YAAYC;AADpC,yIAEMrF,pDACA,AAACyD,0DAAgB4B,mBAAmBd,lKACpC,OAACZ,2KAAYY,eAAea,YAAYxB,4BAAWyB;;AAEzD,wDAAA,xDAAMC,wHAAmBtF,MAAMuE,eAAea,YAAYG;AAA1D,AACE,OAACC,+CACC,WAAKC,EAAExF;AAAP,AACE,OAACkF,uDAAmBM,EAAElB,eAAea,YAAYnF;GACnDD,MACAuF;;AAEJ;;;iEAAA,jEAAMG,0IAEH1F,MAAMC;AAFT,AAGE,IAAMI,OAAK,AAACC,2EAASN,MAAMC;AAA3B,AACE,IAAAM,qBAAkB,AAAC4C,kDAAc9C;AAAjC,AAAA,oBAAAE;AAAA,eAAAA,XAASoF;AAAT,AACE,OAACH,+CACC,WAAKC,EAAEG;AAAP,AACE,OAAC/B,uDAAmB4B,EAAEG,KAAK3F;GAC7BD,MACA2F;;AACF3F;;;AAEN;;;kEAAA,gFAAA6F,lJAAME,4IAEH/F;AAFH,AAAA,IAAA8F,aAAAD;IAAAC,iBAAA,AAAA5G,4BAAA4G;cAAA,AAAA3G,4CAAA2G,eAAA,rEAEkB7F;mBAFlB,AAAAd,4CAAA2G,eAAA,1EAE0BE;AAF1B,AAGE,OAACR,+CACC,WAAKC,EAAEQ;AAAP,AACE,IAAMC,IAAE,AAAC5F,2EAASN,MAAMiG;AAAxB,AACE,GACE,AAAC/I,0BAAU,AAAA,+JAAWgJ,GAAGjG;AACzB,+FAAA,xFAAC0D,8EAAY3D,MAAMiG,qIAAcE,eAAKlG;;AAFxC,GAIE,AAAC/C,0BAAU,AAAA,4JAAUgJ,GAAGjG;AACxB,+FAAA,xFAAC0D,8EAAY3D,MAAMiG,kIAAaE,eAAKlG;;AALvC,AAQEwF;;;;GACNzF,MACAgG;;AAEJ;;;wDAAA,xDAAMI,wHAEHpG,MAAMC;AAFT,AAIE,OAAC8F,gEAA4B/F,MAAMC;;AAErC;;;wDAAA,xDAAMoG,wHAEHrG,MAAMC;AAFT,AAGE,IAAMI,OAAK,AAACC,2EAASN,MAAMC;AAA3B,kFACMD,5BACA,iBAAAsG,vEAGA,OAACC;AAHD,AAAA,oBACE,AAAA,mKAAelG;AACf,yDAAAiG,SAAA,mFAAA,9IAACrE,2SAAmC,AAAA,mKAAe5B,cAAO8F,eAAKlG;;AAFjEqG;;KAGA,2HAAgBrC,iBAAOhE;;AAE/B;;;;kDAAA,lDAAMuG,4GAGHxG,MAAMC;AAHT,AAIE,IAAAwG,aAAgD,AAACnG,2EAASN,MAAMC;IAAhEwG,iBAAA,AAAAvH,4BAAAuH;WAAAA,PAA0CpG;eAA1C,AAAAlB,4CAAAsH,eAAA,tEAAetC;mBAAf,AAAAhF,4CAAAsH,eAAA,1EAAwBT;AAAxB,AACE,GAAQ,kBAAIA,cACF,uBAAA,WAAAU,lCAACC;AAAD,AAAS,OAAC/B,gDAAK3E,QAAQ,iFAAAyG,iBAAA,lGAACpG,2EAASN;iBADnC,dAEIgG;AAFZ;AAAA,AAAA,MAAA,KAAAjG,MAAA,CAAA,sSAAA,KAAA,zRAIE,CAAA,6EAAA,TAA6BE;;;mPAG3BD,/DACA,AAAC0F,qEAA2BzF,5HAC5B,AAAC4D,qIAAmBM,SAASlE,9MAC7B,AAAC8F,uNAA4B1F,pRAC7B,OAACgG,mRAAapG;;AAEtB;;;+DAAA,/DAAM2G,sIAEH5G,MAAMuF;;AAFT,AAGE,GAAI,AAACvB,cAAIuB;AACP,IAAAsB,aAAuBtB;IAAvBuB,aAAA,AAAA9C,cAAA6C;IAAAE,eAAA,AAAAxF,gBAAAuF;IAAAA,iBAAA,AAAAtF,eAAAsF;cAAAC,VAAO9G;WAAP6G,PAAiBG;IAAjBD,aACmC,AAAC1G,2EAASN,MAAMC;IADnD+G,iBAAA,AAAA9H,4BAAA8H;WAAAA,PAC6B3G;eAD7B,AAAAlB,4CAAA6H,eAAA,tEACe7C;IACTwB,WAAW,iBAAAvC,mBAAI,AAACD,kDAAc9C;AAAnB,AAAA,oBAAA+C;AAAAA;;AAAA;;;IACX8D,aAAW,iBAAAC,WAAQxB;AAAR,AAAA,oBAAiBxB;AAAS,oDAAAgD,7CAAChF,sDAAKgC;;AAAhCgD;;;AAHjB,AAIE,eAAO,AAACd,sDAAarG,MAAMC;eACzB,AAACpC,6CAAKoJ,KAAKC;;;;;AACflH;;;;;AAEJ;;;mDAAA,iEAAAoH,pHAAME,8GAEHtH;AAFH,AAAA,IAAAqH,aAAAD;IAAAC,iBAAA,AAAAnI,4BAAAmI;WAAAA,PAEoDhH;cAFpD,AAAAlB,4CAAAkI,eAAA,rEAEkBpH;cAFlB,AAAAd,4CAAAkI,eAAA,rEAEuCE;AAFvC,kCAGMvH,nBACA,yBAAA,mFAAA,5GAACa,uOAAkBZ,gBAASI,tQAC5B,IAAAmH;AAAA,AAAA,oBACED;AACA,yDAAAC,SAAA,mFAAA,9IAACvF,2SAAmCsF,gBAAS3D,4BAAW3D;;AAF1DuH;;;AAIN,iDAAA,jDAAMC,0GAAYzH,MAAMP,IAAI8F;AAA5B,AACE,GAAI,6CAAA,7CAACmC,iDAAI,AAACC,gBAAMpC;AACd,OAACjF,2EAASN,MAAM,AAACuB,gBAAMgE;;AACvB,IAAAqC,aAC6B,iDAAA,jDAACpI,6CAASC;IADvCmI,iBAAA,AAAA1I,4BAAA0I;eAAAA,XACmBE;kBADnB,AAAA3I,4CAAAyI,eAAA,zEAAOC;AAAP,8GAEM7H,jDACA,AAACsH,uDAAaQ,pHACd,0IAAA,nIAACxC,uHAAkBuC,6IAAsBtC;;;AAEnD,sDAAA,tDAAMwC,oHAAiB/H,MAAMP,IAAI8F;AAAjC,AACE,GAAI,6CAAA,7CAACmC,iDAAI,AAACC,gBAAMpC;AACd,OAACtC,kDAAcjD,MAAM,AAACuB,gBAAMgE;;AAC5B,IAAAyC,aAC6B,iDAAA,jDAACxI,6CAASC;IADvCuI,iBAAA,AAAA9I,4BAAA8I;eAAAA,XACmBF;kBADnB,AAAA3I,4CAAA6I,eAAA,zEAAOH;AAAP,wKAEM7H,jDACA,AAACsH,uDAAaQ,7GACd,mIAAA,nIAACxC,uHAAkBuC,6IAAsBtC,tTACzC,AAACtC,gUAAc4E,/UACf,IAAMI;AAAN,AACE,IAAAC,WAAeD;IAAfE,WAAkB1I;IAAlB2I,WAAA,2CAAA,8IAAA,uJAAA,kJAAA,kBAAA,0ZAAA,kJAAA,iNAAA,5mBAGmC,6CAAA,7CAACvK,4FAAO,AAAA,uJAAQoK,YAAK1C,4MACpB,AAAA,uJAAQ0C;AAJ5C,AAAA,oLAAAC,SAAAC,SAAAC,6EAAAF,SAAAC,SAAAC,7RAACC,uFAAAA,mHAAAA;;;AAMb,qDAAA,mEAAAC,xHAAME,kHACHxI,eAA0CuF;AAD7C,AAAA,IAAAgD,aAAAD;IAAAC,iBAAA,AAAArJ,4BAAAqJ;UAAAA,NACwC9I;gBADxC,AAAAN,4CAAAoJ,eAAA,vEACyBrD;AADzB,AAEE,GAAI,6CAAA,7CAACwC,iDAAI,AAACC,gBAAMpC;AACd,OAACtC,kDAAcjD,MAAM,AAACuB,gBAAMgE;;AAC5B,IAAAkD,aAC2B,iDAAA,2CAAA,gIAAA,0DAAA,tRAACjJ,6CAASC,+NAAgByF;IADrDuD,iBAAA,AAAAvJ,4BAAAuJ;cAAAA,VACkBE;iBADlB,AAAAxJ,4CAAAsJ,eAAA,xEAAOC;AAAP,wKAEM1I,jDACA,AAACsH,uDAAaqB,7GACd,iIAAA,jIAACrD,sHAAkBoD,yIAAoBnD,jTACvC,AAACtC,2TAAcyF,1UACf,IAAMT;AAAN,AACE,IAAAW,WAAeX;IAAfY,WAAkBpJ;IAAlBqJ,WAAA,2CAAA,8IAAA,sJAAA,kJAAA,iBAAA,0ZAAA,kJAAA,iNAAA,5mBAGmC,6CAAA,7CAACjL,4FAAO,AAAA,uJAAQoK,YAAK1C,4MACpB,AAAA,uJAAQ0C;AAJ5C,AAAA,oLAAAW,SAAAC,SAAAC,6EAAAF,SAAAC,SAAAC,7RAACT,uFAAAA,mHAAAA;;;AAMb;;;;8DAAA,9DAAMU,oIAGH/I,MAAMP,IAAIuJ;AAHb,AAIE,IAAAC,WACE,qDAAA,mFAAA,xIAAC/I,+CAAOF,kOAAqBgJ;AAD/B,AAAA,GAAA,CAAAC,YAAA;AAAA;;AAEE,oDAAA,WAAAC,xDAACC;AAAD,sNACO,wEAAAD,xEAAC9I,8DAA0BJ,MAAMP,1RAEjC,mDAAA,AAAA,5CAACN,0SAAI6J;GAHZC;;;AAKJ;;;;2DAAA,3DAAMG,8HAGHpJ,MAAMuE,eAAe8E,eAAepJ;AAHvC,0HAIMD,vDACA,AAAC6D,6DAAmBwF,eAAepJ,hIACnC,AAACwD,yIAAgBc,eAAetE,vKAChC,IAAMgI;AAAN,AACE,GACE,AAACP,6CAAE,yFAAA,zFAACpH,2EAASN,MAAMC,0IAAoBoJ;AACvC,OAACnF,4DAAmB+D,SAAGhI,QAAQsE;;AAFjC,GAIE,AAACrH,0BAAU,yFAAA,zFAACoD,2EAASN,MAAMC,0IAAmBoJ;4IAC1CpB,vDACA,wEAAA,xEAAC9C,gEAAmBlF,yIAAkBsE,9RACtC,sTAAA,/SAACZ,uSAAY1D,yIAAkBkG,eAAKkD;;AAP1C,GASE,AAACnM,0BAAU,yFAAA,zFAACoD,2EAASN,MAAMC,uIAAkBoJ;4IACzCpB,vDACA,wEAAA,xEAAC9C,gEAAmBlF,sIAAiBsE,3RACrC,mTAAA,5SAACZ,oSAAY1D,sIAAiBkG,eAAKkD;;AAZzC,AAeEpB;;;;;;AAEV;;;;4DAAA,5DAAMqB,gIAGHtJ,MAAMuE,eAAe8E;AAHxB,AAIE,IAAME,UAAQ,gGAAA,hGAACjJ,2EAASN,MAAMqJ;AAA9B,2CACMrJ,5BAEA,iBAAAwJ,hCAGA,IAAMvB;AAHN,AAAA,GACE,AAACP,6CAAE,AAAA,uJAAQ1H,OAAOqJ;AAClB,yDAAAG,lDAACvG,2DAAcsB;;AAFjBiF;;;AAGA,AACE,OAAChE,+CACC,WAAKC,EAAExF;AAAP,AACE,OAACmJ,yDAAqB3D,EAAElB,eAAe8E,eAAepJ;GACxDgI,SACAsB;;AAEZ,sDAAA,tDAAME,oHAAiBC,GAAGC;AAA1B,AACE,yDAAA,lDAACpD,+CAAOmD,mIAAaE,yDAAkB,AAAA,8JAAWD;;AAEpD,0DAAA,1DAAME,4HAAqBH,GAAGC;AAA9B,AACE,oBAAI,AAAA,sKAAeD;AACjB,yDAAA,lDAACnD,+CAAOmD,2IAAiBI,kDAA0B,AAAA,sKAAeH;;AAClED;;;AAEJ,4DAAA,5DAAMK,gIAAuB/J,MAAMuE,eAAe8E;AAAlD,AACE,IAAMW,QAAM,AAACC,eAAK,gGAAA,hGAAC3J,2EAASN,MAAMqJ;AAAlC,AACE,OAAC7D,+CACC,WAAKxF,UAAMgJ;AAAX,2GACMhJ,lDACA,4DAAA,mFAAA,/IAACiC,wRAAyB+G,aAAMpF,4BAAWW,1XAC3C,0YAAA,mFAAA,tdAACtC,+lBAAyB+G,aAAM7C,eAAKkD;GAC3CrJ,MACAgK;;AAEN,uDAAA,vDAAME,sHACHlK,MAAMP,IAAI8F,SAAS4E;AADtB,AAEE,IAAMC,iBAAe,6CAAA,7CAACvM,8EACK,AAACwM,6CAAK,4CAAA,WAAAC,vDAACC;AAAD,AAAM,wFAAAD,jFAAChK,2EAASN;IAChB,+CAAA,/CAACwK,kLACPjF;AAH3B,AAIE,GACE,6CAAA,7CAACmC,iDAAI,AAACC,gBAAMyC;AACZ,IAAAK,aAAkC,AAAClJ,gBAAM6I;IAAzCK,iBAAA,AAAAvL,4BAAAuL;cAAA,AAAAtL,4CAAAsL,eAAA,rEAAexK;eAAf,AAAAd,4CAAAsL,eAAA,tEAAuBtG;AAAvB,kJACMnE,vDACA,AAAC6D,6DAAmBM,SAASlE,jKAC7B,OAACqE,mKAAkB6F,MAAMhG;;AALjC,GAOE,AAACH,cAAIoG;AACL,IAAMtC,WAAS,iDAAA,2CAAA,iIAAA,7NAACtI,6CAASC;AAAzB,AACE,eAAMO,XAAMiI;IAAAA,eACV,AAACX,iDAAaW,SAAGH;IADPG,eAEV,AAACzC,+CACC,aAAAkF,FAAKjF;AAAL,AAAA,IAAAkF,aAAAD;IAAAC,iBAAA,AAAAzL,4BAAAyL;cAAA,AAAAxL,4CAAAwL,eAAA,rEAAgB1K;eAAhB,AAAAd,4CAAAwL,eAAA,tEAAwBxG;AAAxB,qHACMsB,vDACA,iOAAA,jOAACN,yDAAmB,AAAA,8JAAW2C,2IAAoB3D,haACnD,OAACN,maAAmBM,SAASlE;GACnCgI,aACAmC;AARJ,AASE,OAAC9F,oFAAkB2D,aAAGkC,MAAM,AAAA,8JAAWrC;;AAlB7C,AAqBE9H;;;;;AAEN;;;;;;;2DAAA,3DAAO4K,8HAMJ5K,MAAMP,IAAIQ;AANb,AAQE,IAAMI,OAAe,AAACC,2EAASN,MAAMC;IAC/BsE,iBAAe,iBAAAI,oBAAK,6CAAA,7CAAC+C,iDAAI,AAACC,gBAAM,AAAA,+JAAWtH;AAA5B,AAAA,GAAAsE;AAAA,IAAAA,wBACK,AAACD,cAAI,AAAA,+JAAYrE;AADtB,AAAA,GAAAsE;AAEK,OAACpD,gBAAM,AAAA,+JAAWlB;;AAFvBsE;;;AAAAA;;;AADrB,AAIE,oBAAIJ;2MACEvE,5BACA,iBAAA6K,3EAGA,AAACvB,tDACD,AAAClD,hDACD,AAACI,fACD,IAAAwE;IANAF,WAAerL;IAAfsL,WAAA,2CAAA,kJAAA,yCAAA,iJAAA,wEAAA,kJAAA,wDAAA,pNACyC9K,fAAQsE,2NACTtE;AAFxC,AAAA,oLAAA4K,SAAAC,SAAAC,6EAAAF,SAAAC,SAAAC,7RAAC1C,uFAAAA,mHAAAA;KAGsB9D,eAAetE,SACnBA,SACNA;IACbgL,WAAexL;IAAfyL,WAAA,2CAAA,kJAAA,sBAAA,iJAAA,+CACyC3G;AADzC,AAAA,oLAAAyG,SAAAC,SAAAC,6EAAAF,SAAAC,SAAAC,7RAAC7C,uFAAAA,mHAAAA;;AAELrI;;;AAEN;;;kEAAA,lEAAMmL,4IAEHnL,MAAMuE,eAAe8E;AAFxB,AAGE,IAAM+B,cAAY,AAAC9K,2EAASN,MAAMqJ;AAAlC,iZACMrJ,9EAEA,mGAAA,nGAAC2D,oFAAYY,oBAAmB8G,qCAAoBD,3NACpD,uPAAA,vPAACzH,wOAAYY,oBAAmBkF,oDAAgB2B,9XAChD,0ZAAA,1ZAACzH,2YAAYY,oBAAmBsF,wDAAoBuB,jhBACpD,AAACrB,8hBAAsBxF,eAAe8E,nmBACtC,AAACjD,mnBAAkBiD,1qBACnB,OAAC7C,mrBAAY6C;;AAErB,yEAAA,zEAAMiC,0JACHtL,MAAMmK,MAAM5E;AADf,AAEE,OAACC,+CACC,WAAKC,EAAExF;AAAP,AACE,OAACkL,gEAA4B1F,EAAE0E,MAAMlK;GACvCD,MACAuF;;AAEJ,mEAAA,nEAAMgG,8IACHvL,MAAMP,IAAI+L,eAAejG;AAD5B,AAEE,IAAAkG,aAA0BlG;IAA1BmG,aAAA,AAAA1H,cAAAyH;IAAAE,eAAA,AAAApK,gBAAAmK;IAAAA,iBAAA,AAAAlK,eAAAkK;YAAAC,RAAOxB;4BAAPuB,xBAAeE;IACTC,WAAS,AAAA,mKAAe,AAACvL,2EAASN,MAAMmK;AAD9C,AAEE,IAAA2B,iBAAe9L;IAAf+L,iBAAqBtM;IAArBuM,iBAAA,2CAAA,iQAAA,uSAAA,kJAAA,+DAAA,vmBAA6C,CAAA,0FAAmDH,qKACnD,6CAAA,7CAAChO,+EAAS,AAACsE,6CAAKoD,SAASiG,mNACxBA;AAF9C,AAAA,6KAAAM,eAAAC,eAAAC,mFAAAF,eAAAC,eAAAC,3TAAC3D,uFAAAA,qIAAAA;;2IAGGrI,rDACA,AAACkK,2DAAiBzK,IAAI8F,SAAS4E,/IAC/B,AAACmB,sJAA8BnB,MAAMyB,3KACrC,IAAAK;IAAAC,WAAezM;IAAf0M,WAAA,2CAAA,kJAAA,iBAAA,iJAAA,sEAAA,kJAAA,+DAAA,lOACyCX,NAAerB,yNAChBqB;AAFxC,AAAA,oLAAAS,SAAAC,SAAAC,6EAAAF,SAAAC,SAAAC,7RAAC9D,uFAAAA,mHAAAA;;AAQT,yDAAA,uEAAA+D,hIAAM/D,0HACFrI,eAA2CwM;AAD/C,AAAA,IAAAH,aAAAD;IAAAC,iBAAA,AAAAnN,4BAAAmN;sBAAA,AAAAlN,4CAAAkN,eAAA,7EACmBC;qBADnB,AAAAnN,4CAAAkN,eAAA,5EAC8BE;AAD9B,AAEG,oBAAID;AACF,IAAMG,YAAe,AAACC,kDAAS,AAACC,+CAAO,iBAAAvJ,mBAAImJ;AAAJ,AAAA,oBAAAnJ;AAAAA;;AAAA;;KAAR;IACzBqJ,gBAAe,qDAAA,nDAAI,AAACzI,cAAIyI,YAAK,WAAA,VAAKA;IAClCG,mCAAe,4EAAA,kJAAA,WAAAC,zOAACC,8DAAeN;AAAhB,AAAkD,kEAAAK,1DAAKJ;;AAF5E,AAGE,AAACnN,mDAAMgN,gBAAWS,4KAAS/M,tDAAM,4DAAA,wLAAA,pPAACkD,vGACP,AAACvC,8eAAMiM;;AALtC;;AAMA5M;;AAEH,iDAAA,jDAAMgN;AAAN,AAAA,kDAAA,2HAAA;;AAGA,+CAAA,/CAAMC;AAAN,AAAA,kDAAA,wLAAA,6IAAA,/LACoB,6CAAA,7CAACC;;AAGrB;;;;gDAAA,hDAAMC,wGAGH1N;AAHH,AAIE,IAAA2D,mBAAI,iBAAAgK,WAAQ3N;IAAR2N,eAAA,EAAA,CAAAA,YAAA,OAAA,KAAA,eAAAA,fAAYC;IAAZD,eAAA,EAAA,CAAAA,gBAAA,OAAA,KAAA,AAAA,wKAAAA;AAAA,AAAA,GAAA,CAAAA,gBAAA;AAAA;;AACQ,2BAAAA,pBAACE,iCAAU,AAACD,eAAK5N;;;AAD7B,AAAA,oBAAA2D;AAAAA;;AAEI3D;;;AAEN;;;2DAAA,3DAAM8N,8HAEHvN,MAAMP,IAAI+N;AAFb,8DAGM,qDAAA,rDAACjH,+CAAOvG,yJAA0B4J,yDAAkB4D,/TACpD,yUAAA,2CAAA,8IAAA,8KAAA,zqBAACnF,8TAAc5I,6fACwB,CAAA,gIAAA,nHAAkB,AAACgO,wGAAOD;;AAEvE,kDAAA,lDAAME,4GAAa1N,MAAM2N;AAAzB,AACE,4DAAA,rDAACpH,+CAAOvG,uIAAiB4N,4BAAWD;;AAEtC,AAAA;;;;wDAAA,gEAAA/N,xHAAMkO;AAAN,AAAA,IAAAD,WAAA,AAAA;AAAA,AAAA,QAAAA;KAAA;AAAA,OAAAC,oFAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;KAAA;AAAA,OAAAA,oFAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;;AAAA,MAAA,KAAA/N,MAAA,CAAA,8DAAA,AAAA;;;;;AAAA,CAAA,sFAAA,wBAAAgO,9GAAMD,iGAGFG;AAHJ,AAAA,IAAAD,aAAAD;IAAAC,iBAAA,AAAA9O,4BAAA8O;wBAAA,AAAA7O,4CAAA6O,eAAA,/EAG0BE;AAH1B,AAIG,IAAAC,WAAQF;AAAR,AAAA,oBACEC;AACA,sDAAAC,SAAA,xDAAC5H,2MAA2BqD,yDAAkB,iBAAAxG,mBAAI8K;AAAJ,AAAA,oBAAA9K;AAAAA;;AAAA;;;;AAFhD+K;;;;AAJH,CAAA,sFAAA,tFAAML,iGAOFG,aAAajO,MAAMP,IAAI+N;AAP3B,gEAQO,AAACY,oFAAkBH,aAAajO,jKAChC,OAACuN,iKAAqB9N,IAAI+N;;;AATjC,CAAA,gFAAA,hFAAMM;;AAAN,AAWA;;;qDAAA,6DAAAO,lHAAOE;AAAP,AAAA,IAAAD,aAAAD;IAAAC,iBAAA,AAAApP,4BAAAoP;kBAAA,AAAAnP,4CAAAmP,eAAA,zEAEYE;AAFZ,AAKE,qBAAA,eAAIA,fAAYvE,dAAKwE;;AAEvB;;;gDAAA,hDAAOC,wGAEJ1O,MAAMG;AAFT,AAKE,4DAAA,mFAAA,xIAACD,+CAAOF,4NAAmBG;;AAE7B;;;;;uEAAA,qFAAAwO,5JAAME,sJAIH7O;AAJH,AAAA,IAAA4O,aAAAD;IAAAC,iBAAA,AAAA1P,4BAAA0P;UAAA,AAAAzP,4CAAAyP,eAAA,jEAIiBE;eAJjB,AAAA3P,4CAAAyP,eAAA,tEAIqBG;YAJrB,AAAA5P,4CAAAyP,eAAA,nEAI8BI;AAJ9B,AAKE,oBAAI,iBAAA5L,mBAAI2L;AAAJ,AAAA,oBAAA3L;AAAAA;;AAAa4L;;;AACf,4DAAA,rDAACzI,+CAAOvG,mJAAuB4D,4BAAWkL;;AAC1C9O;;;AAEJ,wDAAA,sEAAAiP,9HAAME,wHAAmBnP;AAAzB,AAAA,IAAAkP,aAAAD;IAAAC,iBAAA,AAAAhQ,4BAAAgQ;UAAA,AAAA/P,4CAAA+P,eAAA,jEAAuCJ;AAAvC,AACE,4DAAA,rDAACvI,+CAAOvG,qIAAe4D,4BAAWkL;;AAEpC,4DAAA,5DAAMM,gIAAuBpP,MAAMgJ;AAAnC,AACE,4DAAA,rDAACzC,+CAAOvG,iJAAqB4D,4BAAWoF;;AAM1C;;;;kEAAA,0EAAAqG,5IAAOE;AAAP,AAAA,IAAAD,aAAAD;IAAAC,iBAAA,AAAApQ,4BAAAoQ;WAAAA,PAG0BjP;eAH1B,AAAAlB,4CAAAmQ,eAAA,tEAGYnL;AAHZ,AAKE,IAAMwB,WAAS,AAACxC,kDAAc9C;AAA9B,AACE,IAAAmP,WAAA;IAAAA,eAAA,4FAAAA,1EACE7J,UACA,6CAAA6J,7CAAC3R,sDAAK8H;AAFR,AAAA,oBAIExB;AACA,oDAAAqL,7CAACrN,0DAAKgC;;AALRqL;;;AAOJ;;;;qDAAA,rDAAOC,kHAGJzP,MAAMC;AAHT,AAME,IAAOyP,aAAW,0DAAA,1DAACC,6IAAY1P;gBAA/B,ZACO2P;;AADP,AAEE,IAAArP,qBAAkB,AAACuP,eAAKJ;AAAxB,AAAA,oBAAAnP;AAAA,2BAAAA,vBAASsP;AAAT,AACE,IAAAE,aAA8B,AAACzP,2EAASN,MAAM6P;IAA9CE,iBAAA,AAAA7Q,4BAAA6Q;mBAAA,AAAA5Q,4CAAA4Q,eAAA,1EAAe/J;AAAf,AACE,eACE,AAACnI,6CAAK,AAACmS,cAAIN,YAAY1J;eACvB,AAAC7D,6CAAKyN,UAAUC;;;;;AACpBD;;;;;AAEN;;;;;sDAAA,tDAAOK,oHAIJjQ,MAAMC;AAJT,AAME,IAAMiQ,aAAW,AAACX,gEAA4B,AAACjP,2EAASN,MAAMC;AAA9D,AACE,GACE,AAAC+D,cAAIkM;AACL,YAAAC,kBAAA,KAAA;AAAA,AAAU,OAACC,eAAKnQ,QAAQ,AAACyC,8CAAM2N,iBAAO,4CAAA,WAAAC,vDAAC/F;AAAD,AAAM,oLAAA+F,wFAAAA,pQAACL,oFAAAA,4GAAAA,1BAAgBjQ,wFAAAA;GAASkQ;GAAtE,KAAA;;AAFF,AAKE,YAAAC,kBAAA,KAAA;AAAA,AAAA,0FAAWlQ;GAAX,KAAA;;;;AAEN;;;gEAAA,8EAAAsQ,9IAAOE,wIAEJzQ;AAFH,AAAA,IAAAwQ,aAAAD;IAAAC,iBAAA,AAAAtR,4BAAAsR;cAAA,AAAArR,4CAAAqR,eAAA,rEAEkBvQ;AAFlB,AAIE,IAAMI,OAAK,AAACC,2EAASN,MAAMC;AAA3B,AACE,kBAAA,dAAO4Q,iGAAaxQ;IAApBqQ,WAC2BrQ;IAD3BsQ,aAAAD;IAAAC,iBAAA,AAAAzR,4BAAAyR;eAAA,AAAAxR,4CAAAwR,eAAA,tEACgBxM;AADhB,AAAA,IAAO0M,kBAAAA;IAAPH,eAAAA;;AAAA,AAAA,IAAOG,kBAAAA;IAAPD,aAAAF;IAAAE,iBAAA,AAAA1R,4BAAA0R;mBAAA,AAAAzR,4CAAAyR,eAAA,1EACgBzM;AADhB,AAEE,IAAA5D,qBAAc,AAACD,2EAASN,MAAMmE;AAA9B,AAAA,oBAAA5D;AAAA,WAAAA,PAASuQ;AAAT,AACE,eAAO,AAAC3O,6CAAK0O,gBAAYC;eAAMA;;;;;AAC/BD;;;;;AAER;;;qDAAA,rDAAME,kHAEH/Q,MAAMK;AAFT,AAAA,mFAAA,6HAAA,kKAAA,zCAGkB2Q;;AAChB,OAAClB,eAAK,AAACW,8DAA0BzQ,MAAMK;;AAMzC,iEAAA,jEAAM4Q,0IAA4BjR,MAAMgJ,KAAKkI;AAA7C,yDACMlR,zDACA,+DAAA,mFAAA,3IAACiC,8QAAuB+G,aAAMc,uGACxB,AAACqH,qEAA2BD,1HAC5B,iIAAA,qDAAA,uGAAA,yDAAA,tVAACvR,iVAAuBqJ,yEAAmBA;;AAEvD;;;;6DAAA,7DAAOoI,kIAGJ3R,IAAI4R,UAAUH;AAHjB,AAKE,IAAMI,UAAQ,AAACC,kFAAaF,UAAUH;AAAtC,AACE,GAAI,AAAClN,cAAIsN;AACP,IAAMtR,QAAM,iBAAAwR,gEACM,AAACrE,8CAAU1N,nGACX,wGAAA,yMAAA,jTAACE,qPACkB0R,6JACY,AAACF,qEAA2BG;AAJjE,AAAA,kLAAAE,4EAAAA,tPAACC,sFAAAA,gGAAAA;;AAAb,AAKE,OAAC9K,uBACC,WAAA+K;AAAA,AAAA,IAAAC,aAAAD;WAAA,AAAAlU,4CAAAmU,WAAA,IAAA,lEAAM3I;UAAN,AAAAxL,4CAAAmU,WAAA,IAAA,jEAAWC;AAAX,AACE,IAAArR,qBAAoB,AAACwI,4DAAwB/I,MAAMP,IAAIuJ;AAAvD,AAAA,oBAAAzI;AAAA,iBAAAA,bAASsR;AAAT,AACE,GAAI,AAAC7N,cAAI6N;AACP,sBAAA,WAAAC,1BAACC;AAAD,AAAO,gMAAAD,iGAAAA,zRAACV,2FAAAA,qHAAAA,5BAAiB3R,iGAAAA,5EAAMmS,iGAAAA;GAAKC;;AADtC;;;AADF;;GAIFX;;AAZN;;;AAeJ,6EAAA,7EAAMc,kKAAwChS,MAAMP,IAAIuJ,KAAKkI,MAAMe;AAAnE,AACE,iEAAA,2CAAA,5GAAC5J,uDAAcrI,MAAMP,iMAAwB,CAAA,kCAAuC,wGAAA,xGAACgO,wJAAQzE,KAAKkI;;AAIlG,IAAMgB,gBAAc,6CAAA,7CAACrU,8EACK,AAAC0M,4CAAI,WAAKlK;AAAL,AACE,IAAA8R,WAAQ9R;AAAR,AAAA,GACE,AAAC+Q,2DAAiB3R,mNAAQY,/MAAoB,4CAAA,AAAA,5CAAClB,qNAAI6J,MAAOkI;AAC1D,qDAAAiB,SAAA,mEAAA,1HAACxS;;AAFHwS;;IAGPF;AAL1B,AAME,oBAAI,eAAA,fAACF,kFAAkBG;sEACjB,AAAC1M,+CACC,aAAA4M,FAAK3M,hIAMP,OAACwL;AANC,AAAA,IAAAoB,aAAAD;IAAAC,iBAAA,AAAAnT,4BAAAmT;wBAAA,AAAAlT,4CAAAkT,eAAA,/EAAeC;cAAf,AAAAnT,4CAAAkT,eAAA,rEAAoCpS;AAApC,AACE,GAAA,AAAAyE,cAAQ4N;AACN,gEAAA,6IAAA,tMAAC1R,+CAAW6E,EAAExF;;AACdwF;;GACJzF,MACAkS,eAC0BlJ,KAAKkI;;+GACjClR,/CACA,qDAAA,rDAACkD,hEACD,mPAAA,5OAACqK,wOAAqB9N,oDAAKuJ,KAAKkI;;;AAE1C,yEAAA,uFAAAqB,hKAAME,0JACHzS,eAAyCgJ,KAAKkI;AADjD,AAAA,IAAAsB,aAAAD;IAAAC,iBAAA,AAAAtT,4BAAAsT;UAAAA,NACuC/S;sBADvC,AAAAN,4CAAAqT,eAAA,7EACkBE;AADlB,AAEE,iEAAA,2CAAA,5GAACrK,uDAAcrI,MAAMP,iMAAwB,CAAA,qEAAA,gDAA+BuJ,KAAKkI;;AACjF,IAAMyB,gGAAW3S,/CACA,qDAAA,rDAACkD,5BACD,iBAAA0P;IAAAC,uJACMpT,/CACA,mDAAA,nDAACyD,/CACD,2NAAA,3NAACqD,0WAAyB3C,4BAAW,AAAA,sJAAoBnE,1kBACzD,glBAAA,iGAAA,2CAAA,qDAAA,qDAAA,yDAAA,/3BAACE,03BAGgBqJ,yEACAA;AARvB,AAAA,8LAAA4J,SAAAC,kFAAAD,SAAAC,1RAACC,4FAAAA,+GAAAA;;AAFlB,AAWE,oBAAI,AAAA,uJAAQH;AACV,IAAMV,QAEK,6CAAA,WAAAc,xDAAC5J;AAAD,AAAO,4FAAA4J,rFAAC3S,8DAA0BuS,mBAAOlT;GADzC,kEAAA,mFAAA,rJAACS,+CAAOyS,+OAAsB3J;IAGnCgK,QACA,AAAC7T,4CAAIuT,gBAAgB1J;AAL3B,AAME,oBAEEgK;uHACIL,vDACA,8EAAA,2CAAA,zHAACtK,0EAAc5I,iMAAwB,CAAA,uFAAgDuJ,naACvF,4bAAA,mFAAA,gKAAA,qDAAA,qDAAA,2GAAA,yEAAA,t8BAAC/G,2oBAAuB+G,aAAMiK,gOAEvBjK,yEACSA,6DACPgK;;AATf,GAYE,AAAChP,cAAIkN;AACL,OAACc,2EAAuCW,mBAAOlT,IAAIuJ,KAAKkI,MAAMe;;AAbhE,AAgBEU;;;;;AACJA;;;AAEN,wEAAA,sFAAAO,9JAAME,wJACHpT,eAAwCgJ,KAAKkI;AADhD,AAAA,IAAAiC,aAAAD;IAAAC,iBAAA,AAAAjU,4BAAAiU;UAAAA,NACsC1T;qBADtC,AAAAN,4CAAAgU,eAAA,5EACkBE;AADlB,AAEE,GAAI,AAACjC,2DAAiB3R,IAAI,AAACN,4CAAIkU,eAAerK,MAAMkI;AAApD,2bAAA,5RACO,AAACD,+DAA2BjR,MAAMgJ,KAAKkI,/IACvC,sJAAA,2CAAA,yDAAA,6DAAA,vTAACrC,qPAAuC7F;;AAF/C,2NAAA,jIAMG,mEAAA,nEAACuE,yDAAqBvN,MAAMP,oDAAKuJ,KAAKkI;;;AAO3C;;;;sDAAA,tDAAMoC,oHAGH7T,IAAI8T;AAHP,AAIE,IAAM1H,WAAS,AAACnL,oDAAoBjB,IAAI8T;AAAxC,AACE,IAAAnQ,mBAAI,AAAA,4KAAoByI;AAAxB,AAAA,oBAAAzI;AAAAA;;AACImQ;;;AAER,wFAAA,gGAAAC,xLAAME;AAAN,AAAA,IAAAD,aAAAD;IAAAC,iBAAA,AAAAvU,4BAAAuU;UAAAA,NAIkBhU;UAJlB,AAAAN,4CAAAsU,eAAA,jEAGIE;gBAHJ,AAAAxU,4CAAAsU,eAAA,vEACmBvO;cADnB,AAAA/F,4CAAAsU,eAAA,rEAEmBlM;AAFnB,AAKE,GAAI,AAACvD,cAAI,AAAA,2FAAW2P;AAClB,IAAMnT,SAAY,AAACE,oDAAoBjB,IAAI8H;IACrC8J,YAAY,sDAAA,mFAAA,zIAACnR,+CAAOM,+NAAuB0E;IAC3ClF,QAAY,iBAAA4T,gEAAuB,AAACzG,8CAAU1N,nGACX,wGAAA,uJAAA,/PAACE,yMAC8BgU,mMACZtC;AAH1C,AAAA,kLAAAuC,4EAAAA,tPAACnC,sFAAAA,gGAAAA;;IAIboC,cAAY,AAACrO,+CACC,aAAAsO,FAAKE;AAAL,AAAA,IAAAD,aAAAD;IAAAC,iBAAA,AAAA7U,4BAAA6U;YAAA,AAAA5U,4CAAA4U,eAAA,nEAAgBE;AAAhB,AACE,OAACC,uFAAkBF,EAAEC;GAFzB,mCAIE,AAACE,eAAK,AAAA,yJAASnU;IAC7BoU,YAAY,AAACC,qEAA2BV;AAX9C,AAYE,OAACW,yDAAkBjD,UAAU,AAAC6C,uFAAkBL,YAAYO;;AAbhE;;;AAeF;;;oEAAA,4EAAAG,hJAAME;AAAN,AAAA,IAAAD,aAAAD;IAAAC,iBAAA,AAAAtV,4BAAAsV;UAAAA,NAMkB/U;UANlB,AAAAN,4CAAAqV,eAAA,jEAKIb;YALJ,AAAAxU,4CAAAqV,eAAA,nEAEmBP;gBAFnB,AAAA9U,4CAAAqV,eAAA,vEAGmBtP;cAHnB,AAAA/F,4CAAAqV,eAAA,rEAImBjN;AAJnB,AAOE,IAAMmN,aAAW,AAAA,sFAASf;IACpBnT,SAAW,AAACE,oDAAoBjB,IAAI8H;IACpCoN,uBAAW,iBAAAvR,mBAAI,AAAA,4KAAoB5C;AAAxB,AAAA,oBAAA4C;AAAAA;;AAAgCmE;;;IAC3CqN,iBAAW,AAACC,4DAAsBpV,IAAIkV;IACtC/C,MAAW,6HAAA,3GAAIgD,gBAAS,AAAClB,sFAAkDjU;eAJjF,XAKMqV,2DAAY5P,UAAU,iBAAA9B,mBAAIwO;AAAJ,AAAA,oBAAAxO;AAAAA;;AAAA;;;AAL5B,AAME,IAAA2R,WACE,iDAAA,2CAAA,0JAAA,yIAAA,/XAACvV,6CAASC,oLACekV,qJACAG,qIACAb;IAJ3Bc,eAAA,8NAAAA,5NAME,AAAC/Q,cAAI0Q,aACL,8CAAAK,SAAA,vDAACpV,qLAAe+U;AAPlB,AAAA,oBASEE;AACA,qDAAAG,aAAA,wIAAA,2CAAA,qDAAA,qDAAA,xVAACpV,qZAEY,kBAAIiS,KACF,iBAAMoD,mBAAK,AAAC7D,qEAA2BS;AAAvC,AAAA,0FACG,yDAAA,4NAAA,rRAACjS,qDAAMgU,iEACK,AAAA,2FAAWqB,4HACd,AAACC,sCAAeD;KAJ9B,mFAKGrB;;AAjBlBoB;;;AAmBJ;;;;4DAAA,0EAAAG,tIAAME,gIAGHpV,eAA+BqV;AAHlC,AAAA,IAAAF,aAAAD;IAAAC,iBAAA,AAAAjW,4BAAAiW;UAAAA,NAG6B1V;YAH7B,AAAAN,4CAAAgW,eAAA,nEAGkBlB;AAHlB,AAIE,IAAMqB,iBAAe,AAACzX,kEAEC,4CAAA,WAAA0X,vDAAChL,rBAgmDtB,AAAAqU;AAhmDqB,AAAM,OAACnK,kEAA8B,kDAAA,qIAAAc,vLAAC5V,8CAAMF;IAC5C4V;AAHvB,AAIE,GAAI,AAACrR,cAAIsR;kEACH,+CAAA,WAAAE,iBAAAC,3EAACjQ,nDAGD,AAACgD,fACD,IAAMP;AAJN,mGACa,iDAAAuN,iBAAAC,lEAACnO,nGACD,OAACrC,gLAA0BxF,IAAI,AAAA,8JAAAgW;GAAiBzV,MAAMsV,gBACnD7V,IAAI,6CAAA,7CAAC0J,6KAAemM;AACpC,AACE,2EAAA,2CAAA,6SAAA,6kBAAA,kJAAA,iNAAA,50CAACjN,uDAAcJ,SAAGxI,iMAAwB,CAAA,4BAAiC,AAACgO,wGAAOwG,uKACzC,6CAAA,7CAACpW,4FAAO,AAAA,uJAAQoK,YAAK,4CAAA,5CAACsC,6KAAe+K,kNACpC,AAAA,uJAAQrN;;AACzD,wEAAA,2CAAA,kJAAA,9PAACI,uDAAcrI,MAAMP;;;AAE3B;;;kEAAA,0EAAAiW,5IAAME,qJAE+BP;AAFrC,AAAA,IAAAM,aAAAD;IAAAC,iBAAA,AAAAzW,4BAAAyW;UAAAA,NAEgClW;qBAFhC,AAAAN,4CAAAwW,eAAA,5EAEYtC;AAFZ,wGAGO,AAACwC,kDACC,4CAAA,WAAAC,vDAACvL,1JAIH,OAACgH,kFAAa8B;AAJZ,AAAM,kEAAAyC,3DAACC,uDAAuBtW;6DADhC,zDAEEmK,4FAEAyL;;AAGT,iEAAA,+EAAAW,hJAAME,0IACHlW,eAAwCsR;AAD3C,AAAA,IAAA2E,aAAAD;IAAAC,iBAAA,AAAA/W,4BAAA+W;UAAAA,NACsCxW;qBADtC,AAAAN,4CAAA8W,eAAA,5EACkB5C;AADlB,AAEE,OAAC8C,oBACC,WAAAC,SAAsBpN,KAAKkI;AAA3B,AAAA,IAAAmF,aAAAD;gBAAA,AAAA5Y,4CAAA6Y,WAAA,IAAA,vEAAMrW;eAAN,AAAAxC,4CAAA6Y,WAAA,IAAA,tEAAYC;AAAZ,AACE,GAAI,AAACpZ,0BAAUmW,eAAerK;AAC5B,IAAAuN,aAAyB,AAACnD,sEAAkCpT,UAAMP,IAAIuJ,KAAKkI;yBAA3E,AAAA1T,4CAAA+Y,WAAA,IAAA,hFAAO5D;sBAAP,AAAAnV,4CAAA+Y,WAAA,IAAA,7EAAcC;AAAd,AACE,oBAAIA;AAAJ,0FACG7D,mBAAO2D;;AACR,yBAAA,sGAAA,xHAACG,qGAAS9D;;;AAEd,IAAMA,qBAAO,AAACF,uEAAmCzS,UAAMP,IAAIuJ,KAAKkI;AAAhE,AACE,IAAA3Q,qBAAc,AAAA,uJAAQoS;AAAtB,AAAA,oBAAApS;AAAA,WAAAA,PAASyC;AAAT,AAAA,0FACG2P,mBACA,AAAChT,8CAAM2W,SAAStN,KAAKhG;;AACtB,yBAAA,qMAAA,vNAACyT,qGAAS,AAACrI,oFAAkBpO,UAAM2S;;;GAZ7C,yFAAA,NAaG3S,iDACDsR;;AAEJ,0EAAA,wFAAAoF,lKAAME,4JACH5W,eAAwC6W,YAAYP;AADvD,AAAA,IAAAK,aAAAD;IAAAC,iBAAA,AAAAzX,4BAAAyX;UAAAA,NACsClX;qBADtC,AAAAN,4CAAAwX,eAAA,5EACkBtD;AADlB,AAEE,OAAC8C,oBACC,WAAAW,SAAsB9N,KAAKkI;AAA3B,AAAA,IAAA6F,aAAAD;gBAAA,AAAAtZ,4CAAAuZ,WAAA,IAAA,vEAAM/W;mBAAN,AAAAxC,4CAAAuZ,WAAA,IAAA,1EAAYT;AAAZ,AACE,GAAI,AAACpZ,0BAAUmW,eAAerK;AAC5B,IAAAgO,aAAe,AAAC5D,sEAAkCpT,UAAMP,IAAIuJ,KAAKkI;yBAAjE,AAAA1T,4CAAAwZ,WAAA,IAAA,hFAAOrE;AAAP,AAAA,0FACGA,mBAAO2D;;AAEV,IAAM3D,qBAAO,AAACF,uEAAmCzS,UAAMP,IAAIuJ,KAAKkI;AAAhE,AACE,IAAA3Q,qBAAc,AAAA,uJAAQoS;AAAtB,AAAA,oBAAApS;AAAA,WAAAA,PAASyC;AAAT,AAAA,0FACG,iBAAAiU,WAAQtE;AAAR,AAAA,GACE,AAACzV,0BAAUoZ,aAAStN;8DAChB,6DAAAiO,SAAA,tEAACrQ,yJAA0B,AAACzH,4CAAImX,aAAStN,hRACzC,mSAAA,2CAAA,kJAAA,zdAACX,wRAAc5I;;AAHrBwX;;KAIA,AAACtX,8CAAM2W,aAAStN,KAAKhG;;AALxB,0FAMG,AAACoL,oFAAkBpO,UAAM2S,oBAAQ2D;;;GAb5C,mFAcGtW,MAAMsW,iBACPO;;AAEJ,4DAAA,5DAAOK,gIACJzX,IAAI4V;AADP,AAEE,oDAAA,7CAACxX,gFACK,AAACwM,6CAAK,4CAAA,WAAA8M,vDAAC5M;AAAD,AAAM,+DAAA4M,xDAACzW,oDAAoBjB;IAC3B,+CAAA,/CAAC2X,iLACD,AAACC,6CAAK,WAAKC;AAAL,AAAQ,GAAI,EAAK,AAACra,qBAAKqa,QAAG,AAACC,sDAAwB,AAAChW,gBAAM,AAAC4S,eAAKmD;AACtD,OAAC/V,gBAAM+V;;AADT;;KAEpBjC;;AAER;;;4DAAA,5DAAMmC,gIAEHxX,MAAMP,IAAI6R,QAAQmG;AAFrB,AAGE,IAAMxZ,IAAE,iEAAA,2CAAA,5GAACoK,uDAAcrI,MAAMP,iMAAwB,CAAA,qNAAA,5JAAkB,AAAA,sJAAoBA,wBAAuB,AAACgO,wGAAO6D;IAA1HoG,aACwB,AAACxB,+DAA2BlW,MAAMP,IAAI6R;yBAD9D,AAAA9T,4CAAAka,WAAA,IAAA,hFACO/E;eADP,AAAAnV,4CAAAka,WAAA,IAAA,tEACcpB;AADd,AAEE,GAAI,GAAA,aAAA,ZAAOA;AAET,IAAAqB,aAA8B,AAACf,wEAAoCjE,mBAAOlT,IAAIgY,kBAAkBnB;sCAAhG,AAAA9Y,4CAAAma,WAAA,IAAA,7FAAOC;oBAAP,AAAApa,4CAAAma,WAAA,IAAA,3EAAeE;IACTC,YAAU,AAAC3D,eAAK,AAACxT,uGAAM2V,SAASuB;AADtC,2CAEMD,5BACA,iBAAAG,hCAMA,IAAM9P;IANN8P,eAAA,kPAAAA,hPACE,AAAC/T,cAAI8T,YACL,oDAAAC,pDAAChQ,6DAAgBtI,IAAI,AAAC0U,eAAK,AAACxT,uGAAM2V,SAASuB;AAF7C,AAAA,GAIE,AAACG,uBAAOF;AACR,yDAAAC,lDAAC9U,+DAAc,AAAA,uJAAQjD;;AALzB+X;;;AAMA,AACE,2EAAA,2CAAA,8IAAA,gKAAA,8SAAA,0aAAA,kJAAA,iNAAA,x9CAAC1P,uDAAcJ,SAAGxI,+eACwB,CAAA,2BAAgC,AAACgO,wGAAO6D,yKACxC,6CAAA,7CAACzT,4FAAO,AAAA,uJAAQoK,YAAK,AAACkM,eAAKmC,6MAC1B,AAAA,uJAAQrO;;iMAGvDjI,/CACA,qDAAA,rDAACkD,pFACD,AAACkL,mQAAkBuE,jUACnB,yVAAA,2CAAA,8IAAA,8JAAA,zqBAACtK,8UAAc5I,6eACwB,CAAA,kCAAuC,AAACgO,wGAAO6D;;;AAEhG;;;;;;;;;oEAAA,kFAAA2G,tJAAME,gJAQHnY,eAIAiU,MAAMoB;AAZT,AAAA,IAAA6C,aAAAD;IAAAC,iBAAA,AAAAhZ,4BAAAgZ;UAAAA,NAWkBzY;qBAXlB,AAAAN,4CAAA+Y,eAAA,5EASmB7E;gBATnB,AAAAlU,4CAAA+Y,eAAA,vEAUmBhT;AAVnB,AAaE,GAAI,AAAChI,0BAAU+W,MAAM/O;AAEnBlF;;AAEA,IAAMsR,UAAa,AAACC,kFAAa8B,eAAeY;IAC1CoE,eAAa,AAACzC,gEAA4BnW,IAAI4V;IAC9C5V,UAAa,kDAAA,lDAACE,8CAAMF,gIAAYwU;IAFtCmE,aAGoC,AAAChD,0DAAsBpV,MAAMP,QAAI4V;IAHrE+C,iBAAA,AAAAlZ,4BAAAkZ;yBAAAA,rBAG4BzF;gBAH5B,AAAAxT,4CAAAiZ,eAAA,vEAGOE;AAHP,AAIE,oBAAIA;AACF,GAAI,AAACtU,cAAI,AAACrD,uGAAM2Q,QAAQ+G;AACtB,IAAME,kBAAgB,AAACf,0DACC7E,gHACIlT,9CACA,sDAAA,tDAACE,uMAAwB,AAACuX,0DAAsBzX,QAAI4V,xTACpD,oUAAA,8IAAA,WAAAmD,7dAACjS;AAAD,AAA0B,QAAK,iBAAAnD,mBAAAoV;AAAA,AAAA,oBAAApV;AAAAA;;AAAA;;OAAL;IAC9BkO,QACA+G;AANxB,AAOE,GACE,AAAC3Q,6CAAE,AAAA,uJAAQ6Q,iBAAiBD;8DACxBC,9DACA,sFAAA,2CAAA,8IAAA,mKAAA,kJAAA,oCAAA,iJAAA,lvBAAClQ,uEAAc5I,0tBAE0B6Y;;AAL/C,oBAOE,AAAA,uJAAQC;AACR,IAAME,eAAa,AAAA,8JAAW,AAAC1H,mDAAewH,gBAAgB,AAACxV,kDAAcwV;AAA7E,8DACM,AAACjU,oFAAkBiU,gBAAgBE,aAAaH,/KAChD,kMAAA,2CAAA,8IAAA,2KAAA,kJAAA,eAAA,hsBAACjQ,mLAAc5I,8pBAEwB,6CAAA,kCAAA,/EAAC5B,kKAAU4a,aAAaH;;AAZvE,2FAeMtY,3FACA,OAACoO,0FAAkBmK;;;;;AAC3B5F;;;AACF3S;;;;AAER;;;;;;;;;;;;;;;;;;;;;;;;;oEAAA,kFAAA0Y,tJAAME,gJAwBH5Y;AAxBH,AAAA,IAAA2Y,aAAAD;IAAAC,iBAAA,AAAAzZ,4BAAAyZ;UAAAA,NA2BkBlZ;gBA3BlB,AAAAN,4CAAAwZ,eAAA,vEAyBmBE;gBAzBnB,AAAA1Z,4CAAAwZ,eAAA,vEA0BmBzT;AA1BnB,AA4BE,IAAMlF,YAAM,iEAAA,2CAAA,8IAAA,uKAAA,jaAACqI,uDAAcrI,MAAMP,sfACwB,CAAA,iEAA0ByF;IADnF4T,aAIM,AAAC3C,oBACC,WAAA6C,SAAsC/E,MAAMoB;AAA5C,AAAA,IAAA4D,aAAAD;gBAAA,AAAAxb,4CAAAyb,WAAA,IAAA,vEAAMjZ;YAAN,AAAAxC,4CAAAyb,WAAA,IAAA,nEAAYhH;yBAAZ,AAAAzU,4CAAAyb,WAAA,IAAA,hFAAkBF;AAAlB,AACE,IAAMpG,qBAAO,AAACwF,kEAA8B,yDAAA,zDAACjV,+CAAOlD,oIAAcP,IAAIwU,MAAMoB;AAA5E,AACE,oBAAI,AAAA,uJAAQ1C;AAAZ,0FACGA,mBAAO,AAACxQ,6CAAK8P,MAAM,AAAA,uJAAQU,qBAASoG;;AADvC,0FAEG/Y,UAAMiS,MAAM,AAAC9P,6CAAK4W,mBAAmBpG;;GAL9C,6FAAA,kCAAA,5CAMG3S,sFACD,AAACb,4CAAI0Z,UAAU3T;yBAXvB,AAAA1H,4CAAAsb,WAAA,IAAA,hFAGOnG;eAHP,AAAAnV,4CAAAsb,WAAA,IAAA,tEAGcvT;yBAHd,AAAA/H,4CAAAsb,WAAA,IAAA,hFAGuBC;AAHvB,AAYE,GAAI,AAAC/U,cAAIuB;AACP,OAACiD,mDAAemK,mBAAOlT,IAAI8F;;wEACvBvF,zDACA,uEAAA,0DAAA,jIAACuN,mEAAqB9N,oDAAKyF,tIAC3B,IAAM+C;AAAN,AACE,OAACzC,+CACCsI,sDACA7F,SACA8Q;;;AAEd;;;8DAAA,sEAAAG,SAAAC,7IAAMrG;AAAN,AAAA,IAAAsG,aAAAF;IAAAE,iBAAA,AAAAla,4BAAAka;YAAAA,RAEmCpZ;wBAFnC,AAAAb,4CAAAia,eAAA,/EAEYlL;IAFZmL,aAAAF;IAAAE,iBAAA,AAAAna,4BAAAma;UAAAA,NAMgB5Z;IANhB6Z,aAAA,AAAAna,4CAAAka,eAAA;IAAAC,iBAAA,AAAApa,4BAAAoa;WAAA,AAAAna,4CAAAma,eAAA,lEAKKtQ;sBALL,AAAA7J,4CAAAka,eAAA,7EAGiBE;gBAHjB,AAAApa,4CAAAka,eAAA,vEAIiBR;AAJjB,AAOE,IAAMpZ,UAAI,kDAAA,lDAACE,8CAAMF,4HAAuBuJ;AAAxC,AACE,GACE,AAAC9L,0BAAUgR,kBAAkBlF;AAC7B,4EAAA,2CAAA,8IAAA,8KAAA,5aAACX,uDAAcrI,MAAMP,igBACwB,CAAA,qEAA8BuJ;;AAH7E,GAKE,AAAC9L,0BAAUqc,gBAAgBvQ;AAC3B,4EAAA,2CAAA,8IAAA,yLAAA,vbAACX,uDAAcrI,MAAMP,4gBACwB,CAAA,4EAAqCuJ;;AAPpF,GAWE,AAAC9L,0BAAU2b,UAAU7P;AACrB,OAAC4P,kEAAyB5Y,MAAMP;;AAZlC,AAeE,8EAAA,qDAAA,5HAAC8N,yDAAqBvN,MAAMP,wDAAKuJ;;;;;;AAEvC;;;;;;;;kEAAA,gFAAAwQ,lJAAMG,4IAOH3Z;AAPH,AAAA,IAAAyZ,aAAAD;IAAAC,iBAAA,AAAAva,4BAAAua;UAAAA,NAWeha;IAXfia,aAAA,AAAAva,4CAAAsa,eAAA;IAAAC,iBAAA,AAAAxa,4BAAAwa;UAAAA,NAUU/F;WAVV,AAAAxU,4CAAAua,eAAA,lEASK1Q;qBATL,AAAA7J,4CAAAsa,eAAA,5EAQgBpG;AARhB,AAYE,GACE,AAACuG,qCAAW5Q;8DACR,AAACmG,sDAAkBnP,MAAM2T,1HACzB,mIAAA,2CAAA,8IAAA,uKAAA,5dAACtL,wHAAc5I,sfACwB,CAAA,yBAA8B,AAACgO,wGAAOzE;;AAJnF,GAME,AAAC9L,0BAAUmW,eAAerK;8DACtB,AAAC6F,qEAAiC7O,MAAM2T,zIACxC,kJAAA,2CAAA,8IAAA,2LAAA,/fAACtL,uIAAc5I,0gBACwB,CAAA,2EAAoCuJ;;AATjF,GAWE,AAAC6Q,uDAAqBpa,IAAIuJ;AAC1B,IAAA8Q,WAAoB,AAAC1K,0DAAsBpP,MAAMgJ;IAAjD+Q,WAAuDta;AAAvD,AAAA,8LAAAqa,SAAAC,kFAAAD,SAAAC,1RAACC,4FAAAA,+GAAAA;;AAZH;;;;;AAcF;;;8DAAA,9DAAMA,oIAEHha,MAAMP;AAFT,AAGE,IAAAwa,aACM,AAACzU,+CACC,WAAA0U,SAAsBvG;AAAtB,AAAA,IAAAwG,aAAAD;gBAAA,AAAA1c,4CAAA2c,WAAA,IAAA,vEAAMna;eAAN,AAAAxC,4CAAA2c,WAAA,IAAA,tEAAY5U;AAAZ,AACE,GACE,0BAAA,iFAAA,0DAAA,rKAACrI,8OAAyB,AAAA,mFAAOyW;AACjC,IAAMlU,UAAI,kDAAA,lDAACE,8CAAMF,qGAAiCkU;AAAlD,AACE,IAAAvQ,mBAEE,iBAAA7C,qBAAoC,AAACoZ,gEAA4B3Z,UAAMP;AAAvE,AAAA,oBAAAc;AAAA,IAAA6Z,aAAA7Z;IAAA6Z,iBAAA,AAAAlb,4BAAAkb;yBAAAA,rBAA4BzH;WAA5B,AAAAxT,4CAAAib,eAAA,lEAAkBpX;AAAlB,AAAA,0FACG2P,mBAAO,iBAAA0H,WAAQ9U;AAAR,AAAA,oBAAiBvC;AAAK,oDAAAqX,7CAAClY,sDAAKa;;AAA5BqX;;;;AADV;;;AAFF,AAAA,oBAAAjX;AAAAA;;AAME,IAAAkX,aACM,AAACxH,4DAAwB9S,UACvB,sDAAA,tDAACL,8CAAMF,yGAAiCkU;IAFhD2G,iBAAA,AAAApb,4BAAAob;yBAAAA,rBAAyB3H;WAAzB,AAAAxT,4CAAAmb,eAAA,lEAAetX;AAAf,AAGE,oBAAIA;AAAJ,0FAEG2P,mBAAO,AAACxQ,6CAAKoD,SAASvC;;AAFzB,0FAIG,AAACoL,oFAAkBpO,UAAM2S,oBAAQpN;;;;AAhB5C,GAmBE,kIAAA,lIAACgV,0CAAmB,AAAA,mFAAO5G;AAnB7B,0FAoBG,yDAAA,zDAACpN,+CAAOvG,+IAAkB4N,4BAAW,AAAA,kFAAM+F,MAAMpO;;AApBpD,AAAA,0FAuBGvF,UAAMuF;;;;GAzBb,yFAAA,NA0BGvF,gDACD,AAAA,2FAAW,AAAA,+HAA8BP;yBA5BjD,AAAAjC,4CAAAyc,WAAA,IAAA,hFAAOtH;eAAP,AAAAnV,4CAAAyc,WAAA,IAAA,tEAAc1U;AAAd,AA6BE,GAAI,AAACvB,cAAIuB;AACP,OAACwC,oDAAgB4K,mBAAOlT,IAAI8F;;AAC5BoN;;;AAEN,AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;wDAAA,gEAAA/S,xHAAO6R;AAAP,AAAA,IAAA+I,WAAA,AAAA;AAAA,AAAA,QAAAA;KAAA;AAAA,OAAA/I,oFAAA,CAAA,UAAA;;;KAAA;AAAA,OAAAA,oFAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;;AAAA,MAAA,KAAA1R,MAAA,CAAA,8DAAA,AAAA;;;;;AAAA,CAAA,sFAAA,tFAAO0R,iGAmCHhS;AAnCJ,AA4CG,2FAAA,pFAACkb,uHAAqBlb;;;AA5CzB,CAAA,sFAAA,iBAAAgb,vGAAOhJ,iGA8CHzR;AA9CJ,AAAA,IAAA0a,aAAAD;IAAAC,iBAAA,AAAAxb,4BAAAwb;UAAAA,NAgDkBjb;4BAhDlB,AAAAN,4CAAAub,eAAA,8IAAA,jOA8CmBE;AA9CnB,AA0DG,iEAAA,2CAAA,8IAAA,2JAAA,kJAAA,viBAACvS,uDAAcrI,MAAMP;;AAGrB,wCAAA,4IAAA,skBAAA,nvBAACob,yKAA6Bpb,uFAAK,AAACqb,eAAK,AAAA,kKAAiBrb,MACvB,AAAA,2KAAkBA,KAClB,AAAA,+HAA8BA;AAFjE,AAGG,IAAMsb,qEAAS,AAACpa,uGAAM,AAACsM,+CAAUxN,xMAClB,kOAAA,lOAACub,kNAAU/H,0JAAqBxT;AAD/C,AAEE,IAAAwb,WACE,AAACjB,4DACC,8JAAA,2CAAA,iTAAA,0QAAA,pwBAACrZ,uGAAM,AAACqM,iDACDhN,oLACkB,AAACkb,yCAAiB,AAAA,+HAA8Bzb,4IAChD,AAAA,+HAA8BA,kJAC9B,AAAA,2KAAkBA,mBAC3Csb;AAPJ,AAAA,oBASEH;AACA,4KAAAK,0FAAAA,9PAACE,mFAAAA,8GAAAA,pBAAeJ,0FAAAA;;AAVlBE;;;;;AAlER,CAAA,gFAAA,hFAAOxJ;;AAAP,AAkFA,8EAAA,9EAAM2J,oKACHpb,MAAMqb,SAASC;AADlB,AAEE,IAAMC,KAAG,AAACjb,2EAASN,MAAMqb;IACnBG,KAAG,AAAClb,2EAASN,MAAMsb;AADzB,AAEE,IAAA3W,oBAEE,AAAA,mKAAe4W;AAFjB,AAAA,oBAAA5W;AAIE,OAAC+C,6CAAE,AAAA,mKAAe6T,IAAI,AAAA,mKAAeC;;AAJvC7W;;;AAMJ,qEAAA,rEAAM8W,kJACHzb,MAAMP,IAAIic,UAAUvR,MAAMwR;AAD7B,AAEE,IAAMC,iBAAe,6CAAA,7CAAC/d,+EACK,+CAAA,WAAAge,1DAACrR;AAAD,AAAS,+FAAAqR,xFAACT,4EAAkCpb,MAAMmK;IAClDwR;IACrBG,cAAe,AAACC,6CAAK,AAAC5Z,6CAAKyZ,eAAezR;IAC1CwI,qBAAe,iBAAAqJ,WAAQhc;AAAR,AAAA,GACE,AAACgE,cAAI4X;AACL,wEAAAI,jEAACzQ,0EAA6B9L,IAAIic,UAAUI;;AAF9CE;;;AAJrB,AAAA,0FAQG,iBAAAC,WAAetJ;IAAfuJ,WAAsBzc;IAAtB0c,WAA0B,AAAC5a,gBAAMua;AAAjC,AAAA,0KAAAG,SAAAC,SAAAC,wEAAAF,SAAAC,SAAAC,9QAACC,kFAAAA,8GAAAA;KACD,6CAAA,7CAACve,+EAAS,AAACC,+CAAO8d,gBAAgBD;;AAEvC;;;;kEAAA,lEAAMU,4IAGHrc,MAAMP,IAAI6c,YAAYZ;AAHzB,AAIE,IAAO1b,YAAMA;IAAbuc,WAC0BD;IAD1BE,aAAAD;IAAAE,aAAA,AAAAzY,cAAAwY;IAAAE,eAAA,AAAAnb,gBAAAkb;IAAAA,iBAAA,AAAAjb,eAAAib;YAAAC,RACQvS;eADRsS,XACgBlX;AADhB,AAAA,IAAOvF,YAAAA;IAAPuc,eAAAA;;AAAA,AAAA,IAAOvc,YAAAA;IAAP2c,aAAAJ;IAAAK,aAAA,AAAA5Y,cAAA2Y;IAAAE,eAAA,AAAAtb,gBAAAqb;IAAAA,iBAAA,AAAApb,eAAAob;gBAAAC,ZACQ1S;mBADRyS,fACgBrX;AADhB,AAEE,oBAAI4E;AACF,oBACE,+FAAA,/FAAC7J,2EAASN,UAAMmK;AAChB,IAAA2S,aAAyB,AAACrB,mEAA+Bzb,UAAMP,IAAIic,UAAUvR,UAAM5E;yBAAnF,AAAA/H,4CAAAsf,WAAA,IAAA,hFAAOnK;4BAAP,AAAAnV,4CAAAsf,WAAA,IAAA,nFAAclR;AAAd,AACE,eAAO+G;eAAO/G;;;;;AAHlB,AAME,eACE,CAACwQ,kFAAAA,2GAAAA,3BAAcpc,uFAAAA,7EAAMP,uFAAAA,nFAAI0K,uFAAAA;eACzB5E;;;;;;;AACJvF;;;;;AAEN,uDAAA,vDAAM+c,sHAAkB/c,MAAMgd,KAAKV,YAAYW;AAA/C,AACE,IAAMC,WAAS,6CAAA,7CAACrf,8EACK,6CAAA,WAAAsf,xDAAC9F;AAAD,AACG,IAAMhX,OAAK,iFAAA8c,jFAAC7c,2EAASN;AAArB,AACE,oBAAI,AAAA,4JAAUK;AAAMA;;AAApB;;IACLic;AAJrB,AAKE,GAAI,6BAAA,5BAAG,AAAC3U,gBAAMuV;AACZ,IAAOld,YAAMA;IAAbod,WAC6BF;IAD7BG,aAAAD;IAAAE,aAAA,AAAAtZ,cAAAqZ;IAAAE,eAAA,AAAAhc,gBAAA+b;IAAAA,iBAAA,AAAA9b,eAAA8b;YAAAC,RACQpT;kBADRmT,dACgB3B;AADhB,AAAA,IAAO3b,YAAAA;IAAPod,eAAAA;;AAAA,AAAA,IAAOpd,YAAAA;IAAPwd,aAAAJ;IAAAK,aAAA,AAAAzZ,cAAAwZ;IAAAE,eAAA,AAAAnc,gBAAAkc;IAAAA,iBAAA,AAAAjc,eAAAic;gBAAAC,ZACQvT;sBADRsT,lBACgB9B;AADhB,AAEE,OAACnW,+CACC;kBAAKxF,UAAM2I;AAAX,AAEE,GAAI,AAACjB,6CAAE,AAACC,gBAAM,AAAA,4JAAUwC,YACjB,AAACxC,gBAAM,AAAA,4JAAUgB;AAEtB3I;;AACAA;;;CACJA,UACA2b;;;;AACJ3b;;;AAEN,4DAAA,5DAAM2d,gIACH3d,MAAMP,IAAIQ;AADb,AAEE,IAAA2d,aAAyB,AAACtd,2EAASN,MAAMC;IAAzC2d,iBAAA,AAAA1e,4BAAA0e;cAAA,AAAAze,4CAAAye,eAAA,rEAAeC;AAAf,gIACM7d,hEACA,AAACqc,sEAA4B5c,IAAIoe,QAAQ5d,lJAEzC,OAAC2K,oJAAqBnL,IAAIQ;;AAElC,2DAAA,3DAAM6d,8HAAsB9d,MAAMP,IAAIQ;AAAtC,AACE,IAAA8d,aAAwB,AAACzd,2EAASN,MAAMC;IAAxC8d,iBAAA,AAAA7e,4BAAA6e;aAAA,AAAA5e,4CAAA4e,eAAA,pEAAeC;AAAf,AACE,OAACxY,+CACC,WAAKxF,UAAMC;AAAX,AACE,QAACmc,kFAAAA,6GAAAA,7BAAcpc,yFAAAA,/EAAMP,yFAAAA,rFAAIQ,yFAAAA;GAC3BD,MACAge;;AAEN,oDAAA,pDAAM5B,gHACHpc,MAAMP,IAAIQ;;AADb,AAEE,IAAAM,qBAAc,AAACD,2EAASN,MAAMC;AAA9B,AAAA,oBAAAM;AAAA,WAAAA,PAASF;AAAT,AACE,AACE,iEAAA,2CAAA,gOAAA,iJAAA,7dAACgI,uDAAcrI,MAAMP,iMAAwB,CAAA,0DAAmBQ,mNACjBA;;AAC/C,eACE,iBAAAge,WAAM,AAAC1a,8CAAUlD;IAAjB4d,eAAA,EAAA,CAAAA,oBAAAC,oBAAA,AAAAD,aAAA;AAAA,AAAA,QAAAA;KAAA;AAEEje;;;KAFF;AAKE,OAAC2d,0DAAsB3d,MAAMP,IAAIQ;;;KALnC;AAQE,OAAC6d,yDAAqB9d,MAAMP,IAAIQ;;;;AARlC,MAAA,KAAAF,MAAA,CAAA,mEAAAke;;;;eASAxe;eACA,AAAA,+JAAYY;;;;;;AAChBL;;;;;AAEJ,qDAAA,rDAAMmb,kHACHnb,MAAMP;AADT,gHAEMO,vDACA,iEAAA,2CAAA,kJAAA,9PAACqI,6DAAc5I,tHACf,OAAC2c,4UAAc3c,IAAI,AAAA,uJAAQO;;AAIjC,AAAA,sDAAA,8DAAAJ,pHAAOwe;AAAP,AAAA,IAAAD,WAAA,AAAA;AAAA,AAAA,QAAAA;KAAA;AAAA,OAAAC,kFAAA,CAAA,UAAA;;;KAAA;AAAA,OAAAA,kFAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;;AAAA,MAAA,KAAAre,MAAA,CAAA,8DAAA,AAAA;;;;;AAAA,CAAA,oFAAA,pFAAOqe,+FACH3e;AADJ,AACwB,OAAC4e,kFAAgB5e,IAAI,6CAAA,7CAACyN;;;AAD9C,CAAA,oFAAA,pFAAOkR,+FAEH3e,IAAI6e;AAFR,AAEoD,yDAAA,lDAAC3e,8CAAMF,4IAAkB6e;;;AAF7E,CAAA,8EAAA,9EAAOF;;AAAP,AAIA;;;6DAAA,7DAAMG,kIAEH9e;AAFH,AAGE,IAAM6M,kBAAW,6CAAA,7CAACY;IACZlN,QAAW,iBAAA,AACE,OAAC2a,oFACC,0OAAA,1OAAChb,8CAAM,mDAAA,nDAACuD,+CAAOzD,oRAAgC6M;gBAFnD,QAAAkS,JAG2CC;AAH3C,AAAA,kDAAA,uQAAA,rHAIwB,CAAA,iFAA0C,AAACC,qBAAWD,qEACtDA;;AANzC,AAOE,oDAAA,AAAAE,7CAACxc,6DAAMmK,iBAAW,oDAAA,kJAAA,tMAAC3M,8CAAMK","names":["cljs.spec.alpha/def-impl","cljs.core/pos-int?","cljs.spec.alpha.every_impl","G__83046","cljs.core/set?","cljs.spec.alpha/map-spec-impl","G__83047","cljs.core/map?","cljs.core/contains?","cljs.core/any?","cljs.spec.alpha.tuple_impl","G__83055","i__11949__auto__","v__11950__auto__","cljs.core.nth","G__83056","cljs.core/nat-int?","com.wsscode.pathom3.connect.planner/ignore-nils","m","cljs.core.into","cljs.core.remove","p__83063","vec__83064","_","v","cljs.spec.alpha/and-spec-impl","cljs.spec.alpha.spec_impl","G__83071","G__83076","cljs.core/string?","G__83089","G__83088","cljs.core/coll?","G__83110","cljs.core/vector?","G__83113","cljs.core/boolean?","com.wsscode.misc.refs/atom?","p__83117","map__83118","cljs.core/--destructure-map","cljs.core.get","com.wsscode.pathom3.connect.planner/next-node-id","id-counter","cljs.core.swap_BANG_","cljs.core/inc","com.wsscode.pathom3.connect.planner/new-node","env","node-data","cljs.core.assoc","var_args","G__83121","com.wsscode.pathom3.connect.planner/get-node","js/Error","graph","node-id","cljs.core.get_in","k","com.wsscode.pathom3.connect.planner/node-with-resolver-config","node","com.wsscode.pathom3.connect.planner.get_node","temp__5751__auto__","config","G__83122","com.wsscode.pathom3.connect.indexes/resolver-config","cljs.core.merge","com.wsscode.pathom3.connect.planner/assoc-node","cljs.core/assoc-in","G__83142","com.wsscode.pathom3.connect.planner/update-node","args-arr__4850__auto__","len__4829__auto__","i__4830__auto__","argseq__4851__auto__","cljs.core/IndexedSeq","seq83134","G__83135","cljs.core/first","cljs.core/next","G__83136","G__83137","G__83138","G__83139","G__83140","G__83141","self__4816__auto__","f","cljs.core.update_in","G__83147","cljs.core.conj","G__83148","v2","G__83150","v3","G__83152","args","cljs.core.apply","cljs.core/update-in","G__83154","p__83158","map__83159","com.wsscode.pathom3.connect.planner/get-root-node","root","com.wsscode.pathom3.connect.planner/set-root-node","cljs.core.dissoc","com.wsscode.pathom3.connect.planner/node-branches","or__4223__auto__","com.wsscode.pathom3.connect.planner/branch-node?","cljs.core/boolean","com.wsscode.pathom3.connect.planner/node-kind","com.wsscode.pathom3.connect.planner/node->label","com.wsscode.pathom3.connect.planner/add-node-parent","node-parent-id","com.wsscode.pathom3.connect.planner.update_node","com.wsscode.misc.coll/sconj","com.wsscode.pathom3.connect.planner/remove-node-parent","node-parents'","cljs.core.disj","cljs.core/seq","cljs.core/dissoc","com.wsscode.pathom3.connect.planner/set-node-run-next*","run-next","G__83181","com.wsscode.pathom3.connect.planner/set-node-run-next","com.wsscode.pathom3.connect.planner.set_node_run_next","target-node-id","map__83184","target-run-next","cljs.core/not","and__4221__auto__","cljs.core.not_EQ_","G__83191","com.wsscode.pathom3.connect.planner/set-node-source-for-attrs","p__83193","map__83194","com.wsscode.pathom3.connect.planner.set_node_source_for_attrs","attribute","com.wsscode.pathom3.connect.planner/add-branch-to-node","branch-type","new-branch-node-id","com.wsscode.pathom3.connect.planner/add-node-branches","node-ids","cljs.core.reduce","g","com.wsscode.pathom3.connect.planner/remove-branch-node-parents","branches","n-id","p__83199","map__83200","com.wsscode.pathom3.connect.planner/remove-from-parent-branches","node-parents","nid","n","cljs.core/disj","com.wsscode.pathom3.connect.planner/remove-node-edges","com.wsscode.pathom3.connect.planner/remove-node*","G__83201","cljs.core.update","com.wsscode.pathom3.connect.planner/remove-node","map__83203","p1__83202#","cljs.core/every?","com.wsscode.pathom3.connect.planner/remove-root-node-cluster","vec__83206","seq__83207","first__83208","map__83209","rest","next-nodes","G__83210","p__83212","map__83213","com.wsscode.pathom3.connect.planner/include-node","op-name","G__83217","com.wsscode.pathom3.connect.planner/create-and","cljs.core._EQ_","cljs.core/count","map__83219","and-node-id","and-node","com.wsscode.pathom3.connect.planner/create-root-and","map__83220","<>","G__83221","G__83222","G__83223","com.wsscode.pathom3.connect.planner/add-snapshot!","p__83225","map__83226","com.wsscode.pathom3.connect.planner/create-root-or","map__83227","or-node-id","or-node","G__83228","G__83229","G__83230","com.wsscode.pathom3.connect.planner/node-attribute-provides","attr","G__83233","p1__83231#","cljs.core.mapv","com.wsscode.pathom3.connect.planner/transfer-node-parent","source-node-id","com.wsscode.pathom3.connect.planner/transfer-node-parents","parents","G__83234","com.wsscode.pathom3.connect.planner/combine-expects","na","nb","com.wsscode.pathom3.format.shape-descriptor/merge-shapes","com.wsscode.pathom3.connect.planner/combine-foreign-ast","com.wsscode.pathom3.format.eql/merge-ast-children","com.wsscode.pathom3.connect.planner/transfer-node-indexes","attrs","cljs.core/keys","com.wsscode.pathom3.connect.planner/combine-run-next","pivot","run-next-nodes","cljs.core.comp","p1__83235#","cljs.core.map","cljs.core.filter","map__83236","p__83237","map__83238","com.wsscode.pathom3.connect.planner/simplify-branch-node","G__83242","G__83243","G__83244","G__83239","G__83240","G__83241","com.wsscode.pathom3.connect.planner/merge-sibling-resolver-node","source-node","com.wsscode.misc.coll/merge-defaults","com.wsscode.pathom3.connect.planner/merge-sibling-resolver-nodes*","com.wsscode.pathom3.connect.planner/merge-sibling-resolver-nodes","parent-node-id","vec__83245","seq__83246","first__83247","node-ids'","resolver","G__83248","G__83249","G__83250","G__83251","G__83252","G__83253","p__83255","map__83256","snapshots*","snapshot-depth","event-details","pad","clojure.string.join","cljs.core.repeat","event-details'","p1__83254#","com.wsscode.misc.coll.update_if","cljs.core/conj","com.wsscode.pathom3.connect.planner/base-graph","com.wsscode.pathom3.connect.planner/base-env","cljs.core.atom","com.wsscode.pathom3.connect.planner/reset-env","G__83257","cljs.core/meta","cljs.core/with-meta","com.wsscode.pathom3.connect.planner/add-unreachable-path","path","cljs.core.pr_str","com.wsscode.pathom3.connect.planner/add-warning","warn","com.wsscode.misc.coll/vconj","G__83259","com.wsscode.pathom3.connect.planner/merge-unreachable","p__83260","map__83261","target-graph","unreachable-paths","G__83262","com.wsscode.pathom3.connect.planner.merge_unreachable","p__83263","map__83264","com.wsscode.pathom3.connect.planner/graph-provides","index-attrs","cljs.core/set","com.wsscode.pathom3.connect.planner/entry-ast","p__83265","map__83266","com.wsscode.pathom3.connect.planner/mark-attribute-process-sub-query","key","children","query","p__83267","map__83268","com.wsscode.pathom3.connect.planner/add-ident-process","com.wsscode.pathom3.connect.planner/add-placeholder-entry","p__83269","map__83270","com.wsscode.pathom3.connect.planner/find-direct-node-successors","G__83271","com.wsscode.pathom3.connect.planner/node-ancestors","node-queue","com.wsscode.misc.coll.queue","ancestors","node-id'","cljs.core/peek","map__83273","cljs.core/pop","com.wsscode.pathom3.connect.planner/node-successors","successors","cljs.core/LazySeq","cljs.core/cons","cljs.core/concat","p1__83274#","p__83275","map__83276","com.wsscode.pathom3.connect.planner/find-run-next-descendants","G__83278","map__83279","map__83281","descendants","next","com.wsscode.pathom3.connect.planner/find-leaf-node","com.fulcrologic.guardrails.core/=>","com.wsscode.pathom3.connect.planner/extend-attribute-sub-query","shape","com.wsscode.pathom3.format.shape-descriptor/shape-descriptor->ast","com.wsscode.pathom3.connect.planner/shape-reachable?","available","missing","com.wsscode.pathom3.format.shape_descriptor.missing","G__83283","com.wsscode.pathom3.connect.planner/compute-run-graph","p__83284","vec__83285","sub","nodes-subs","p1__83282#","cljs.core/some","com.wsscode.pathom3.connect.planner/compute-attribute-nested-input-require","nodes","checked-nodes","G__83288","p__83289","map__83290","valid-path?","p__83292","map__83293","com.wsscode.pathom3.connect.planner/compute-attribute-dependency-graph","recursive-joins","graph'","G__83294","G__83295","com.wsscode.pathom3.connect.planner/compute-attribute-graph","p1__83291#","recur","cljs.core/assoc","p__83296","map__83297","com.wsscode.pathom3.connect.planner/extend-available-attribute-nested","available-data","com.wsscode.pathom3.connect.planner/runner-node-sym","resolver-name","p__83298","map__83299","com.wsscode.pathom3.connect.planner/compute-dynamic-resolver-nested-requirements-keep","ast","G__83300","node-inputs","p__83301","map__83302","i","input","com.wsscode.pathom3.format.shape_descriptor.merge_shapes","cljs.core/vals","ast-shape","com.wsscode.pathom3.format.shape-descriptor/ast->shape-descriptor","com.wsscode.pathom3.format.shape-descriptor/intersection","p__83303","map__83304","com.wsscode.pathom3.connect.planner/create-node-for-resolver-call","ast-params","op-name'","dynamic?","com.wsscode.pathom3.connect.indexes/dynamic-resolver?","requires","G__83305","ast'","edn-query-language.core/ast->query","p__83309","map__83310","com.wsscode.pathom3.connect.planner/compute-resolver-leaf","resolvers","resolver-nodes","p1__83306#","p1__83307#","p2__83308#","p__83312","map__83313","com.wsscode.pathom3.connect.planner/resolvers-missing-optionals","cljs.core.transduce","p1__83311#","com.wsscode.pathom3.connect.indexes/resolver-optionals","p__83314","map__83315","com.wsscode.pathom3.connect.planner/compute-missing-chain-deps","cljs.core/reduce-kv","p__83316","vec__83317","node-map","vec__83320","extended?","cljs.core/reduced","p__83323","map__83324","com.wsscode.pathom3.connect.planner/compute-missing-chain-optional-deps","opt-missing","p__83325","vec__83326","vec__83329","G__83332","com.wsscode.pathom3.connect.planner/index-recursive-joins","p1__83333#","cljs.core.mapcat","cljs.core.keep","x","com.wsscode.pathom3.format.eql/recursive-query?","com.wsscode.pathom3.connect.planner/compute-missing-chain","missing-optionals","vec__83334","vec__83337","graph''","node-map-opts","all-nodes","G__83340","cljs.core/empty?","p__83342","map__83343","com.wsscode.pathom3.connect.planner/compute-input-resolvers-graph","map__83344","missing-opts","leaf-root","graph-with-deps","p1__83341#","tail-node-id","p__83345","map__83346","com.wsscode.pathom3.connect.planner/compute-attribute-graph*","index-oir","vec__83347","unreachable-graphs","p__83350","vec__83351","p__83354","p__83355","map__83356","map__83357","map__83358","attr-deps-trail","p__83359","map__83360","map__83361","com.wsscode.pathom3.connect.planner/compute-non-index-attribute","edn-query-language.core/ident?","com.wsscode.pathom3.placeholder/placeholder-key?","G__83362","G__83363","com.wsscode.pathom3.connect.planner/compute-run-graph*","vec__83364","p__83367","vec__83368","map__83371","G__83372","map__83373","com.wsscode.misc.refs/kw-identical?","G__83375","p__83376","map__83377","com.wsscode.pathom3.connect.planner.compute_run_graph","optimize-graph?","com.wsscode.pathom3.cache/cached","cljs.core/hash","env'","cljs.core.vary_meta","G__83378","com.wsscode.pathom3.format.eql/index-ast","com.wsscode.pathom3.connect.planner/optimize-graph","com.wsscode.pathom3.connect.planner/can-merge-sibling-resolver-nodes?","node-id1","node-id2","n1","n2","com.wsscode.pathom3.connect.planner/optimize-AND-resolver-siblings","parent-id","other-nodes","matching-nodes","p1__83379#","merge-nodes","cljs.core.sort","G__83380","G__83381","G__83382","G__83383","com.wsscode.pathom3.connect.planner/optimize-node","com.wsscode.pathom3.connect.planner/optimize-AND-resolvers-pass","sibling-ids","G__83387","vec__83388","seq__83389","first__83390","vec__83391","seq__83392","first__83393","vec__83394","com.wsscode.pathom3.connect.planner/optimize-AND-ORs","_env","_parent-id","or-nodes","p1__83397#","G__83401","vec__83402","seq__83403","first__83404","vec__83405","seq__83406","first__83407","com.wsscode.pathom3.connect.planner/optimize-AND-branches","map__83408","run-and","com.wsscode.pathom3.connect.planner/optimize-OR-branches","map__83409","run-or","G__83410","cljs.core/Keyword","G__83412","com.wsscode.pathom3.connect.planner/with-plan-cache","com.wsscode.pathom3.connect.planner.with_plan_cache","cache*","com.wsscode.pathom3.connect.planner/compute-plan-snapshots","e83413","e","cljs.core/ex-message","cljs.core/deref","cljs.core/List"],"sourcesContent":["(ns com.wsscode.pathom3.connect.planner\n  (:require\n    [clojure.spec.alpha :as s]\n    [clojure.string :as str]\n    [com.fulcrologic.guardrails.core :refer [>def >defn >fdef => | <- ?]]\n    [com.wsscode.misc.coll :as coll]\n    [com.wsscode.misc.refs :as refs]\n    [com.wsscode.pathom3.attribute :as p.attr]\n    [com.wsscode.pathom3.cache :as p.cache]\n    [com.wsscode.pathom3.connect.indexes :as pci]\n    [com.wsscode.pathom3.connect.operation :as pco]\n    [com.wsscode.pathom3.format.eql :as pf.eql]\n    [com.wsscode.pathom3.format.shape-descriptor :as pfsd]\n    [com.wsscode.pathom3.placeholder :as pph]\n    [edn-query-language.core :as eql])\n  #?(:cljs\n     (:require-macros\n       [com.wsscode.pathom3.connect.planner])))\n\n; region specs\n\n(>def ::node-id\n  \"ID for a execution node in the planner graph.\"\n  pos-int?)\n\n(>def ::node-id-set\n  \"A set of node ids.\"\n  (s/coll-of ::node-id :kind set?))\n\n(>def ::graph\n  \"The graph container, requires nodes.\"\n  (s/keys :req [::nodes]))\n\n(>def ::available-data\n  \"An shape descriptor declaring which data is already available when the planner starts.\"\n  ::pfsd/shape-descriptor)\n\n(>def ::node-parents\n  \"A set of node-ids containing the direct parents of the current node.\n  In regular execution nodes, this is the reverse of ::run-next, but in case of\n  immediate children of branch nodes, this points to the branch node.\"\n  ::node-id-set)\n\n(>def ::attr-deps-trail\n  \"A set containing attributes already in consideration when computing missing dependencies.\"\n  ::p.attr/attributes-set)\n\n(>def ::branch-type\n  \"The branch type for a branch node, can be AND or OR\"\n  #{::run-or ::run-and})\n\n(>def ::id-counter\n  \"An atom with a number, used to get the next node-id when creating new nodes.\"\n  any?)\n\n(>def ::foreign-ast\n  \"In dynamic resolver nodes, this contains the AST to be sent into the remote\"\n  :edn-query-language.ast/node)\n\n(>def ::node-type\n  \"Type of the nde, can be resolver, AND, OR or unknown.\"\n  #{::node-resolver ::node-and ::node-or ::node-unknown})\n\n(>def ::input\n  \"An IO-MAP description of required inputs to run the node.\"\n  ::pfsd/shape-descriptor)\n\n(>def ::index-attrs\n  \"A index pointing from attribute to the node that provides its value.\"\n  (s/map-of ::p.attr/attribute ::node-id-set))\n\n(>def ::index-resolver->nodes\n  \"An index from resolver symbol to a set of execution nodes where its used.\"\n  (s/map-of ::pco/op-name ::node-id-set))\n\n(>def ::node-depth\n  \"The node depth on the graph, starts on zero.\"\n  nat-int?)\n\n(>def ::node-branch-depth\n  \"How far the branch depth goes from the current node.\"\n  nat-int?)\n\n(>def ::node-chain-depth\n  \"The chain depth relative to the current node.\"\n  nat-int?)\n\n(defn ignore-nils [m]\n  (into {} (remove (fn [[_ v]] (nil? v))) m))\n\n(>def ::node\n  \"Node.\"\n  (s/and (s/conformer ignore-nils) (s/keys :opt [::node-id ::run-next ::node-parents ::expects ::input])))\n\n(>def ::nodes\n  \"The nodes index.\"\n  (s/map-of ::node-id ::node))\n\n(>def ::params\n  \"Params to be used when executing the resolver node\"\n  map?)\n\n(>def ::expects\n  \"An data shape description of what is expected from this execution node to return.\"\n  ::pfsd/shape-descriptor)\n\n(>def ::root\n  \"A node-id that defines the root in the planner graph.\"\n  ::node-id)\n\n(>def ::run-and\n  \"Vector containing nodes ids to run in a AND branch.\"\n  ::node-id-set)\n\n(>def ::run-or\n  \"Vector containing nodes ids to run in a AND branch.\"\n  ::node-id-set)\n\n(>def ::run-next\n  \"A node-id that points to the next node to run.\"\n  ::node-id)\n\n(>def ::source-for-attrs\n  \"Set of attributes that are provided by this node.\"\n  ::p.attr/attributes-set)\n\n(>def ::source-sym\n  \"On dynamic resolvers, this points to the original source resolver in the foreign environment.\"\n  ::pco/op-name)\n\n(>def ::unreachable-paths\n  \"A shape containing the attributes that can't be reached considering current graph and available data.\"\n  ::pfsd/shape-descriptor)\n\n(>def ::warn\n  \"Warn message\"\n  string?)\n\n(>def ::warnings\n  \"List of warnings generated during the plan process.\"\n  (s/coll-of (s/keys :req [::warn])))\n\n(>def ::conflict-params\n  \"Set of params that were conflicting during merge.\"\n  ::p.attr/attributes-set)\n\n(>def ::index-ast\n  \"Index to find the AST for a given property.\"\n  ::pf.eql/prop->ast)\n\n(>def ::mutations\n  \"A vector with the operation name of every mutation that appears in the query.\"\n  (s/coll-of ::pco/op-name :kind vector?))\n\n(>def ::nested-process\n  \"Which attributes need further processing due to sub-query requirements.\"\n  ::p.attr/attributes-set)\n\n(>def ::placeholders\n  \"Placeholder items to nest in.\"\n  ::p.attr/attributes-set)\n\n(>def ::idents\n  \"Idents collected while scanning query\"\n  (s/coll-of ::eql/ident :kind set?))\n\n(>def ::optimize-graph? boolean?)\n\n(>def ::plan-cache*\n  \"Atom containing the cache atom to support cached planning.\"\n  refs/atom?)\n\n(>def ::snapshots*\n  \"Atom to store each step of the planning process\"\n  refs/atom?)\n\n; endregion\n\n(declare add-snapshot! compute-run-graph compute-run-graph* compute-attribute-graph\n         optimize-graph optimize-node)\n\n; region node helpers\n\n(defn next-node-id\n  \"Return the next node ID in the system, its an incremental number\"\n  [{::keys [id-counter]}]\n  (swap! id-counter inc))\n\n(defn new-node [env node-data]\n  (assoc node-data ::node-id (next-node-id env)))\n\n(>defn get-node\n  ([graph node-id]\n   [(s/keys :req [::nodes]) (? ::node-id)\n    => (? ::node)]\n   (get-in graph [::nodes node-id]))\n\n  ([graph node-id k]\n   [(s/keys :req [::nodes]) (? ::node-id) keyword?\n    => any?]\n   (get-in graph [::nodes node-id k])))\n\n(defn node-with-resolver-config\n  \"Get the node plus the resolver config, when the node has an op-name. If node is\n  not a resolver not it returns nil.\"\n  [graph env node-id]\n  (let [node (get-node graph node-id)]\n    (if-let [config (some->> node ::pco/op-name (pci/resolver-config env))]\n      (merge node config))))\n\n(defn assoc-node\n  \"Set attribute k about node-id. Only assoc when node exists, otherwise its a noop.\"\n  [graph node-id k v]\n  (if (get-node graph node-id)\n    (assoc-in graph [::nodes node-id k] v)\n    graph))\n\n(defn update-node\n  \"Update a given node in a graph, like Clojure native update.\"\n  ([graph node-id k f]\n   (if (get-node graph node-id)\n     (update-in graph (cond-> [::nodes node-id] k (conj k)) f)\n     graph))\n  ([graph node-id k f v]\n   (if (get-node graph node-id)\n     (update-in graph (cond-> [::nodes node-id] k (conj k)) f v)\n     graph))\n  ([graph node-id k f v v2]\n   (if (get-node graph node-id)\n     (update-in graph (cond-> [::nodes node-id] k (conj k)) f v v2)\n     graph))\n  ([graph node-id k f v v2 v3]\n   (if (get-node graph node-id)\n     (update-in graph (cond-> [::nodes node-id] k (conj k)) f v v2 v3)\n     graph))\n  ([graph node-id k f v v2 v3 & args]\n   (if (get-node graph node-id)\n     (apply update-in graph (cond-> [::nodes node-id] k (conj k)) f v v2 v3 args)\n     graph)))\n\n(defn get-root-node\n  \"Returns the root node of the graph.\"\n  [{::keys [root] :as graph}]\n  (get-node graph root))\n\n(>defn set-root-node\n  [graph node-id]\n  [(s/keys :req [::nodes]) (? ::node-id)\n   => (s/keys :req [::nodes])]\n  (if node-id\n    (assoc graph ::root node-id)\n    (dissoc graph ::root)))\n\n(>defn node-branches\n  \"Return node branches, which can be the ::run-and or the ::run-or part of the node.\"\n  [node]\n  [(? ::node)\n   => (? (s/or :and ::run-and :or ::run-or))]\n  (or (::run-and node)\n      (::run-or node)))\n\n(>defn branch-node?\n  \"Returns true when the node is a branch node type.\"\n  [node]\n  [(? ::node) => boolean?]\n  (boolean (node-branches node)))\n\n(>defn node-kind\n  \"Return a keyword describing the type of the node.\"\n  [node]\n  [(? ::node) => ::node-type]\n  (cond\n    (::pco/op-name node)\n    ::node-resolver\n\n    (::run-and node)\n    ::node-and\n\n    (::run-or node)\n    ::node-or\n\n    :else\n    ::node-unknown))\n\n(defn node->label\n  \"Return a string representation for the node, for resolver nodes this is the\n  symbol, branch nodes get AND / OR respectively.\"\n  [node]\n  (str\n    (or\n      (::pco/op-name node)\n      (if (::run-and node) \"AND\")\n      (if (::run-or node) \"OR\"))))\n\n(defn add-node-parent [graph node-id node-parent-id]\n  (assert node-parent-id \"Tried to add after node with nil value\")\n  (update-node graph node-id ::node-parents coll/sconj node-parent-id))\n\n(defn remove-node-parent [graph node-id node-parent-id]\n  (let [node          (get-node graph node-id)\n        node-parents' (disj (::node-parents node #{}) node-parent-id)]\n    (if (seq node-parents')\n      (assoc-node graph node-id ::node-parents node-parents')\n      (if node\n        (update-in graph [::nodes node-id] dissoc ::node-parents)\n        graph))))\n\n(defn set-node-run-next*\n  \"Update the node-id run-next value, if run-next is nil the attribute\n  will be removed from the map.\"\n  [graph node-id run-next]\n  (if run-next\n    (assoc-node graph node-id ::run-next run-next)\n    (update-in graph [::nodes node-id] dissoc ::run-next)))\n\n(defn set-node-run-next\n  \"Set the node run next value and add the node-parent counter part. Noop if target\n  and run next are the same node.\"\n  ([graph run-next] (set-node-run-next graph (::root graph) run-next))\n  ([graph target-node-id run-next]\n   (let [{target-run-next ::run-next} (get-node graph target-node-id)\n         graph (if target-run-next\n                 (remove-node-parent graph target-run-next target-node-id)\n                 graph)]\n     (cond\n       (not run-next)\n       (set-node-run-next* graph target-node-id run-next)\n\n       (and run-next (not= target-node-id run-next))\n       (-> graph\n           (set-node-run-next* target-node-id run-next)\n           (add-node-parent run-next target-node-id))\n\n       :else\n       graph))))\n\n(defn set-node-source-for-attrs\n  ([graph env] (set-node-source-for-attrs graph env (::root graph)))\n  ([graph {::p.attr/keys [attribute]} node-id]\n   (if node-id\n     (-> graph\n         (update-in [::index-attrs attribute] coll/sconj node-id))\n     graph)))\n\n(defn add-branch-to-node\n  [graph target-node-id branch-type new-branch-node-id]\n  (-> graph\n      (add-node-parent new-branch-node-id target-node-id)\n      (update-node target-node-id branch-type coll/sconj new-branch-node-id)))\n\n(defn add-node-branches [graph target-node-id branch-type node-ids]\n  (reduce\n    (fn [g node-id]\n      (add-branch-to-node g target-node-id branch-type node-id))\n    graph\n    node-ids))\n\n(defn remove-branch-node-parents\n  \"When node-id is a branch node, remove all node-parents associated from its children.\"\n  [graph node-id]\n  (let [node (get-node graph node-id)]\n    (if-let [branches (node-branches node)]\n      (reduce\n        (fn [g n-id]\n          (remove-node-parent g n-id node-id))\n        graph\n        branches)\n      graph)))\n\n(defn remove-from-parent-branches\n  \"Disconnect a branch node from its parents.\"\n  [graph {::keys [node-id node-parents]}]\n  (reduce\n    (fn [g nid]\n      (let [n (get-node graph nid)]\n        (cond\n          (contains? (::run-and n) node-id)\n          (update-node graph nid ::run-and disj node-id)\n\n          (contains? (::run-or n) node-id)\n          (update-node graph nid ::run-or disj node-id)\n\n          :else\n          g)))\n    graph\n    node-parents))\n\n(defn remove-node-edges\n  \"Remove all node connections. This disconnect the nodes from parents and run-next.\"\n  [graph node-id]\n  ;; TODO disconnect run-next\n  (remove-from-parent-branches graph node-id))\n\n(defn remove-node*\n  \"Remove a node from the graph. Doesn't remove any references, caution!\"\n  [graph node-id]\n  (let [node (get-node graph node-id)]\n    (-> graph\n        (cond->\n          (::pco/op-name node)\n          (update-in [::index-resolver->nodes (::pco/op-name node)] disj node-id))\n        (update ::nodes dissoc node-id))))\n\n(defn remove-node\n  \"Remove a node from the graph. In case of resolver nodes it also removes them\n  from the ::index-syms and after node references.\"\n  [graph node-id]\n  (let [{::keys [run-next node-parents] :as node} (get-node graph node-id)]\n    (assert (if node-parents\n              (every? #(not= node-id (get-node graph % ::run-next))\n                node-parents)\n              true)\n      (str \"Tried to remove node \" node-id \" that still contains references pointing to it. Move\n      the run-next references from the pointer nodes before removing it. Also check if\n      parent is branch and trying to merge.\"))\n    (-> graph\n        (remove-branch-node-parents node-id)\n        (remove-node-parent run-next node-id)\n        (remove-from-parent-branches node)\n        (remove-node* node-id))))\n\n(defn remove-root-node-cluster\n  \"Remove a complete node cluster, starting from some node root.\"\n  [graph node-ids]\n  (if (seq node-ids)\n    (let [[node-id & rest] node-ids\n          {::keys [run-next] :as node} (get-node graph node-id)\n          branches   (or (node-branches node) #{})\n          next-nodes (cond-> branches run-next (conj run-next))]\n      (recur (remove-node* graph node-id)\n        (into rest next-nodes)))\n    graph))\n\n(defn include-node\n  \"Add new node to the graph, this add the node and the index of in ::index-syms.\"\n  [graph {::keys [node-id] ::pco/keys [op-name] :as node}]\n  (-> graph\n      (assoc-in [::nodes node-id] node)\n      (cond->\n        op-name\n        (update-in [::index-resolver->nodes op-name] coll/sconj node-id))))\n\n(defn create-and [graph env node-ids]\n  (if (= 1 (count node-ids))\n    (get-node graph (first node-ids))\n    (let [{and-node-id ::node-id\n           :as         and-node} (new-node env {})]\n      (-> graph\n          (include-node and-node)\n          (add-node-branches and-node-id ::run-and node-ids)))))\n\n(defn create-root-and [graph env node-ids]\n  (if (= 1 (count node-ids))\n    (set-root-node graph (first node-ids))\n    (let [{and-node-id ::node-id\n           :as         and-node} (new-node env {})]\n      (-> graph\n          (include-node and-node)\n          (add-node-branches and-node-id ::run-and node-ids)\n          (set-root-node and-node-id)\n          (as-> <>\n            (add-snapshot! <> env\n                           {::snapshot-event   ::snapshot-create-and\n                            ::snapshot-message \"Create root AND\"\n                            ::highlight-nodes  (into #{(::root <>)} node-ids)\n                            ::highlight-styles {(::root <>) 1}}))))))\n\n(defn create-root-or\n  [graph {::p.attr/keys [attribute] :as env} node-ids]\n  (if (= 1 (count node-ids))\n    (set-root-node graph (first node-ids))\n    (let [{or-node-id ::node-id\n           :as        or-node} (new-node env {::expects {attribute {}}})]\n      (-> graph\n          (include-node or-node)\n          (add-node-branches or-node-id ::run-or node-ids)\n          (set-root-node or-node-id)\n          (as-> <>\n            (add-snapshot! <> env\n                           {::snapshot-event   ::snapshot-create-or\n                            ::snapshot-message \"Create root OR\"\n                            ::highlight-nodes  (into #{(::root <>)} node-ids)\n                            ::highlight-styles {(::root <>) 1}}))))))\n\n(defn node-attribute-provides\n  \"For a specific attribute, return a vector containing the provides of each node of\n  that resolver.\"\n  [graph env attr]\n  (some->>\n    (get-in graph [::index-attrs attr])\n    (mapv\n      #(-> (node-with-resolver-config graph env %)\n           ::pco/provides\n           (get attr)))))\n\n(defn transfer-node-parent\n  \"Transfer the node parent from source node to target node. This function will also\n  update the parents references to point to target node.\"\n  [graph target-node-id source-node-id node-id]\n  (-> graph\n      (remove-node-parent source-node-id node-id)\n      (add-node-parent target-node-id node-id)\n      (as-> <>\n        (cond\n          (= (get-node graph node-id ::run-next) source-node-id)\n          (set-node-run-next* <> node-id target-node-id)\n\n          (contains? (get-node graph node-id ::run-and) source-node-id)\n          (-> <>\n              (add-branch-to-node node-id ::run-and target-node-id)\n              (update-node node-id ::run-and disj source-node-id))\n\n          (contains? (get-node graph node-id ::run-or) source-node-id)\n          (-> <>\n              (add-branch-to-node node-id ::run-or target-node-id)\n              (update-node node-id ::run-or disj source-node-id))\n\n          :else\n          <>))))\n\n(defn transfer-node-parents\n  \"Transfer node parents from source node to target node. In case source node is root,\n  the root will be transferred to target node.\"\n  [graph target-node-id source-node-id]\n  (let [parents (get-node graph source-node-id ::node-parents)]\n    (-> graph\n        ; transfer root\n        (cond->\n          (= (::root graph) source-node-id)\n          (set-root-node target-node-id))\n        (as-> <>\n          (reduce\n            (fn [g node-id]\n              (transfer-node-parent g target-node-id source-node-id node-id))\n            <>\n            parents)))))\n\n(defn combine-expects [na nb]\n  (update na ::expects pfsd/merge-shapes (::expects nb)))\n\n(defn combine-foreign-ast [na nb]\n  (if (::foreign-ast na)\n    (update na ::foreign-ast pf.eql/merge-ast-children (::foreign-ast nb))\n    na))\n\n(defn transfer-node-indexes [graph target-node-id source-node-id]\n  (let [attrs (keys (get-node graph source-node-id ::expects))]\n    (reduce\n      (fn [graph attr]\n        (-> graph\n            (update-in [::index-attrs attr] coll/sconj target-node-id)\n            (update-in [::index-attrs attr] disj source-node-id)))\n      graph\n      attrs)))\n\n(defn combine-run-next\n  [graph env node-ids pivot]\n  (let [run-next-nodes (into []\n                             (comp (map #(get-node graph %))\n                                   (filter ::run-next))\n                             node-ids)]\n    (cond\n      (= 1 (count run-next-nodes))\n      (let [{::keys [node-id run-next]} (first run-next-nodes)]\n        (-> graph\n            (remove-node-parent run-next node-id)\n            (set-node-run-next pivot run-next)))\n\n      (seq run-next-nodes)\n      (let [and-node (new-node env {::run-and #{}})]\n        (as-> graph <>\n          (include-node <> and-node)\n          (reduce\n            (fn [g {::keys [node-id run-next]}]\n              (-> g\n                  (add-branch-to-node (::node-id and-node) ::run-and run-next)\n                  (remove-node-parent run-next node-id)))\n            <>\n            run-next-nodes)\n          (set-node-run-next <> pivot (::node-id and-node))))\n\n      :else\n      graph)))\n\n(>defn simplify-branch-node\n  \"When a branch node contains a single branch out, remove the AND node and put that\n  single item in place.\n\n  Note in case the branch has a run-next, that run-next gets moved to the end of chain\n  to retain the same order as it would run with the branch.\"\n  [graph env node-id]\n  [::graph map? ::node-id => ::graph]\n  (let [node           (get-node graph node-id)\n        target-node-id (and (= 1 (count (::run-and node)))\n                            (not (::run-next node))\n                            (first (::run-and node)))]\n    (if target-node-id\n      (-> graph\n          (add-snapshot! env {::snapshot-message \"Simplifying branch with single element\"\n                              ::highlight-nodes  #{node-id target-node-id}\n                              ::highlight-styles {node-id 1}})\n          (transfer-node-parents target-node-id node-id)\n          (remove-node-edges node-id)\n          (remove-node node-id)\n          (add-snapshot! env {::snapshot-message \"Simplification done\"\n                              ::highlight-nodes  #{target-node-id}}))\n      graph)))\n\n(defn merge-sibling-resolver-node\n  \"Merges data from source-node-id into target-node-id, them removes the source node.\"\n  [graph target-node-id source-node-id]\n  (let [source-node (get-node graph source-node-id)]\n    (-> graph\n        ; merge any extra keys from source node, but without overriding anything\n        (update-node target-node-id nil coll/merge-defaults source-node)\n        (update-node target-node-id nil combine-expects source-node)\n        (update-node target-node-id nil combine-foreign-ast source-node)\n        (transfer-node-indexes target-node-id source-node-id)\n        (remove-node-edges source-node-id)\n        (remove-node source-node-id))))\n\n(defn merge-sibling-resolver-nodes*\n  [graph pivot node-ids]\n  (reduce\n    (fn [g node-id]\n      (merge-sibling-resolver-node g pivot node-id))\n    graph\n    node-ids))\n\n(defn merge-sibling-resolver-nodes\n  [graph env parent-node-id node-ids]\n  (let [[pivot & node-ids'] node-ids\n        resolver (::pco/op-name (get-node graph pivot))]\n    (add-snapshot! graph env {::snapshot-message (str \"Merging sibling resolver calls to resolver \" resolver)\n                              ::highlight-nodes  (into #{} (conj node-ids parent-node-id))\n                              ::highlight-styles {parent-node-id 1}})\n    (-> graph\n        (combine-run-next env node-ids pivot)\n        (merge-sibling-resolver-nodes* pivot node-ids')\n        (add-snapshot! env {::snapshot-message \"Merge complete\"\n                            ::highlight-nodes  #{parent-node-id pivot}\n                            ::highlight-styles {parent-node-id 1}}))))\n\n; endregion\n\n; region graph helpers\n\n(defn add-snapshot!\n  ([graph {::keys [snapshots* snapshot-depth]} event-details]\n   (if snapshots*\n     (let [pad            (str/join (repeat (or snapshot-depth 0) \"-\"))\n           pad            (if (seq pad) (str pad \" \") \"\")\n           event-details' (coll/update-if event-details ::snapshot-message #(str pad %))]\n       (swap! snapshots* conj (-> graph (dissoc ::source-ast ::available-data)\n                                  (merge event-details')))))\n   graph))\n\n(defn base-graph []\n  {::nodes {}})\n\n(defn base-env []\n  {::id-counter     (atom 0)\n   ::available-data {}})\n\n(defn reset-env\n  \"Restore the original environment sent to run-graph! Use this for nested graphs\n  that need a clean environment.\"\n  [env]\n  (or (some-> env meta ::original-env\n              (with-meta (meta env)))\n      env))\n\n(defn add-unreachable-path\n  \"Add attribute to unreachable list\"\n  [graph env path]\n  (-> (update graph ::unreachable-paths pfsd/merge-shapes path)\n      (add-snapshot! env {::snapshot-event   ::snapshot-mark-attr-unreachable\n                          ::snapshot-message (str \"Mark path \" (pr-str path) \" as unreachable.\")})))\n\n(defn add-warning [graph warn]\n  (update graph ::warnings coll/vconj warn))\n\n(defn merge-unreachable\n  \"Copy unreachable attributes from discard-graph to target-graph. Using the extra arity\n  you can also add a new unreachable path in the same call.\"\n  ([target-graph {::keys [unreachable-paths]}]\n   (cond-> target-graph\n     unreachable-paths\n     (update ::unreachable-paths pfsd/merge-shapes (or unreachable-paths {}))))\n  ([target-graph graph env path]\n   (-> (merge-unreachable target-graph graph)\n       (add-unreachable-path env path))))\n\n(>defn graph-provides\n  \"Get a set with all provided attributes from the graph.\"\n  [{::keys [index-attrs]}]\n  [(s/keys :req [::index-attrs])\n   => ::p.attr/attributes-set]\n  (-> index-attrs keys set))\n\n(>defn entry-ast\n  \"Find AST node a given entry from the source AST.\"\n  [graph k]\n  [(s/keys :req [::index-ast]) any?\n   => (? :edn-query-language.ast/node)]\n  (get-in graph [::index-ast k]))\n\n(defn mark-attribute-process-sub-query\n  \"Add information about attribute that is present but requires further processing\n  due to subquery, this is created so the runner can quickly know which attributes\n  need to have the subquery processing done.\"\n  [graph {:keys [key children query]}]\n  (if (or children query)\n    (update graph ::nested-process coll/sconj key)\n    graph))\n\n(defn add-ident-process [graph {:keys [key]}]\n  (update graph ::idents coll/sconj key))\n\n(defn add-placeholder-entry [graph attr]\n  (update graph ::placeholders coll/sconj attr))\n\n; endregion\n\n; region node traversal\n\n(>defn find-direct-node-successors\n  \"Direct successors of node, branch nodes and run-next, in case of branch nodes the\n  branches will always come before the run-next.\"\n  [{::keys [run-next] :as node}]\n  [::node => (s/coll-of ::node-id)]\n  (let [branches (node-branches node)]\n    (cond-> []\n      branches\n      (into branches)\n\n      run-next\n      (conj run-next))))\n\n(>defn node-ancestors\n  \"Return all node ancestors. The order of the output will go from closest to farthest\n  nodes, like breathing out of the current node.\"\n  [graph node-id]\n  [::graph ::node-id\n   => (s/coll-of ::node-id :kind vector?)]\n  (loop [node-queue (coll/queue [node-id])\n         ancestors  []]\n    (if-let [node-id' (peek node-queue)]\n      (let [{::keys [node-parents]} (get-node graph node-id')]\n        (recur\n          (into (pop node-queue) node-parents)\n          (conj ancestors node-id')))\n      ancestors)))\n\n(>defn node-successors\n  \"Find successor nodes of node-id, node-id is included in the list. This will add\n  branch nodes before run-next nodes. Returns a lazy sequence that traverse the graph\n  as items are requested.\"\n  [graph node-id]\n  [::graph ::node-id => (s/coll-of ::node-id)]\n  (let [successors (find-direct-node-successors (get-node graph node-id))]\n    (cond\n      (seq successors)\n      (lazy-seq (cons node-id (apply concat (map #(node-successors graph %) successors))))\n\n      :else\n      (lazy-seq [node-id]))))\n\n(>defn find-run-next-descendants\n  \"Return descendants by walking the run-next\"\n  [graph {::keys [node-id]}]\n  [::graph ::node => (s/coll-of ::node)]\n  (let [node (get-node graph node-id)]\n    (loop [descendants [node]\n           {::keys [run-next]} node]\n      (if-let [next (get-node graph run-next)]\n        (recur (conj descendants next) next)\n        descendants))))\n\n(defn find-leaf-node\n  \"Traverses all run-next still it reaches a leaf.\"\n  [graph node]\n  [::graph ::node => ::node]\n  (peek (find-run-next-descendants graph node)))\n\n; endregion\n\n; region sub-query process\n\n(defn extend-attribute-sub-query [graph attr shape]\n  (-> graph\n      (update-in [::index-ast attr] pf.eql/merge-ast-children\n        (-> (pfsd/shape-descriptor->ast shape)\n            (assoc :type :prop :key attr :dispatch-key attr)))))\n\n(>defn shape-reachable?\n  \"Given an environment, available data and shape, determines if the whole shape\n  is reachable (including nested dependencies).\"\n  [env available shape]\n  [map? ::pfsd/shape-descriptor ::pfsd/shape-descriptor => boolean?]\n  (let [missing (pfsd/missing available shape)]\n    (if (seq missing)\n      (let [graph (compute-run-graph\n                    (-> (reset-env env)\n                        (assoc\n                          ::available-data available\n                          :edn-query-language.ast/node (pfsd/shape-descriptor->ast missing))))]\n        (every?\n          (fn [[attr sub]]\n            (if-let [nodes-subs (node-attribute-provides graph env attr)]\n              (if (seq nodes-subs)\n                (some #(shape-reachable? env % sub) nodes-subs)\n                true)))\n          shape))\n      true)))\n\n(defn compute-attribute-nested-input-require [graph env attr shape nodes]\n  (add-snapshot! graph env {::snapshot-message (str \"Processing nested requirements \" (pr-str {attr shape}))})\n  ; TODO this should consider the case that a few of the nodes can provide the\n  ; sub-query, in this case only they should be kept in the graph, and the other\n  ; options must be removed\n  (let [checked-nodes (into []\n                            (map (fn [node]\n                                   (cond-> node\n                                     (shape-reachable? env (-> node ::pco/provides (get attr)) shape)\n                                     (assoc :valid-path? true))))\n                            nodes)]\n    (if (some :valid-path? checked-nodes)\n      (-> (reduce\n            (fn [g {:keys [valid-path?] ::keys [node-id]}]\n              (if-not valid-path?\n                (assoc-node g node-id ::invalid-node? true)\n                g))\n            graph\n            checked-nodes)\n          (extend-attribute-sub-query attr shape))\n      (-> graph\n          (dissoc ::root)\n          (add-unreachable-path env {attr shape})))))\n\n(defn compute-attribute-dependency-graph\n  [graph {::keys [recursive-joins] :as env} attr shape]\n  (add-snapshot! graph env {::snapshot-message (str \"Processing dependency \" {attr shape})})\n  (let [graph' (-> graph\n                   (dissoc ::root)\n                   (compute-attribute-graph\n                     (-> env\n                         (dissoc ::p.attr/attribute)\n                         (update ::attr-deps-trail coll/sconj (::p.attr/attribute env))\n                         (assoc\n                           :edn-query-language.ast/node\n                           {:type         :prop\n                            :key          attr\n                            :dispatch-key attr}))))]\n    (if (::root graph')\n      (let [nodes\n            (->> (get-in graph' [::index-attrs attr])\n                 (mapv #(node-with-resolver-config graph' env %)))\n\n            recur\n            (get recursive-joins attr)]\n        (cond\n          ; recursive query\n          recur\n          (-> graph'\n              (add-snapshot! env {::snapshot-message (str \"Detected recursive nested dependency on \" attr)})\n              (update-in [::index-ast attr] assoc\n                :type :join\n                :key attr\n                :dispatch-key attr\n                :query recur))\n\n          ; nested input requirement\n          (seq shape)\n          (compute-attribute-nested-input-require graph' env attr shape nodes)\n\n          :else\n          graph'))\n      graph')))\n\n(defn extend-available-attribute-nested\n  [graph {::keys [available-data] :as env} attr shape]\n  (if (shape-reachable? env (get available-data attr) shape)\n    [(-> (extend-attribute-sub-query graph attr shape)\n         (mark-attribute-process-sub-query {:key attr :children []}))\n     true]\n    ; TODO maybe the sub-query fails partially, in this case making the whole\n    ; sub-query unreachable will lead to bad results\n    [(add-unreachable-path graph env {attr shape})\n     false]))\n\n; endregion\n\n; region path expansion\n\n(defn runner-node-sym\n  \"Find the runner symbol for a resolver, on normal resolvers that is the resolver symbol,\n  but for foreign resolvers it uses its ::p.c.o/dynamic-name.\"\n  [env resolver-name]\n  (let [resolver (pci/resolver-config env resolver-name)]\n    (or (::pco/dynamic-name resolver)\n        resolver-name)))\n\n(defn compute-dynamic-resolver-nested-requirements-keep\n  [{::p.attr/keys [attribute]\n    ::pco/keys    [op-name]\n    ast           :edn-query-language.ast/node\n    :as           env}]\n  (if (seq (:children ast))\n    (let [config      (pci/resolver-config env op-name)\n          available   (get-in config [::pco/provides attribute])\n          graph       (compute-run-graph (-> (reset-env env)\n                                             (assoc\n                                               :edn-query-language.ast/node ast\n                                               ::available-data available)))\n          node-inputs (reduce\n                        (fn [i {::keys [input]}]\n                          (pfsd/merge-shapes i input))\n                        {}\n                        (vals (::nodes graph)))\n          ast-shape   (pfsd/ast->shape-descriptor ast)]\n      (pfsd/intersection available (pfsd/merge-shapes node-inputs ast-shape)))))\n\n(defn create-node-for-resolver-call\n  \"Create a new node representative to run a given resolver.\"\n  [{::keys        [input]\n    ::p.attr/keys [attribute]\n    ::pco/keys    [op-name]\n    ast           :edn-query-language.ast/node\n    :as           env}]\n  (let [ast-params (:params ast)\n        config     (pci/resolver-config env op-name)\n        op-name'   (or (::pco/dynamic-name config) op-name)\n        dynamic?   (pci/dynamic-resolver? env op-name')\n        sub        (if dynamic? (compute-dynamic-resolver-nested-requirements-keep env))\n        requires   {attribute (or sub {})}]\n    (cond->\n      (new-node env\n                {::pco/op-name op-name'\n                 ::expects     requires\n                 ::input       input})\n\n      (seq ast-params)\n      (assoc ::params ast-params)\n\n      dynamic?\n      (assoc ::foreign-ast\n        {:type     :root\n         :children (if sub\n                     (let [ast' (pfsd/shape-descriptor->ast sub)]\n                       [(assoc ast\n                          :children (:children ast')\n                          :query (eql/ast->query ast'))])\n                     [ast])}))))\n\n(defn compute-resolver-leaf\n  \"For a set of resolvers (the R part of OIR index), create one OR node that branches\n  to each option in the set.\"\n  [graph {::keys [input] :as env} resolvers]\n  (let [resolver-nodes (into\n                         (list)\n                         (map #(create-node-for-resolver-call (assoc env ::pco/op-name %)))\n                         resolvers)]\n    (if (seq resolver-nodes)\n      (-> (reduce #(-> %\n                       (include-node %2)\n                       (set-node-source-for-attrs env (::node-id %2))) graph resolver-nodes)\n          (create-root-or env (mapv ::node-id resolver-nodes))\n          (as-> <>\n            (add-snapshot! <> env {::snapshot-message (str \"Add nodes for input path \" (pr-str input))\n                                   ::highlight-nodes  (into #{(::root <>)} (map ::node-id) resolver-nodes)\n                                   ::highlight-styles {(::root <>) 1}})))\n      (add-snapshot! graph env {::snapshot-message \"No reachable resolver found.\"}))))\n\n(defn resolvers-missing-optionals\n  \"Merge the optionals from a collection of resolver symbols.\"\n  [{::keys [available-data] :as env} resolvers]\n  (->> (transduce\n         (map #(pci/resolver-optionals env %))\n         pfsd/merge-shapes\n         {}\n         resolvers)\n       (pfsd/missing available-data)))\n\n(defn compute-missing-chain-deps\n  [graph {::keys [available-data] :as env} missing]\n  (reduce-kv\n    (fn [[graph node-map] attr shape]\n      (if (contains? available-data attr)\n        (let [[graph' extended?] (extend-available-attribute-nested graph env attr shape)]\n          (if extended?\n            [graph' node-map]\n            (reduced [graph' nil])))\n\n        (let [graph' (compute-attribute-dependency-graph graph env attr shape)]\n          (if-let [root (::root graph')]\n            [graph'\n             (assoc node-map attr root)]\n            (reduced [(merge-unreachable graph graph') nil])))))\n    [graph {}]\n    missing))\n\n(defn compute-missing-chain-optional-deps\n  [graph {::keys [available-data] :as env} opt-missing node-map]\n  (reduce-kv\n    (fn [[graph node-map] attr shape]\n      (if (contains? available-data attr)\n        (let [[graph'] (extend-available-attribute-nested graph env attr shape)]\n          [graph' node-map])\n\n        (let [graph' (compute-attribute-dependency-graph graph env attr shape)]\n          (if-let [root (::root graph')]\n            [(cond-> graph'\n               (contains? node-map attr)\n               (-> (remove-root-node-cluster [(get node-map attr)])\n                   (add-snapshot! env {::snapshot-message \"Optional computation overrode the required.\"})))\n             (assoc node-map attr root)]\n            [(merge-unreachable graph graph') node-map]))))\n    [graph node-map]\n    opt-missing))\n\n(defn- index-recursive-joins\n  [env resolvers]\n  (into {}\n        (comp (map #(pci/resolver-config env %))\n              (mapcat ::pco/input)\n              (keep (fn [x] (if (and (map? x) (pf.eql/recursive-query? (first (vals x))))\n                              (first x)))))\n        resolvers))\n\n(defn compute-missing-chain\n  \"Start a recursive call to process the dependencies required by the resolver.\"\n  [graph env missing missing-optionals]\n  (let [_ (add-snapshot! graph env {::snapshot-message (str \"Computing \" (::p.attr/attribute env) \" dependencies: \" (pr-str missing))})\n        [graph' node-map] (compute-missing-chain-deps graph env missing)]\n    (if (some? node-map)\n      ;; add new nodes (and maybe nested processes)\n      (let [[graph'' node-map-opts] (compute-missing-chain-optional-deps graph' env missing-optionals node-map)\n            all-nodes (vals (merge node-map node-map-opts))]\n        (-> graph''\n            (cond->\n              (seq all-nodes)\n              (create-root-and env (vals (merge node-map node-map-opts)))\n\n              (empty? all-nodes)\n              (set-root-node (::root graph)))\n            (as-> <>\n              (add-snapshot! <> env {::snapshot-event   ::compute-missing-success\n                                     ::snapshot-message (str \"Complete computing deps \" (pr-str missing))\n                                     ::highlight-nodes  (into #{(::root <>)} (vals node-map))\n                                     ::highlight-styles {(::root <>) 1}}))))\n\n      ;; failed\n      (-> graph\n          (dissoc ::root)\n          (merge-unreachable graph')\n          (add-snapshot! env {::snapshot-event   ::compute-missing-failed\n                              ::snapshot-message (str \"Failed to compute dependencies \" (pr-str missing))})))))\n\n(defn compute-input-resolvers-graph\n  \"This function computes the graph for a given `process path`. It creates the resolver\n  nodes to execute the resolvers, in case of many resolvers it uses a OR node to combine\n  them.\n\n  Them it fetches the dependencies, declared in the process path. If the dependencies\n  are successfully computed, it returns the graph with the root on the node that\n  fulfills the request.\"\n  [graph\n   {::keys        [available-data]\n    ::p.attr/keys [attribute]\n    :as           env}\n   input resolvers]\n  (if (contains? input attribute)\n    ; attribute requires itself, just stop\n    graph\n\n    (let [missing      (pfsd/missing available-data input)\n          missing-opts (resolvers-missing-optionals env resolvers)\n          env          (assoc env ::input input)\n          {leaf-root ::root :as graph'} (compute-resolver-leaf graph env resolvers)]\n      (if leaf-root\n        (if (seq (merge missing missing-opts))\n          (let [graph-with-deps (compute-missing-chain\n                                  graph'\n                                  (-> env\n                                      (assoc ::recursive-joins (index-recursive-joins env resolvers))\n                                      (update ::snapshot-depth #(inc (or % 0))))\n                                  missing\n                                  missing-opts)]\n            (cond\n              (= (::root graph-with-deps) leaf-root)\n              (-> graph-with-deps\n                  (add-snapshot! env {::snapshot-event   ::snapshot-chained-no-nodes\n                                      ::snapshot-message \"Chained deps without adding nodes\"\n                                      ::highlight-nodes  #{leaf-root}}))\n\n              (::root graph-with-deps)\n              (let [tail-node-id (::node-id (find-leaf-node graph-with-deps (get-root-node graph-with-deps)))]\n                (-> (set-node-run-next graph-with-deps tail-node-id leaf-root)\n                    (add-snapshot! env {::snapshot-event   ::snapshot-chained-dependencies\n                                        ::snapshot-message \"Chained deps\"\n                                        ::highlight-nodes  (into #{} [tail-node-id leaf-root])})))\n\n              :else\n              (-> graph\n                  (merge-unreachable graph-with-deps))))\n          graph')\n        graph))))\n\n(defn compute-attribute-graph*\n  \"Traverse the attribute options, for example, considering we are processing the\n  attribute `:a`. And we have this index:\n\n      {::pci/index-oir {:a {{} #{a}}}}\n\n  This means we are now at the `{{} #{a}}` part, lets call each entry of this map a\n  `process path`.\n\n  To break it down, in this case we have one `process path` to get `:a`. Each process\n  pair contains an input shape and a set of resolvers.\n\n  You can read it as: I can fetch `:a` providing the data `{}` to the resolver `a`.\n\n  A bigger example:\n\n      {::pci/index-oir {:a {{:b {}} #{a-from-b}\n                            {:c {}} #{a-from-c a-f-c}}}}\n\n  In this case we have two process paths.\n\n  This function iterates over each process path, if at least one can complete the path,\n  it returns a graph with a root o the node. In case of many options, an OR node will\n  be the root, providing each path.\"\n  [graph\n   {::pci/keys    [index-oir]\n    ::p.attr/keys [attribute]\n    :as           env}]\n  (let [graph (add-snapshot! graph env {::snapshot-event   ::snapshot-process-attribute\n                                        ::snapshot-message (str \"Process attribute \" attribute)})\n\n        [graph' node-ids unreachable-graphs]\n        (reduce-kv\n          (fn [[graph nodes unreachable-graphs] input resolvers]\n            (let [graph' (compute-input-resolvers-graph (dissoc graph ::root) env input resolvers)]\n              (if (::root graph')\n                [graph' (conj nodes (::root graph')) unreachable-graphs]\n                [graph nodes (conj unreachable-graphs graph')])))\n          [graph #{} #{}]\n          (get index-oir attribute))]\n    (if (seq node-ids)\n      (create-root-or graph' env node-ids)\n      (-> graph\n          (add-unreachable-path env {attribute {}})\n          (as-> <>\n            (reduce\n              merge-unreachable\n              <>\n              unreachable-graphs))))))\n\n(defn compute-attribute-graph\n  \"Compute the run graph for a given attribute.\"\n  [{::keys [unreachable-paths] :as graph}\n   {::keys      [attr-deps-trail]\n    ::pci/keys  [index-oir]\n    {attr :key} :edn-query-language.ast/node\n    :as         env}]\n  (let [env (assoc env ::p.attr/attribute attr)]\n    (cond\n      (contains? unreachable-paths attr)\n      (add-snapshot! graph env {::snapshot-event   ::snapshot-attribute-unreachable\n                                ::snapshot-message (str \"Attribute unreachable \" attr)})\n\n      (contains? attr-deps-trail attr)\n      (add-snapshot! graph env {::snapshot-event   ::snapshot-attribute-cycle-dependency\n                                ::snapshot-message (str \"Attribute cycle detected for \" attr)})\n\n      ; its part of the index, traverse the options. this process also compute the\n      ; dependencies for this attribute\n      (contains? index-oir attr)\n      (compute-attribute-graph* graph env)\n\n      :else\n      (add-unreachable-path graph env {attr {}}))))\n\n(defn compute-non-index-attribute\n  \"This function deals with attributes that are not part of the index execution. The\n  cases here are:\n\n  - EQL idents\n  - Previously available data\n  - Placeholders\"\n  [graph\n   {::keys     [available-data]\n    {attr :key\n     :as  ast} :edn-query-language.ast/node\n    :as        env}]\n  (cond\n    (eql/ident? attr)\n    (-> (add-ident-process graph ast)\n        (add-snapshot! env {::snapshot-event   ::snapshot-add-ident-process\n                            ::snapshot-message (str \"Add ident process for \" (pr-str attr))}))\n\n    (contains? available-data attr)\n    (-> (mark-attribute-process-sub-query graph ast)\n        (add-snapshot! env {::snapshot-event   ::snapshot-attribute-already-available\n                            ::snapshot-message (str \"Attribute already available \" attr)}))\n\n    (pph/placeholder-key? env attr)\n    (compute-run-graph* (add-placeholder-entry graph attr) env)))\n\n(defn compute-run-graph*\n  \"Starts scanning the AST to plan for each attribute.\"\n  [graph env]\n  (let [[graph' node-ids]\n        (reduce\n          (fn [[graph node-ids] ast]\n            (cond\n              (contains? #{:prop :join} (:type ast))\n              (let [env (assoc env :edn-query-language.ast/node ast)]\n                (or\n                  ; try to compute a non-index attribute\n                  (if-let [{::keys [root] :as graph'} (compute-non-index-attribute graph env)]\n                    [graph' (cond-> node-ids root (conj root))])\n\n                  ; try to figure the attribute from the indexes\n                  (let [{::keys [root] :as graph'}\n                        (compute-attribute-graph graph\n                          (assoc env :edn-query-language.ast/node ast))]\n                    (if root\n                      ; success\n                      [graph' (conj node-ids root)]\n                      ; failed, collect unreachables\n                      [(merge-unreachable graph graph') node-ids]))))\n\n              ; process mutation\n              (refs/kw-identical? (:type ast) :call)\n              [(update graph ::mutations coll/vconj (:key ast)) node-ids]\n\n              :else\n              [graph node-ids]))\n          [graph #{}]\n          (:children (:edn-query-language.ast/node env)))]\n    (if (seq node-ids)\n      (create-root-and graph' env node-ids)\n      graph')))\n\n(>defn compute-run-graph\n  \"Generates a run plan for a given environment, the environment should contain the\n  indexes in it (::pc/index-oir and ::pc/index-resolvers). It computes a plan to execute\n  one level of an AST, the AST must be provided via the key :edn-query-language.ast/node.\n\n      (compute-run-graph (assoc indexes :edn-query-language.ast/node ...))\n\n  The resulting graph will look like this:\n\n      {::nodes                 {1 {::pco/op-name      a\n                                   ::node-id          1\n                                   ::requires         {:a {}}\n                                   ::input            {}\n                                   ::source-for-attrs #{:a}\n                                   ::node-parents      #{3}}\n                                2 {::pco/op-name      b\n                                   ::node-id          2\n                                   ::requires         {:b {}}\n                                   ::input            {}\n                                   ::source-for-attrs #{:b}\n                                   ::node-parents      #{3}}\n                                3 {::node-id  3\n                                   ::requires {:b {} :a {} :c {}}\n                                   ::run-and  #{2 1 4}}\n                                4 {::pco/op-name      c\n                                   ::node-id          4\n                                   ::requires         {:c {}}\n                                   ::input            {}\n                                   ::source-for-attrs #{:c}\n                                   ::node-parents      #{3}}}\n       ::index-resolver->nodes {a #{1} b #{2} c #{4}}\n       ::unreachable-attrs     #{}\n       ::index-attrs           {:a #{1} :b #{2} :c #{4}}\n       ::root                  3}\n  \"\n  ([env]\n   [(s/keys\n      :req [:edn-query-language.ast/node]\n      :opt [::available-data\n            ::pci/index-mutations\n            ::pci/index-oir\n            ::pci/index-resolvers\n            ::plan-cache*])\n    => ::graph]\n   (compute-run-graph {} env))\n\n  ([graph {::keys [optimize-graph?]\n           :or    {optimize-graph? true}\n           :as    env}]\n   [(? (s/keys))\n    (s/keys\n      :req [:edn-query-language.ast/node]\n      :opt [::available-data\n            ::pci/index-mutations\n            ::pci/index-oir\n            ::pci/index-resolvers\n            ::plan-cache*])\n    => ::graph]\n   (add-snapshot! graph env {::snapshot-event   ::snapshot-start-graph\n                             ::snapshot-message \"Start query plan\"})\n\n   (p.cache/cached ::plan-cache* env [(hash (::pci/index-oir env))\n                                      (::available-data env)\n                                      (:edn-query-language.ast/node env)]\n     #(let [env' (-> (merge (base-env) env)\n                     (vary-meta assoc ::original-env env))]\n        (cond->\n          (compute-run-graph*\n            (merge (base-graph)\n                   graph\n                   {::index-ast      (pf.eql/index-ast (:edn-query-language.ast/node env))\n                    ::source-ast     (:edn-query-language.ast/node env)\n                    ::available-data (::available-data env)})\n            env')\n\n          optimize-graph?\n          (optimize-graph env'))))))\n\n; endregion\n\n; region graph optimizations\n\n(defn can-merge-sibling-resolver-nodes?\n  [graph node-id1 node-id2]\n  (let [n1 (get-node graph node-id1)\n        n2 (get-node graph node-id2)]\n    (and\n      ; is a resolver\n      (::pco/op-name n1)\n      ; same resolver\n      (= (::pco/op-name n1) (::pco/op-name n2)))))\n\n(defn optimize-AND-resolver-siblings\n  [graph env parent-id pivot other-nodes]\n  (let [matching-nodes (into #{}\n                             (filter #(can-merge-sibling-resolver-nodes? graph pivot %))\n                             other-nodes)\n        merge-nodes    (sort (conj matching-nodes pivot))\n        graph'         (cond-> graph\n                         (seq matching-nodes)\n                         (merge-sibling-resolver-nodes env parent-id merge-nodes))]\n    [; optimize the new merged node\n     (optimize-node graph' env (first merge-nodes))\n     (into #{} (remove matching-nodes) other-nodes)]))\n\n(defn optimize-AND-resolvers-pass\n  \"This pass will collapse the same resolver node branches. This also do a local optimization\n  on AND's and OR's sub-nodes. This is important to simplify the pass to merge OR nodes.\"\n  [graph env sibling-ids parent-id]\n  (loop [graph graph\n         [pivot & node-ids] sibling-ids]\n    (if pivot\n      (cond\n        (get-node graph pivot ::pco/op-name)\n        (let [[graph' node-ids'] (optimize-AND-resolver-siblings graph env parent-id pivot node-ids)]\n          (recur graph' node-ids'))\n\n        :else\n        (recur\n          (optimize-node graph env pivot)\n          node-ids))\n      graph)))\n\n(defn optimize-AND-ORs [graph _env sibling-ids _parent-id]\n  (let [or-nodes (into []\n                       (keep\n                         #(let [node (get-node graph %)]\n                            (if (::run-or node) node)))\n                       sibling-ids)]\n    (if (> (count or-nodes) 1)\n      (loop [graph graph\n             [pivot & other-nodes] or-nodes]\n        (reduce\n          (fn [graph or-node]\n            ; TODO need more checks\n            (if (= (count (::run-or pivot))\n                   (count (::run-or or-node)))\n              ; TODO need to figure how to merge the nodes\n              graph\n              graph))\n          graph\n          other-nodes))\n      graph)))\n\n(defn optimize-AND-branches\n  [graph env node-id]\n  (let [{::keys [run-and]} (get-node graph node-id)]\n    (-> graph\n        (optimize-AND-resolvers-pass env run-and node-id)\n        ;(optimize-AND-ORs env run-and node-id)\n        (simplify-branch-node env node-id))))\n\n(defn optimize-OR-branches [graph env node-id]\n  (let [{::keys [run-or]} (get-node graph node-id)]\n    (reduce\n      (fn [graph node-id]\n        (optimize-node graph env node-id))\n      graph\n      run-or)))\n\n(defn optimize-node\n  [graph env node-id]\n  (if-let [node (get-node graph node-id)]\n    (do\n      (add-snapshot! graph env {::snapshot-message (str \"Visit node \" node-id)\n                                ::highlight-nodes  #{node-id}})\n      (recur\n        (case (node-kind node)\n          ::node-resolver\n          graph\n\n          ::node-and\n          (optimize-AND-branches graph env node-id)\n\n          ::node-or\n          (optimize-OR-branches graph env node-id))\n        env\n        (::run-next node)))\n    graph))\n\n(defn optimize-graph\n  [graph env]\n  (-> graph\n      (add-snapshot! env {::snapshot-message \"=== Optimize ===\"})\n      (optimize-node env (::root graph))))\n\n; endregion\n\n(>defn with-plan-cache\n  ([env] [map? => map?] (with-plan-cache env (atom {})))\n  ([env cache*] [map? p.cache/cache-store? => map?] (assoc env ::plan-cache* cache*)))\n\n(defn compute-plan-snapshots\n  \"Run compute graph capturing snapshots, return the snapshots vector in the end.\"\n  [env]\n  (let [snapshots* (atom [])\n        graph      (try\n                     (compute-run-graph\n                       (assoc (dissoc env ::plan-cache*) ::snapshots* snapshots*))\n                     (catch #?(:clj Throwable :cljs :default) e\n                       {::snapshot-message (str \"Planning stopped due to an error: \" (ex-message e))\n                        :error             e}))]\n    (conj @snapshots* (assoc graph ::snapshot-message \"Complete graph.\"))))\n"]}